/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/howler/dist/howler.js":
/*!********************************************!*\
  !*** ./node_modules/howler/dist/howler.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n *  howler.js v2.2.4\n *  howlerjs.com\n *\n *  (c) 2013-2020, James Simpson of GoldFire Studios\n *  goldfirestudios.com\n *\n *  MIT License\n */\n\n(function () {\n  'use strict';\n\n  /** Global Methods **/\n  /***************************************************************************/\n\n  /**\n   * Create the global controller. All contained methods and properties apply\n   * to all sounds that are currently playing or will be in the future.\n   */\n  var HowlerGlobal = function () {\n    this.init();\n  };\n  HowlerGlobal.prototype = {\n    /**\n     * Initialize the global Howler object.\n     * @return {Howler}\n     */\n    init: function () {\n      var self = this || Howler;\n\n      // Create a global ID counter.\n      self._counter = 1000;\n\n      // Pool of unlocked HTML5 Audio objects.\n      self._html5AudioPool = [];\n      self.html5PoolSize = 10;\n\n      // Internal properties.\n      self._codecs = {};\n      self._howls = [];\n      self._muted = false;\n      self._volume = 1;\n      self._canPlayEvent = 'canplaythrough';\n      self._navigator = typeof window !== 'undefined' && window.navigator ? window.navigator : null;\n\n      // Public properties.\n      self.masterGain = null;\n      self.noAudio = false;\n      self.usingWebAudio = true;\n      self.autoSuspend = true;\n      self.ctx = null;\n\n      // Set to false to disable the auto audio unlocker.\n      self.autoUnlock = true;\n\n      // Setup the various state values for global tracking.\n      self._setup();\n      return self;\n    },\n    /**\n     * Get/set the global volume for all sounds.\n     * @param  {Float} vol Volume from 0.0 to 1.0.\n     * @return {Howler/Float}     Returns self or current volume.\n     */\n    volume: function (vol) {\n      var self = this || Howler;\n      vol = parseFloat(vol);\n\n      // If we don't have an AudioContext created yet, run the setup.\n      if (!self.ctx) {\n        setupAudioContext();\n      }\n      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {\n        self._volume = vol;\n\n        // Don't update any of the nodes if we are muted.\n        if (self._muted) {\n          return self;\n        }\n\n        // When using Web Audio, we just need to adjust the master gain.\n        if (self.usingWebAudio) {\n          self.masterGain.gain.setValueAtTime(vol, Howler.ctx.currentTime);\n        }\n\n        // Loop through and change volume for all HTML5 audio nodes.\n        for (var i = 0; i < self._howls.length; i++) {\n          if (!self._howls[i]._webAudio) {\n            // Get all of the sounds in this Howl group.\n            var ids = self._howls[i]._getSoundIds();\n\n            // Loop through all sounds and change the volumes.\n            for (var j = 0; j < ids.length; j++) {\n              var sound = self._howls[i]._soundById(ids[j]);\n              if (sound && sound._node) {\n                sound._node.volume = sound._volume * vol;\n              }\n            }\n          }\n        }\n        return self;\n      }\n      return self._volume;\n    },\n    /**\n     * Handle muting and unmuting globally.\n     * @param  {Boolean} muted Is muted or not.\n     */\n    mute: function (muted) {\n      var self = this || Howler;\n\n      // If we don't have an AudioContext created yet, run the setup.\n      if (!self.ctx) {\n        setupAudioContext();\n      }\n      self._muted = muted;\n\n      // With Web Audio, we just need to mute the master gain.\n      if (self.usingWebAudio) {\n        self.masterGain.gain.setValueAtTime(muted ? 0 : self._volume, Howler.ctx.currentTime);\n      }\n\n      // Loop through and mute all HTML5 Audio nodes.\n      for (var i = 0; i < self._howls.length; i++) {\n        if (!self._howls[i]._webAudio) {\n          // Get all of the sounds in this Howl group.\n          var ids = self._howls[i]._getSoundIds();\n\n          // Loop through all sounds and mark the audio node as muted.\n          for (var j = 0; j < ids.length; j++) {\n            var sound = self._howls[i]._soundById(ids[j]);\n            if (sound && sound._node) {\n              sound._node.muted = muted ? true : sound._muted;\n            }\n          }\n        }\n      }\n      return self;\n    },\n    /**\n     * Handle stopping all sounds globally.\n     */\n    stop: function () {\n      var self = this || Howler;\n\n      // Loop through all Howls and stop them.\n      for (var i = 0; i < self._howls.length; i++) {\n        self._howls[i].stop();\n      }\n      return self;\n    },\n    /**\n     * Unload and destroy all currently loaded Howl objects.\n     * @return {Howler}\n     */\n    unload: function () {\n      var self = this || Howler;\n      for (var i = self._howls.length - 1; i >= 0; i--) {\n        self._howls[i].unload();\n      }\n\n      // Create a new AudioContext to make sure it is fully reset.\n      if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== 'undefined') {\n        self.ctx.close();\n        self.ctx = null;\n        setupAudioContext();\n      }\n      return self;\n    },\n    /**\n     * Check for codec support of specific extension.\n     * @param  {String} ext Audio file extention.\n     * @return {Boolean}\n     */\n    codecs: function (ext) {\n      return (this || Howler)._codecs[ext.replace(/^x-/, '')];\n    },\n    /**\n     * Setup various state values for global tracking.\n     * @return {Howler}\n     */\n    _setup: function () {\n      var self = this || Howler;\n\n      // Keeps track of the suspend/resume state of the AudioContext.\n      self.state = self.ctx ? self.ctx.state || 'suspended' : 'suspended';\n\n      // Automatically begin the 30-second suspend process\n      self._autoSuspend();\n\n      // Check if audio is available.\n      if (!self.usingWebAudio) {\n        // No audio is available on this system if noAudio is set to true.\n        if (typeof Audio !== 'undefined') {\n          try {\n            var test = new Audio();\n\n            // Check if the canplaythrough event is available.\n            if (typeof test.oncanplaythrough === 'undefined') {\n              self._canPlayEvent = 'canplay';\n            }\n          } catch (e) {\n            self.noAudio = true;\n          }\n        } else {\n          self.noAudio = true;\n        }\n      }\n\n      // Test to make sure audio isn't disabled in Internet Explorer.\n      try {\n        var test = new Audio();\n        if (test.muted) {\n          self.noAudio = true;\n        }\n      } catch (e) {}\n\n      // Check for supported codecs.\n      if (!self.noAudio) {\n        self._setupCodecs();\n      }\n      return self;\n    },\n    /**\n     * Check for browser support for various codecs and cache the results.\n     * @return {Howler}\n     */\n    _setupCodecs: function () {\n      var self = this || Howler;\n      var audioTest = null;\n\n      // Must wrap in a try/catch because IE11 in server mode throws an error.\n      try {\n        audioTest = typeof Audio !== 'undefined' ? new Audio() : null;\n      } catch (err) {\n        return self;\n      }\n      if (!audioTest || typeof audioTest.canPlayType !== 'function') {\n        return self;\n      }\n      var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, '');\n\n      // Opera version <33 has mixed MP3 support, so we need to check for and block it.\n      var ua = self._navigator ? self._navigator.userAgent : '';\n      var checkOpera = ua.match(/OPR\\/(\\d+)/g);\n      var isOldOpera = checkOpera && parseInt(checkOpera[0].split('/')[1], 10) < 33;\n      var checkSafari = ua.indexOf('Safari') !== -1 && ua.indexOf('Chrome') === -1;\n      var safariVersion = ua.match(/Version\\/(.*?) /);\n      var isOldSafari = checkSafari && safariVersion && parseInt(safariVersion[1], 10) < 15;\n      self._codecs = {\n        mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),\n        mpeg: !!mpegTest,\n        opus: !!audioTest.canPlayType('audio/ogg; codecs=\"opus\"').replace(/^no$/, ''),\n        ogg: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, ''),\n        oga: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, ''),\n        wav: !!(audioTest.canPlayType('audio/wav; codecs=\"1\"') || audioTest.canPlayType('audio/wav')).replace(/^no$/, ''),\n        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),\n        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),\n        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\n        m4b: !!(audioTest.canPlayType('audio/x-m4b;') || audioTest.canPlayType('audio/m4b;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\n        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\n        weba: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, '')),\n        webm: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, '')),\n        dolby: !!audioTest.canPlayType('audio/mp4; codecs=\"ec-3\"').replace(/^no$/, ''),\n        flac: !!(audioTest.canPlayType('audio/x-flac;') || audioTest.canPlayType('audio/flac;')).replace(/^no$/, '')\n      };\n      return self;\n    },\n    /**\n     * Some browsers/devices will only allow audio to be played after a user interaction.\n     * Attempt to automatically unlock audio on the first user interaction.\n     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/\n     * @return {Howler}\n     */\n    _unlockAudio: function () {\n      var self = this || Howler;\n\n      // Only run this if Web Audio is supported and it hasn't already been unlocked.\n      if (self._audioUnlocked || !self.ctx) {\n        return;\n      }\n      self._audioUnlocked = false;\n      self.autoUnlock = false;\n\n      // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.\n      // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.\n      // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.\n      if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {\n        self._mobileUnloaded = true;\n        self.unload();\n      }\n\n      // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:\n      // http://stackoverflow.com/questions/24119684\n      self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);\n\n      // Call this method on touch start to create and play a buffer,\n      // then check if the audio actually played to determine if\n      // audio has now been unlocked on iOS, Android, etc.\n      var unlock = function (e) {\n        // Create a pool of unlocked HTML5 Audio objects that can\n        // be used for playing sounds without user interaction. HTML5\n        // Audio objects must be individually unlocked, as opposed\n        // to the WebAudio API which only needs a single activation.\n        // This must occur before WebAudio setup or the source.onended\n        // event will not fire.\n        while (self._html5AudioPool.length < self.html5PoolSize) {\n          try {\n            var audioNode = new Audio();\n\n            // Mark this Audio object as unlocked to ensure it can get returned\n            // to the unlocked pool when released.\n            audioNode._unlocked = true;\n\n            // Add the audio node to the pool.\n            self._releaseHtml5Audio(audioNode);\n          } catch (e) {\n            self.noAudio = true;\n            break;\n          }\n        }\n\n        // Loop through any assigned audio nodes and unlock them.\n        for (var i = 0; i < self._howls.length; i++) {\n          if (!self._howls[i]._webAudio) {\n            // Get all of the sounds in this Howl group.\n            var ids = self._howls[i]._getSoundIds();\n\n            // Loop through all sounds and unlock the audio nodes.\n            for (var j = 0; j < ids.length; j++) {\n              var sound = self._howls[i]._soundById(ids[j]);\n              if (sound && sound._node && !sound._node._unlocked) {\n                sound._node._unlocked = true;\n                sound._node.load();\n              }\n            }\n          }\n        }\n\n        // Fix Android can not play in suspend state.\n        self._autoResume();\n\n        // Create an empty buffer.\n        var source = self.ctx.createBufferSource();\n        source.buffer = self._scratchBuffer;\n        source.connect(self.ctx.destination);\n\n        // Play the empty buffer.\n        if (typeof source.start === 'undefined') {\n          source.noteOn(0);\n        } else {\n          source.start(0);\n        }\n\n        // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.\n        if (typeof self.ctx.resume === 'function') {\n          self.ctx.resume();\n        }\n\n        // Setup a timeout to check that we are unlocked on the next event loop.\n        source.onended = function () {\n          source.disconnect(0);\n\n          // Update the unlocked state and prevent this check from happening again.\n          self._audioUnlocked = true;\n\n          // Remove the touch start listener.\n          document.removeEventListener('touchstart', unlock, true);\n          document.removeEventListener('touchend', unlock, true);\n          document.removeEventListener('click', unlock, true);\n          document.removeEventListener('keydown', unlock, true);\n\n          // Let all sounds know that audio has been unlocked.\n          for (var i = 0; i < self._howls.length; i++) {\n            self._howls[i]._emit('unlock');\n          }\n        };\n      };\n\n      // Setup a touch start listener to attempt an unlock in.\n      document.addEventListener('touchstart', unlock, true);\n      document.addEventListener('touchend', unlock, true);\n      document.addEventListener('click', unlock, true);\n      document.addEventListener('keydown', unlock, true);\n      return self;\n    },\n    /**\n     * Get an unlocked HTML5 Audio object from the pool. If none are left,\n     * return a new Audio object and throw a warning.\n     * @return {Audio} HTML5 Audio object.\n     */\n    _obtainHtml5Audio: function () {\n      var self = this || Howler;\n\n      // Return the next object from the pool if one exists.\n      if (self._html5AudioPool.length) {\n        return self._html5AudioPool.pop();\n      }\n\n      //.Check if the audio is locked and throw a warning.\n      var testPlay = new Audio().play();\n      if (testPlay && typeof Promise !== 'undefined' && (testPlay instanceof Promise || typeof testPlay.then === 'function')) {\n        testPlay.catch(function () {\n          console.warn('HTML5 Audio pool exhausted, returning potentially locked audio object.');\n        });\n      }\n      return new Audio();\n    },\n    /**\n     * Return an activated HTML5 Audio object to the pool.\n     * @return {Howler}\n     */\n    _releaseHtml5Audio: function (audio) {\n      var self = this || Howler;\n\n      // Don't add audio to the pool if we don't know if it has been unlocked.\n      if (audio._unlocked) {\n        self._html5AudioPool.push(audio);\n      }\n      return self;\n    },\n    /**\n     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.\n     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.\n     * @return {Howler}\n     */\n    _autoSuspend: function () {\n      var self = this;\n      if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === 'undefined' || !Howler.usingWebAudio) {\n        return;\n      }\n\n      // Check if any sounds are playing.\n      for (var i = 0; i < self._howls.length; i++) {\n        if (self._howls[i]._webAudio) {\n          for (var j = 0; j < self._howls[i]._sounds.length; j++) {\n            if (!self._howls[i]._sounds[j]._paused) {\n              return self;\n            }\n          }\n        }\n      }\n      if (self._suspendTimer) {\n        clearTimeout(self._suspendTimer);\n      }\n\n      // If no sound has played after 30 seconds, suspend the context.\n      self._suspendTimer = setTimeout(function () {\n        if (!self.autoSuspend) {\n          return;\n        }\n        self._suspendTimer = null;\n        self.state = 'suspending';\n\n        // Handle updating the state of the audio context after suspending.\n        var handleSuspension = function () {\n          self.state = 'suspended';\n          if (self._resumeAfterSuspend) {\n            delete self._resumeAfterSuspend;\n            self._autoResume();\n          }\n        };\n\n        // Either the state gets suspended or it is interrupted.\n        // Either way, we need to update the state to suspended.\n        self.ctx.suspend().then(handleSuspension, handleSuspension);\n      }, 30000);\n      return self;\n    },\n    /**\n     * Automatically resume the Web Audio AudioContext when a new sound is played.\n     * @return {Howler}\n     */\n    _autoResume: function () {\n      var self = this;\n      if (!self.ctx || typeof self.ctx.resume === 'undefined' || !Howler.usingWebAudio) {\n        return;\n      }\n      if (self.state === 'running' && self.ctx.state !== 'interrupted' && self._suspendTimer) {\n        clearTimeout(self._suspendTimer);\n        self._suspendTimer = null;\n      } else if (self.state === 'suspended' || self.state === 'running' && self.ctx.state === 'interrupted') {\n        self.ctx.resume().then(function () {\n          self.state = 'running';\n\n          // Emit to all Howls that the audio has resumed.\n          for (var i = 0; i < self._howls.length; i++) {\n            self._howls[i]._emit('resume');\n          }\n        });\n        if (self._suspendTimer) {\n          clearTimeout(self._suspendTimer);\n          self._suspendTimer = null;\n        }\n      } else if (self.state === 'suspending') {\n        self._resumeAfterSuspend = true;\n      }\n      return self;\n    }\n  };\n\n  // Setup the global audio controller.\n  var Howler = new HowlerGlobal();\n\n  /** Group Methods **/\n  /***************************************************************************/\n\n  /**\n   * Create an audio group controller.\n   * @param {Object} o Passed in properties for this group.\n   */\n  var Howl = function (o) {\n    var self = this;\n\n    // Throw an error if no source is provided.\n    if (!o.src || o.src.length === 0) {\n      console.error('An array of source files must be passed with any new Howl.');\n      return;\n    }\n    self.init(o);\n  };\n  Howl.prototype = {\n    /**\n     * Initialize a new Howl group object.\n     * @param  {Object} o Passed in properties for this group.\n     * @return {Howl}\n     */\n    init: function (o) {\n      var self = this;\n\n      // If we don't have an AudioContext created yet, run the setup.\n      if (!Howler.ctx) {\n        setupAudioContext();\n      }\n\n      // Setup user-defined default properties.\n      self._autoplay = o.autoplay || false;\n      self._format = typeof o.format !== 'string' ? o.format : [o.format];\n      self._html5 = o.html5 || false;\n      self._muted = o.mute || false;\n      self._loop = o.loop || false;\n      self._pool = o.pool || 5;\n      self._preload = typeof o.preload === 'boolean' || o.preload === 'metadata' ? o.preload : true;\n      self._rate = o.rate || 1;\n      self._sprite = o.sprite || {};\n      self._src = typeof o.src !== 'string' ? o.src : [o.src];\n      self._volume = o.volume !== undefined ? o.volume : 1;\n      self._xhr = {\n        method: o.xhr && o.xhr.method ? o.xhr.method : 'GET',\n        headers: o.xhr && o.xhr.headers ? o.xhr.headers : null,\n        withCredentials: o.xhr && o.xhr.withCredentials ? o.xhr.withCredentials : false\n      };\n\n      // Setup all other default properties.\n      self._duration = 0;\n      self._state = 'unloaded';\n      self._sounds = [];\n      self._endTimers = {};\n      self._queue = [];\n      self._playLock = false;\n\n      // Setup event listeners.\n      self._onend = o.onend ? [{\n        fn: o.onend\n      }] : [];\n      self._onfade = o.onfade ? [{\n        fn: o.onfade\n      }] : [];\n      self._onload = o.onload ? [{\n        fn: o.onload\n      }] : [];\n      self._onloaderror = o.onloaderror ? [{\n        fn: o.onloaderror\n      }] : [];\n      self._onplayerror = o.onplayerror ? [{\n        fn: o.onplayerror\n      }] : [];\n      self._onpause = o.onpause ? [{\n        fn: o.onpause\n      }] : [];\n      self._onplay = o.onplay ? [{\n        fn: o.onplay\n      }] : [];\n      self._onstop = o.onstop ? [{\n        fn: o.onstop\n      }] : [];\n      self._onmute = o.onmute ? [{\n        fn: o.onmute\n      }] : [];\n      self._onvolume = o.onvolume ? [{\n        fn: o.onvolume\n      }] : [];\n      self._onrate = o.onrate ? [{\n        fn: o.onrate\n      }] : [];\n      self._onseek = o.onseek ? [{\n        fn: o.onseek\n      }] : [];\n      self._onunlock = o.onunlock ? [{\n        fn: o.onunlock\n      }] : [];\n      self._onresume = [];\n\n      // Web Audio or HTML5 Audio?\n      self._webAudio = Howler.usingWebAudio && !self._html5;\n\n      // Automatically try to enable audio.\n      if (typeof Howler.ctx !== 'undefined' && Howler.ctx && Howler.autoUnlock) {\n        Howler._unlockAudio();\n      }\n\n      // Keep track of this Howl group in the global controller.\n      Howler._howls.push(self);\n\n      // If they selected autoplay, add a play event to the load queue.\n      if (self._autoplay) {\n        self._queue.push({\n          event: 'play',\n          action: function () {\n            self.play();\n          }\n        });\n      }\n\n      // Load the source file unless otherwise specified.\n      if (self._preload && self._preload !== 'none') {\n        self.load();\n      }\n      return self;\n    },\n    /**\n     * Load the audio file.\n     * @return {Howler}\n     */\n    load: function () {\n      var self = this;\n      var url = null;\n\n      // If no audio is available, quit immediately.\n      if (Howler.noAudio) {\n        self._emit('loaderror', null, 'No audio support.');\n        return;\n      }\n\n      // Make sure our source is in an array.\n      if (typeof self._src === 'string') {\n        self._src = [self._src];\n      }\n\n      // Loop through the sources and pick the first one that is compatible.\n      for (var i = 0; i < self._src.length; i++) {\n        var ext, str;\n        if (self._format && self._format[i]) {\n          // If an extension was specified, use that instead.\n          ext = self._format[i];\n        } else {\n          // Make sure the source is a string.\n          str = self._src[i];\n          if (typeof str !== 'string') {\n            self._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');\n            continue;\n          }\n\n          // Extract the file extension from the URL or base64 data URI.\n          ext = /^data:audio\\/([^;,]+);/i.exec(str);\n          if (!ext) {\n            ext = /\\.([^.]+)$/.exec(str.split('?', 1)[0]);\n          }\n          if (ext) {\n            ext = ext[1].toLowerCase();\n          }\n        }\n\n        // Log a warning if no extension was found.\n        if (!ext) {\n          console.warn('No file extension was found. Consider using the \"format\" property or specify an extension.');\n        }\n\n        // Check if this extension is available.\n        if (ext && Howler.codecs(ext)) {\n          url = self._src[i];\n          break;\n        }\n      }\n      if (!url) {\n        self._emit('loaderror', null, 'No codec support for selected audio sources.');\n        return;\n      }\n      self._src = url;\n      self._state = 'loading';\n\n      // If the hosting page is HTTPS and the source isn't,\n      // drop down to HTML5 Audio to avoid Mixed Content errors.\n      if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {\n        self._html5 = true;\n        self._webAudio = false;\n      }\n\n      // Create a new sound object and add it to the pool.\n      new Sound(self);\n\n      // Load and decode the audio data for playback.\n      if (self._webAudio) {\n        loadBuffer(self);\n      }\n      return self;\n    },\n    /**\n     * Play a sound or resume previous playback.\n     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.\n     * @param  {Boolean} internal Internal Use: true prevents event firing.\n     * @return {Number}          Sound ID.\n     */\n    play: function (sprite, internal) {\n      var self = this;\n      var id = null;\n\n      // Determine if a sprite, sound id or nothing was passed\n      if (typeof sprite === 'number') {\n        id = sprite;\n        sprite = null;\n      } else if (typeof sprite === 'string' && self._state === 'loaded' && !self._sprite[sprite]) {\n        // If the passed sprite doesn't exist, do nothing.\n        return null;\n      } else if (typeof sprite === 'undefined') {\n        // Use the default sound sprite (plays the full audio length).\n        sprite = '__default';\n\n        // Check if there is a single paused sound that isn't ended.\n        // If there is, play that sound. If not, continue as usual.\n        if (!self._playLock) {\n          var num = 0;\n          for (var i = 0; i < self._sounds.length; i++) {\n            if (self._sounds[i]._paused && !self._sounds[i]._ended) {\n              num++;\n              id = self._sounds[i]._id;\n            }\n          }\n          if (num === 1) {\n            sprite = null;\n          } else {\n            id = null;\n          }\n        }\n      }\n\n      // Get the selected node, or get one from the pool.\n      var sound = id ? self._soundById(id) : self._inactiveSound();\n\n      // If the sound doesn't exist, do nothing.\n      if (!sound) {\n        return null;\n      }\n\n      // Select the sprite definition.\n      if (id && !sprite) {\n        sprite = sound._sprite || '__default';\n      }\n\n      // If the sound hasn't loaded, we must wait to get the audio's duration.\n      // We also need to wait to make sure we don't run into race conditions with\n      // the order of function calls.\n      if (self._state !== 'loaded') {\n        // Set the sprite value on this sound.\n        sound._sprite = sprite;\n\n        // Mark this sound as not ended in case another sound is played before this one loads.\n        sound._ended = false;\n\n        // Add the sound to the queue to be played on load.\n        var soundId = sound._id;\n        self._queue.push({\n          event: 'play',\n          action: function () {\n            self.play(soundId);\n          }\n        });\n        return soundId;\n      }\n\n      // Don't play the sound if an id was passed and it is already playing.\n      if (id && !sound._paused) {\n        // Trigger the play event, in order to keep iterating through queue.\n        if (!internal) {\n          self._loadQueue('play');\n        }\n        return sound._id;\n      }\n\n      // Make sure the AudioContext isn't suspended, and resume it if it is.\n      if (self._webAudio) {\n        Howler._autoResume();\n      }\n\n      // Determine how long to play for and where to start playing.\n      var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000);\n      var duration = Math.max(0, (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000 - seek);\n      var timeout = duration * 1000 / Math.abs(sound._rate);\n      var start = self._sprite[sprite][0] / 1000;\n      var stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;\n      sound._sprite = sprite;\n\n      // Mark the sound as ended instantly so that this async playback\n      // doesn't get grabbed by another call to play while this one waits to start.\n      sound._ended = false;\n\n      // Update the parameters of the sound.\n      var setParams = function () {\n        sound._paused = false;\n        sound._seek = seek;\n        sound._start = start;\n        sound._stop = stop;\n        sound._loop = !!(sound._loop || self._sprite[sprite][2]);\n      };\n\n      // End the sound instantly if seek is at the end.\n      if (seek >= stop) {\n        self._ended(sound);\n        return;\n      }\n\n      // Begin the actual playback.\n      var node = sound._node;\n      if (self._webAudio) {\n        // Fire this when the sound is ready to play to begin Web Audio playback.\n        var playWebAudio = function () {\n          self._playLock = false;\n          setParams();\n          self._refreshBuffer(sound);\n\n          // Setup the playback params.\n          var vol = sound._muted || self._muted ? 0 : sound._volume;\n          node.gain.setValueAtTime(vol, Howler.ctx.currentTime);\n          sound._playStart = Howler.ctx.currentTime;\n\n          // Play the sound using the supported method.\n          if (typeof node.bufferSource.start === 'undefined') {\n            sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);\n          } else {\n            sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);\n          }\n\n          // Start a new timer if none is present.\n          if (timeout !== Infinity) {\n            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n          }\n          if (!internal) {\n            setTimeout(function () {\n              self._emit('play', sound._id);\n              self._loadQueue();\n            }, 0);\n          }\n        };\n        if (Howler.state === 'running' && Howler.ctx.state !== 'interrupted') {\n          playWebAudio();\n        } else {\n          self._playLock = true;\n\n          // Wait for the audio context to resume before playing.\n          self.once('resume', playWebAudio);\n\n          // Cancel the end timer.\n          self._clearTimer(sound._id);\n        }\n      } else {\n        // Fire this when the sound is ready to play to begin HTML5 Audio playback.\n        var playHtml5 = function () {\n          node.currentTime = seek;\n          node.muted = sound._muted || self._muted || Howler._muted || node.muted;\n          node.volume = sound._volume * Howler.volume();\n          node.playbackRate = sound._rate;\n\n          // Some browsers will throw an error if this is called without user interaction.\n          try {\n            var play = node.play();\n\n            // Support older browsers that don't support promises, and thus don't have this issue.\n            if (play && typeof Promise !== 'undefined' && (play instanceof Promise || typeof play.then === 'function')) {\n              // Implements a lock to prevent DOMException: The play() request was interrupted by a call to pause().\n              self._playLock = true;\n\n              // Set param values immediately.\n              setParams();\n\n              // Releases the lock and executes queued actions.\n              play.then(function () {\n                self._playLock = false;\n                node._unlocked = true;\n                if (!internal) {\n                  self._emit('play', sound._id);\n                } else {\n                  self._loadQueue();\n                }\n              }).catch(function () {\n                self._playLock = false;\n                self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' + 'on mobile devices and Chrome where playback was not within a user interaction.');\n\n                // Reset the ended and paused values.\n                sound._ended = true;\n                sound._paused = true;\n              });\n            } else if (!internal) {\n              self._playLock = false;\n              setParams();\n              self._emit('play', sound._id);\n            }\n\n            // Setting rate before playing won't work in IE, so we set it again here.\n            node.playbackRate = sound._rate;\n\n            // If the node is still paused, then we can assume there was a playback issue.\n            if (node.paused) {\n              self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' + 'on mobile devices and Chrome where playback was not within a user interaction.');\n              return;\n            }\n\n            // Setup the end timer on sprites or listen for the ended event.\n            if (sprite !== '__default' || sound._loop) {\n              self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n            } else {\n              self._endTimers[sound._id] = function () {\n                // Fire ended on this audio node.\n                self._ended(sound);\n\n                // Clear this listener.\n                node.removeEventListener('ended', self._endTimers[sound._id], false);\n              };\n              node.addEventListener('ended', self._endTimers[sound._id], false);\n            }\n          } catch (err) {\n            self._emit('playerror', sound._id, err);\n          }\n        };\n\n        // If this is streaming audio, make sure the src is set and load again.\n        if (node.src === 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA') {\n          node.src = self._src;\n          node.load();\n        }\n\n        // Play immediately if ready, or wait for the 'canplaythrough'e vent.\n        var loadedNoReadyState = window && window.ejecta || !node.readyState && Howler._navigator.isCocoonJS;\n        if (node.readyState >= 3 || loadedNoReadyState) {\n          playHtml5();\n        } else {\n          self._playLock = true;\n          self._state = 'loading';\n          var listener = function () {\n            self._state = 'loaded';\n\n            // Begin playback.\n            playHtml5();\n\n            // Clear this listener.\n            node.removeEventListener(Howler._canPlayEvent, listener, false);\n          };\n          node.addEventListener(Howler._canPlayEvent, listener, false);\n\n          // Cancel the end timer.\n          self._clearTimer(sound._id);\n        }\n      }\n      return sound._id;\n    },\n    /**\n     * Pause playback and save current position.\n     * @param  {Number} id The sound ID (empty to pause all in group).\n     * @return {Howl}\n     */\n    pause: function (id) {\n      var self = this;\n\n      // If the sound hasn't loaded or a play() promise is pending, add it to the load queue to pause when capable.\n      if (self._state !== 'loaded' || self._playLock) {\n        self._queue.push({\n          event: 'pause',\n          action: function () {\n            self.pause(id);\n          }\n        });\n        return self;\n      }\n\n      // If no id is passed, get all ID's to be paused.\n      var ids = self._getSoundIds(id);\n      for (var i = 0; i < ids.length; i++) {\n        // Clear the end timer.\n        self._clearTimer(ids[i]);\n\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n        if (sound && !sound._paused) {\n          // Reset the seek position.\n          sound._seek = self.seek(ids[i]);\n          sound._rateSeek = 0;\n          sound._paused = true;\n\n          // Stop currently running fades.\n          self._stopFade(ids[i]);\n          if (sound._node) {\n            if (self._webAudio) {\n              // Make sure the sound has been created.\n              if (!sound._node.bufferSource) {\n                continue;\n              }\n              if (typeof sound._node.bufferSource.stop === 'undefined') {\n                sound._node.bufferSource.noteOff(0);\n              } else {\n                sound._node.bufferSource.stop(0);\n              }\n\n              // Clean up the buffer source.\n              self._cleanBuffer(sound._node);\n            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {\n              sound._node.pause();\n            }\n          }\n        }\n\n        // Fire the pause event, unless `true` is passed as the 2nd argument.\n        if (!arguments[1]) {\n          self._emit('pause', sound ? sound._id : null);\n        }\n      }\n      return self;\n    },\n    /**\n     * Stop playback and reset to start.\n     * @param  {Number} id The sound ID (empty to stop all in group).\n     * @param  {Boolean} internal Internal Use: true prevents event firing.\n     * @return {Howl}\n     */\n    stop: function (id, internal) {\n      var self = this;\n\n      // If the sound hasn't loaded, add it to the load queue to stop when capable.\n      if (self._state !== 'loaded' || self._playLock) {\n        self._queue.push({\n          event: 'stop',\n          action: function () {\n            self.stop(id);\n          }\n        });\n        return self;\n      }\n\n      // If no id is passed, get all ID's to be stopped.\n      var ids = self._getSoundIds(id);\n      for (var i = 0; i < ids.length; i++) {\n        // Clear the end timer.\n        self._clearTimer(ids[i]);\n\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n        if (sound) {\n          // Reset the seek position.\n          sound._seek = sound._start || 0;\n          sound._rateSeek = 0;\n          sound._paused = true;\n          sound._ended = true;\n\n          // Stop currently running fades.\n          self._stopFade(ids[i]);\n          if (sound._node) {\n            if (self._webAudio) {\n              // Make sure the sound's AudioBufferSourceNode has been created.\n              if (sound._node.bufferSource) {\n                if (typeof sound._node.bufferSource.stop === 'undefined') {\n                  sound._node.bufferSource.noteOff(0);\n                } else {\n                  sound._node.bufferSource.stop(0);\n                }\n\n                // Clean up the buffer source.\n                self._cleanBuffer(sound._node);\n              }\n            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {\n              sound._node.currentTime = sound._start || 0;\n              sound._node.pause();\n\n              // If this is a live stream, stop download once the audio is stopped.\n              if (sound._node.duration === Infinity) {\n                self._clearSound(sound._node);\n              }\n            }\n          }\n          if (!internal) {\n            self._emit('stop', sound._id);\n          }\n        }\n      }\n      return self;\n    },\n    /**\n     * Mute/unmute a single sound or all sounds in this Howl group.\n     * @param  {Boolean} muted Set to true to mute and false to unmute.\n     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).\n     * @return {Howl}\n     */\n    mute: function (muted, id) {\n      var self = this;\n\n      // If the sound hasn't loaded, add it to the load queue to mute when capable.\n      if (self._state !== 'loaded' || self._playLock) {\n        self._queue.push({\n          event: 'mute',\n          action: function () {\n            self.mute(muted, id);\n          }\n        });\n        return self;\n      }\n\n      // If applying mute/unmute to all sounds, update the group's value.\n      if (typeof id === 'undefined') {\n        if (typeof muted === 'boolean') {\n          self._muted = muted;\n        } else {\n          return self._muted;\n        }\n      }\n\n      // If no id is passed, get all ID's to be muted.\n      var ids = self._getSoundIds(id);\n      for (var i = 0; i < ids.length; i++) {\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n        if (sound) {\n          sound._muted = muted;\n\n          // Cancel active fade and set the volume to the end value.\n          if (sound._interval) {\n            self._stopFade(sound._id);\n          }\n          if (self._webAudio && sound._node) {\n            sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);\n          } else if (sound._node) {\n            sound._node.muted = Howler._muted ? true : muted;\n          }\n          self._emit('mute', sound._id);\n        }\n      }\n      return self;\n    },\n    /**\n     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.\n     *   volume() -> Returns the group's volume value.\n     *   volume(id) -> Returns the sound id's current volume.\n     *   volume(vol) -> Sets the volume of all sounds in this Howl group.\n     *   volume(vol, id) -> Sets the volume of passed sound id.\n     * @return {Howl/Number} Returns self or current volume.\n     */\n    volume: function () {\n      var self = this;\n      var args = arguments;\n      var vol, id;\n\n      // Determine the values based on arguments.\n      if (args.length === 0) {\n        // Return the value of the groups' volume.\n        return self._volume;\n      } else if (args.length === 1 || args.length === 2 && typeof args[1] === 'undefined') {\n        // First check if this is an ID, and if not, assume it is a new volume.\n        var ids = self._getSoundIds();\n        var index = ids.indexOf(args[0]);\n        if (index >= 0) {\n          id = parseInt(args[0], 10);\n        } else {\n          vol = parseFloat(args[0]);\n        }\n      } else if (args.length >= 2) {\n        vol = parseFloat(args[0]);\n        id = parseInt(args[1], 10);\n      }\n\n      // Update the volume or return the current volume.\n      var sound;\n      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {\n        // If the sound hasn't loaded, add it to the load queue to change volume when capable.\n        if (self._state !== 'loaded' || self._playLock) {\n          self._queue.push({\n            event: 'volume',\n            action: function () {\n              self.volume.apply(self, args);\n            }\n          });\n          return self;\n        }\n\n        // Set the group volume.\n        if (typeof id === 'undefined') {\n          self._volume = vol;\n        }\n\n        // Update one or all volumes.\n        id = self._getSoundIds(id);\n        for (var i = 0; i < id.length; i++) {\n          // Get the sound.\n          sound = self._soundById(id[i]);\n          if (sound) {\n            sound._volume = vol;\n\n            // Stop currently running fades.\n            if (!args[2]) {\n              self._stopFade(id[i]);\n            }\n            if (self._webAudio && sound._node && !sound._muted) {\n              sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);\n            } else if (sound._node && !sound._muted) {\n              sound._node.volume = vol * Howler.volume();\n            }\n            self._emit('volume', sound._id);\n          }\n        }\n      } else {\n        sound = id ? self._soundById(id) : self._sounds[0];\n        return sound ? sound._volume : 0;\n      }\n      return self;\n    },\n    /**\n     * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).\n     * @param  {Number} from The value to fade from (0.0 to 1.0).\n     * @param  {Number} to   The volume to fade to (0.0 to 1.0).\n     * @param  {Number} len  Time in milliseconds to fade.\n     * @param  {Number} id   The sound id (omit to fade all sounds).\n     * @return {Howl}\n     */\n    fade: function (from, to, len, id) {\n      var self = this;\n\n      // If the sound hasn't loaded, add it to the load queue to fade when capable.\n      if (self._state !== 'loaded' || self._playLock) {\n        self._queue.push({\n          event: 'fade',\n          action: function () {\n            self.fade(from, to, len, id);\n          }\n        });\n        return self;\n      }\n\n      // Make sure the to/from/len values are numbers.\n      from = Math.min(Math.max(0, parseFloat(from)), 1);\n      to = Math.min(Math.max(0, parseFloat(to)), 1);\n      len = parseFloat(len);\n\n      // Set the volume to the start position.\n      self.volume(from, id);\n\n      // Fade the volume of one or all sounds.\n      var ids = self._getSoundIds(id);\n      for (var i = 0; i < ids.length; i++) {\n        // Get the sound.\n        var sound = self._soundById(ids[i]);\n\n        // Create a linear fade or fall back to timeouts with HTML5 Audio.\n        if (sound) {\n          // Stop the previous fade if no sprite is being used (otherwise, volume handles this).\n          if (!id) {\n            self._stopFade(ids[i]);\n          }\n\n          // If we are using Web Audio, let the native methods do the actual fade.\n          if (self._webAudio && !sound._muted) {\n            var currentTime = Howler.ctx.currentTime;\n            var end = currentTime + len / 1000;\n            sound._volume = from;\n            sound._node.gain.setValueAtTime(from, currentTime);\n            sound._node.gain.linearRampToValueAtTime(to, end);\n          }\n          self._startFadeInterval(sound, from, to, len, ids[i], typeof id === 'undefined');\n        }\n      }\n      return self;\n    },\n    /**\n     * Starts the internal interval to fade a sound.\n     * @param  {Object} sound Reference to sound to fade.\n     * @param  {Number} from The value to fade from (0.0 to 1.0).\n     * @param  {Number} to   The volume to fade to (0.0 to 1.0).\n     * @param  {Number} len  Time in milliseconds to fade.\n     * @param  {Number} id   The sound id to fade.\n     * @param  {Boolean} isGroup   If true, set the volume on the group.\n     */\n    _startFadeInterval: function (sound, from, to, len, id, isGroup) {\n      var self = this;\n      var vol = from;\n      var diff = to - from;\n      var steps = Math.abs(diff / 0.01);\n      var stepLen = Math.max(4, steps > 0 ? len / steps : len);\n      var lastTick = Date.now();\n\n      // Store the value being faded to.\n      sound._fadeTo = to;\n\n      // Update the volume value on each interval tick.\n      sound._interval = setInterval(function () {\n        // Update the volume based on the time since the last tick.\n        var tick = (Date.now() - lastTick) / len;\n        lastTick = Date.now();\n        vol += diff * tick;\n\n        // Round to within 2 decimal points.\n        vol = Math.round(vol * 100) / 100;\n\n        // Make sure the volume is in the right bounds.\n        if (diff < 0) {\n          vol = Math.max(to, vol);\n        } else {\n          vol = Math.min(to, vol);\n        }\n\n        // Change the volume.\n        if (self._webAudio) {\n          sound._volume = vol;\n        } else {\n          self.volume(vol, sound._id, true);\n        }\n\n        // Set the group's volume.\n        if (isGroup) {\n          self._volume = vol;\n        }\n\n        // When the fade is complete, stop it and fire event.\n        if (to < from && vol <= to || to > from && vol >= to) {\n          clearInterval(sound._interval);\n          sound._interval = null;\n          sound._fadeTo = null;\n          self.volume(to, sound._id);\n          self._emit('fade', sound._id);\n        }\n      }, stepLen);\n    },\n    /**\n     * Internal method that stops the currently playing fade when\n     * a new fade starts, volume is changed or the sound is stopped.\n     * @param  {Number} id The sound id.\n     * @return {Howl}\n     */\n    _stopFade: function (id) {\n      var self = this;\n      var sound = self._soundById(id);\n      if (sound && sound._interval) {\n        if (self._webAudio) {\n          sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);\n        }\n        clearInterval(sound._interval);\n        sound._interval = null;\n        self.volume(sound._fadeTo, id);\n        sound._fadeTo = null;\n        self._emit('fade', id);\n      }\n      return self;\n    },\n    /**\n     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   loop() -> Returns the group's loop value.\n     *   loop(id) -> Returns the sound id's loop value.\n     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.\n     *   loop(loop, id) -> Sets the loop value of passed sound id.\n     * @return {Howl/Boolean} Returns self or current loop value.\n     */\n    loop: function () {\n      var self = this;\n      var args = arguments;\n      var loop, id, sound;\n\n      // Determine the values for loop and id.\n      if (args.length === 0) {\n        // Return the grou's loop value.\n        return self._loop;\n      } else if (args.length === 1) {\n        if (typeof args[0] === 'boolean') {\n          loop = args[0];\n          self._loop = loop;\n        } else {\n          // Return this sound's loop value.\n          sound = self._soundById(parseInt(args[0], 10));\n          return sound ? sound._loop : false;\n        }\n      } else if (args.length === 2) {\n        loop = args[0];\n        id = parseInt(args[1], 10);\n      }\n\n      // If no id is passed, get all ID's to be looped.\n      var ids = self._getSoundIds(id);\n      for (var i = 0; i < ids.length; i++) {\n        sound = self._soundById(ids[i]);\n        if (sound) {\n          sound._loop = loop;\n          if (self._webAudio && sound._node && sound._node.bufferSource) {\n            sound._node.bufferSource.loop = loop;\n            if (loop) {\n              sound._node.bufferSource.loopStart = sound._start || 0;\n              sound._node.bufferSource.loopEnd = sound._stop;\n\n              // If playing, restart playback to ensure looping updates.\n              if (self.playing(ids[i])) {\n                self.pause(ids[i], true);\n                self.play(ids[i], true);\n              }\n            }\n          }\n        }\n      }\n      return self;\n    },\n    /**\n     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   rate() -> Returns the first sound node's current playback rate.\n     *   rate(id) -> Returns the sound id's current playback rate.\n     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.\n     *   rate(rate, id) -> Sets the playback rate of passed sound id.\n     * @return {Howl/Number} Returns self or the current playback rate.\n     */\n    rate: function () {\n      var self = this;\n      var args = arguments;\n      var rate, id;\n\n      // Determine the values based on arguments.\n      if (args.length === 0) {\n        // We will simply return the current rate of the first node.\n        id = self._sounds[0]._id;\n      } else if (args.length === 1) {\n        // First check if this is an ID, and if not, assume it is a new rate value.\n        var ids = self._getSoundIds();\n        var index = ids.indexOf(args[0]);\n        if (index >= 0) {\n          id = parseInt(args[0], 10);\n        } else {\n          rate = parseFloat(args[0]);\n        }\n      } else if (args.length === 2) {\n        rate = parseFloat(args[0]);\n        id = parseInt(args[1], 10);\n      }\n\n      // Update the playback rate or return the current value.\n      var sound;\n      if (typeof rate === 'number') {\n        // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.\n        if (self._state !== 'loaded' || self._playLock) {\n          self._queue.push({\n            event: 'rate',\n            action: function () {\n              self.rate.apply(self, args);\n            }\n          });\n          return self;\n        }\n\n        // Set the group rate.\n        if (typeof id === 'undefined') {\n          self._rate = rate;\n        }\n\n        // Update one or all volumes.\n        id = self._getSoundIds(id);\n        for (var i = 0; i < id.length; i++) {\n          // Get the sound.\n          sound = self._soundById(id[i]);\n          if (sound) {\n            // Keep track of our position when the rate changed and update the playback\n            // start position so we can properly adjust the seek position for time elapsed.\n            if (self.playing(id[i])) {\n              sound._rateSeek = self.seek(id[i]);\n              sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;\n            }\n            sound._rate = rate;\n\n            // Change the playback rate.\n            if (self._webAudio && sound._node && sound._node.bufferSource) {\n              sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler.ctx.currentTime);\n            } else if (sound._node) {\n              sound._node.playbackRate = rate;\n            }\n\n            // Reset the timers.\n            var seek = self.seek(id[i]);\n            var duration = (self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000 - seek;\n            var timeout = duration * 1000 / Math.abs(sound._rate);\n\n            // Start a new end timer if sound is already playing.\n            if (self._endTimers[id[i]] || !sound._paused) {\n              self._clearTimer(id[i]);\n              self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);\n            }\n            self._emit('rate', sound._id);\n          }\n        }\n      } else {\n        sound = self._soundById(id);\n        return sound ? sound._rate : self._rate;\n      }\n      return self;\n    },\n    /**\n     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.\n     *   seek() -> Returns the first sound node's current seek position.\n     *   seek(id) -> Returns the sound id's current seek position.\n     *   seek(seek) -> Sets the seek position of the first sound node.\n     *   seek(seek, id) -> Sets the seek position of passed sound id.\n     * @return {Howl/Number} Returns self or the current seek position.\n     */\n    seek: function () {\n      var self = this;\n      var args = arguments;\n      var seek, id;\n\n      // Determine the values based on arguments.\n      if (args.length === 0) {\n        // We will simply return the current position of the first node.\n        if (self._sounds.length) {\n          id = self._sounds[0]._id;\n        }\n      } else if (args.length === 1) {\n        // First check if this is an ID, and if not, assume it is a new seek position.\n        var ids = self._getSoundIds();\n        var index = ids.indexOf(args[0]);\n        if (index >= 0) {\n          id = parseInt(args[0], 10);\n        } else if (self._sounds.length) {\n          id = self._sounds[0]._id;\n          seek = parseFloat(args[0]);\n        }\n      } else if (args.length === 2) {\n        seek = parseFloat(args[0]);\n        id = parseInt(args[1], 10);\n      }\n\n      // If there is no ID, bail out.\n      if (typeof id === 'undefined') {\n        return 0;\n      }\n\n      // If the sound hasn't loaded, add it to the load queue to seek when capable.\n      if (typeof seek === 'number' && (self._state !== 'loaded' || self._playLock)) {\n        self._queue.push({\n          event: 'seek',\n          action: function () {\n            self.seek.apply(self, args);\n          }\n        });\n        return self;\n      }\n\n      // Get the sound.\n      var sound = self._soundById(id);\n      if (sound) {\n        if (typeof seek === 'number' && seek >= 0) {\n          // Pause the sound and update position for restarting playback.\n          var playing = self.playing(id);\n          if (playing) {\n            self.pause(id, true);\n          }\n\n          // Move the position of the track and cancel timer.\n          sound._seek = seek;\n          sound._ended = false;\n          self._clearTimer(id);\n\n          // Update the seek position for HTML5 Audio.\n          if (!self._webAudio && sound._node && !isNaN(sound._node.duration)) {\n            sound._node.currentTime = seek;\n          }\n\n          // Seek and emit when ready.\n          var seekAndEmit = function () {\n            // Restart the playback if the sound was playing.\n            if (playing) {\n              self.play(id, true);\n            }\n            self._emit('seek', id);\n          };\n\n          // Wait for the play lock to be unset before emitting (HTML5 Audio).\n          if (playing && !self._webAudio) {\n            var emitSeek = function () {\n              if (!self._playLock) {\n                seekAndEmit();\n              } else {\n                setTimeout(emitSeek, 0);\n              }\n            };\n            setTimeout(emitSeek, 0);\n          } else {\n            seekAndEmit();\n          }\n        } else {\n          if (self._webAudio) {\n            var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;\n            var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;\n            return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));\n          } else {\n            return sound._node.currentTime;\n          }\n        }\n      }\n      return self;\n    },\n    /**\n     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.\n     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.\n     * @return {Boolean} True if playing and false if not.\n     */\n    playing: function (id) {\n      var self = this;\n\n      // Check the passed sound ID (if any).\n      if (typeof id === 'number') {\n        var sound = self._soundById(id);\n        return sound ? !sound._paused : false;\n      }\n\n      // Otherwise, loop through all sounds and check if any are playing.\n      for (var i = 0; i < self._sounds.length; i++) {\n        if (!self._sounds[i]._paused) {\n          return true;\n        }\n      }\n      return false;\n    },\n    /**\n     * Get the duration of this sound. Passing a sound id will return the sprite duration.\n     * @param  {Number} id The sound id to check. If none is passed, return full source duration.\n     * @return {Number} Audio duration in seconds.\n     */\n    duration: function (id) {\n      var self = this;\n      var duration = self._duration;\n\n      // If we pass an ID, get the sound and return the sprite length.\n      var sound = self._soundById(id);\n      if (sound) {\n        duration = self._sprite[sound._sprite][1] / 1000;\n      }\n      return duration;\n    },\n    /**\n     * Returns the current loaded state of this Howl.\n     * @return {String} 'unloaded', 'loading', 'loaded'\n     */\n    state: function () {\n      return this._state;\n    },\n    /**\n     * Unload and destroy the current Howl object.\n     * This will immediately stop all sound instances attached to this group.\n     */\n    unload: function () {\n      var self = this;\n\n      // Stop playing any active sounds.\n      var sounds = self._sounds;\n      for (var i = 0; i < sounds.length; i++) {\n        // Stop the sound if it is currently playing.\n        if (!sounds[i]._paused) {\n          self.stop(sounds[i]._id);\n        }\n\n        // Remove the source or disconnect.\n        if (!self._webAudio) {\n          // Set the source to 0-second silence to stop any downloading (except in IE).\n          self._clearSound(sounds[i]._node);\n\n          // Remove any event listeners.\n          sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);\n          sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);\n          sounds[i]._node.removeEventListener('ended', sounds[i]._endFn, false);\n\n          // Release the Audio object back to the pool.\n          Howler._releaseHtml5Audio(sounds[i]._node);\n        }\n\n        // Empty out all of the nodes.\n        delete sounds[i]._node;\n\n        // Make sure all timers are cleared out.\n        self._clearTimer(sounds[i]._id);\n      }\n\n      // Remove the references in the global Howler object.\n      var index = Howler._howls.indexOf(self);\n      if (index >= 0) {\n        Howler._howls.splice(index, 1);\n      }\n\n      // Delete this sound from the cache (if no other Howl is using it).\n      var remCache = true;\n      for (i = 0; i < Howler._howls.length; i++) {\n        if (Howler._howls[i]._src === self._src || self._src.indexOf(Howler._howls[i]._src) >= 0) {\n          remCache = false;\n          break;\n        }\n      }\n      if (cache && remCache) {\n        delete cache[self._src];\n      }\n\n      // Clear global errors.\n      Howler.noAudio = false;\n\n      // Clear out `self`.\n      self._state = 'unloaded';\n      self._sounds = [];\n      self = null;\n      return null;\n    },\n    /**\n     * Listen to a custom event.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to call.\n     * @param  {Number}   id    (optional) Only listen to events for this sound.\n     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.\n     * @return {Howl}\n     */\n    on: function (event, fn, id, once) {\n      var self = this;\n      var events = self['_on' + event];\n      if (typeof fn === 'function') {\n        events.push(once ? {\n          id: id,\n          fn: fn,\n          once: once\n        } : {\n          id: id,\n          fn: fn\n        });\n      }\n      return self;\n    },\n    /**\n     * Remove a custom event. Call without parameters to remove all events.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to remove. Leave empty to remove all.\n     * @param  {Number}   id    (optional) Only remove events for this sound.\n     * @return {Howl}\n     */\n    off: function (event, fn, id) {\n      var self = this;\n      var events = self['_on' + event];\n      var i = 0;\n\n      // Allow passing just an event and ID.\n      if (typeof fn === 'number') {\n        id = fn;\n        fn = null;\n      }\n      if (fn || id) {\n        // Loop through event store and remove the passed function.\n        for (i = 0; i < events.length; i++) {\n          var isId = id === events[i].id;\n          if (fn === events[i].fn && isId || !fn && isId) {\n            events.splice(i, 1);\n            break;\n          }\n        }\n      } else if (event) {\n        // Clear out all events of this type.\n        self['_on' + event] = [];\n      } else {\n        // Clear out all events of every type.\n        var keys = Object.keys(self);\n        for (i = 0; i < keys.length; i++) {\n          if (keys[i].indexOf('_on') === 0 && Array.isArray(self[keys[i]])) {\n            self[keys[i]] = [];\n          }\n        }\n      }\n      return self;\n    },\n    /**\n     * Listen to a custom event and remove it once fired.\n     * @param  {String}   event Event name.\n     * @param  {Function} fn    Listener to call.\n     * @param  {Number}   id    (optional) Only listen to events for this sound.\n     * @return {Howl}\n     */\n    once: function (event, fn, id) {\n      var self = this;\n\n      // Setup the event listener.\n      self.on(event, fn, id, 1);\n      return self;\n    },\n    /**\n     * Emit all events of a specific type and pass the sound id.\n     * @param  {String} event Event name.\n     * @param  {Number} id    Sound ID.\n     * @param  {Number} msg   Message to go with event.\n     * @return {Howl}\n     */\n    _emit: function (event, id, msg) {\n      var self = this;\n      var events = self['_on' + event];\n\n      // Loop through event store and fire all functions.\n      for (var i = events.length - 1; i >= 0; i--) {\n        // Only fire the listener if the correct ID is used.\n        if (!events[i].id || events[i].id === id || event === 'load') {\n          setTimeout(function (fn) {\n            fn.call(this, id, msg);\n          }.bind(self, events[i].fn), 0);\n\n          // If this event was setup with `once`, remove it.\n          if (events[i].once) {\n            self.off(event, events[i].fn, events[i].id);\n          }\n        }\n      }\n\n      // Pass the event type into load queue so that it can continue stepping.\n      self._loadQueue(event);\n      return self;\n    },\n    /**\n     * Queue of actions initiated before the sound has loaded.\n     * These will be called in sequence, with the next only firing\n     * after the previous has finished executing (even if async like play).\n     * @return {Howl}\n     */\n    _loadQueue: function (event) {\n      var self = this;\n      if (self._queue.length > 0) {\n        var task = self._queue[0];\n\n        // Remove this task if a matching event was passed.\n        if (task.event === event) {\n          self._queue.shift();\n          self._loadQueue();\n        }\n\n        // Run the task if no event type is passed.\n        if (!event) {\n          task.action();\n        }\n      }\n      return self;\n    },\n    /**\n     * Fired when playback ends at the end of the duration.\n     * @param  {Sound} sound The sound object to work with.\n     * @return {Howl}\n     */\n    _ended: function (sound) {\n      var self = this;\n      var sprite = sound._sprite;\n\n      // If we are using IE and there was network latency we may be clipping\n      // audio before it completes playing. Lets check the node to make sure it\n      // believes it has completed, before ending the playback.\n      if (!self._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {\n        setTimeout(self._ended.bind(self, sound), 100);\n        return self;\n      }\n\n      // Should this sound loop?\n      var loop = !!(sound._loop || self._sprite[sprite][2]);\n\n      // Fire the ended event.\n      self._emit('end', sound._id);\n\n      // Restart the playback for HTML5 Audio loop.\n      if (!self._webAudio && loop) {\n        self.stop(sound._id, true).play(sound._id);\n      }\n\n      // Restart this timer if on a Web Audio loop.\n      if (self._webAudio && loop) {\n        self._emit('play', sound._id);\n        sound._seek = sound._start || 0;\n        sound._rateSeek = 0;\n        sound._playStart = Howler.ctx.currentTime;\n        var timeout = (sound._stop - sound._start) * 1000 / Math.abs(sound._rate);\n        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);\n      }\n\n      // Mark the node as paused.\n      if (self._webAudio && !loop) {\n        sound._paused = true;\n        sound._ended = true;\n        sound._seek = sound._start || 0;\n        sound._rateSeek = 0;\n        self._clearTimer(sound._id);\n\n        // Clean up the buffer source.\n        self._cleanBuffer(sound._node);\n\n        // Attempt to auto-suspend AudioContext if no sounds are still playing.\n        Howler._autoSuspend();\n      }\n\n      // When using a sprite, end the track.\n      if (!self._webAudio && !loop) {\n        self.stop(sound._id, true);\n      }\n      return self;\n    },\n    /**\n     * Clear the end timer for a sound playback.\n     * @param  {Number} id The sound ID.\n     * @return {Howl}\n     */\n    _clearTimer: function (id) {\n      var self = this;\n      if (self._endTimers[id]) {\n        // Clear the timeout or remove the ended listener.\n        if (typeof self._endTimers[id] !== 'function') {\n          clearTimeout(self._endTimers[id]);\n        } else {\n          var sound = self._soundById(id);\n          if (sound && sound._node) {\n            sound._node.removeEventListener('ended', self._endTimers[id], false);\n          }\n        }\n        delete self._endTimers[id];\n      }\n      return self;\n    },\n    /**\n     * Return the sound identified by this ID, or return null.\n     * @param  {Number} id Sound ID\n     * @return {Object}    Sound object or null.\n     */\n    _soundById: function (id) {\n      var self = this;\n\n      // Loop through all sounds and find the one with this ID.\n      for (var i = 0; i < self._sounds.length; i++) {\n        if (id === self._sounds[i]._id) {\n          return self._sounds[i];\n        }\n      }\n      return null;\n    },\n    /**\n     * Return an inactive sound from the pool or create a new one.\n     * @return {Sound} Sound playback object.\n     */\n    _inactiveSound: function () {\n      var self = this;\n      self._drain();\n\n      // Find the first inactive node to recycle.\n      for (var i = 0; i < self._sounds.length; i++) {\n        if (self._sounds[i]._ended) {\n          return self._sounds[i].reset();\n        }\n      }\n\n      // If no inactive node was found, create a new one.\n      return new Sound(self);\n    },\n    /**\n     * Drain excess inactive sounds from the pool.\n     */\n    _drain: function () {\n      var self = this;\n      var limit = self._pool;\n      var cnt = 0;\n      var i = 0;\n\n      // If there are less sounds than the max pool size, we are done.\n      if (self._sounds.length < limit) {\n        return;\n      }\n\n      // Count the number of inactive sounds.\n      for (i = 0; i < self._sounds.length; i++) {\n        if (self._sounds[i]._ended) {\n          cnt++;\n        }\n      }\n\n      // Remove excess inactive sounds, going in reverse order.\n      for (i = self._sounds.length - 1; i >= 0; i--) {\n        if (cnt <= limit) {\n          return;\n        }\n        if (self._sounds[i]._ended) {\n          // Disconnect the audio source when using Web Audio.\n          if (self._webAudio && self._sounds[i]._node) {\n            self._sounds[i]._node.disconnect(0);\n          }\n\n          // Remove sounds until we have the pool size.\n          self._sounds.splice(i, 1);\n          cnt--;\n        }\n      }\n    },\n    /**\n     * Get all ID's from the sounds pool.\n     * @param  {Number} id Only return one ID if one is passed.\n     * @return {Array}    Array of IDs.\n     */\n    _getSoundIds: function (id) {\n      var self = this;\n      if (typeof id === 'undefined') {\n        var ids = [];\n        for (var i = 0; i < self._sounds.length; i++) {\n          ids.push(self._sounds[i]._id);\n        }\n        return ids;\n      } else {\n        return [id];\n      }\n    },\n    /**\n     * Load the sound back into the buffer source.\n     * @param  {Sound} sound The sound object to work with.\n     * @return {Howl}\n     */\n    _refreshBuffer: function (sound) {\n      var self = this;\n\n      // Setup the buffer source for playback.\n      sound._node.bufferSource = Howler.ctx.createBufferSource();\n      sound._node.bufferSource.buffer = cache[self._src];\n\n      // Connect to the correct node.\n      if (sound._panner) {\n        sound._node.bufferSource.connect(sound._panner);\n      } else {\n        sound._node.bufferSource.connect(sound._node);\n      }\n\n      // Setup looping and playback rate.\n      sound._node.bufferSource.loop = sound._loop;\n      if (sound._loop) {\n        sound._node.bufferSource.loopStart = sound._start || 0;\n        sound._node.bufferSource.loopEnd = sound._stop || 0;\n      }\n      sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler.ctx.currentTime);\n      return self;\n    },\n    /**\n     * Prevent memory leaks by cleaning up the buffer source after playback.\n     * @param  {Object} node Sound's audio node containing the buffer source.\n     * @return {Howl}\n     */\n    _cleanBuffer: function (node) {\n      var self = this;\n      var isIOS = Howler._navigator && Howler._navigator.vendor.indexOf('Apple') >= 0;\n      if (!node.bufferSource) {\n        return self;\n      }\n      if (Howler._scratchBuffer && node.bufferSource) {\n        node.bufferSource.onended = null;\n        node.bufferSource.disconnect(0);\n        if (isIOS) {\n          try {\n            node.bufferSource.buffer = Howler._scratchBuffer;\n          } catch (e) {}\n        }\n      }\n      node.bufferSource = null;\n      return self;\n    },\n    /**\n     * Set the source to a 0-second silence to stop any downloading (except in IE).\n     * @param  {Object} node Audio node to clear.\n     */\n    _clearSound: function (node) {\n      var checkIE = /MSIE |Trident\\//.test(Howler._navigator && Howler._navigator.userAgent);\n      if (!checkIE) {\n        node.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';\n      }\n    }\n  };\n\n  /** Single Sound Methods **/\n  /***************************************************************************/\n\n  /**\n   * Setup the sound object, which each node attached to a Howl group is contained in.\n   * @param {Object} howl The Howl parent group.\n   */\n  var Sound = function (howl) {\n    this._parent = howl;\n    this.init();\n  };\n  Sound.prototype = {\n    /**\n     * Initialize a new Sound object.\n     * @return {Sound}\n     */\n    init: function () {\n      var self = this;\n      var parent = self._parent;\n\n      // Setup the default parameters.\n      self._muted = parent._muted;\n      self._loop = parent._loop;\n      self._volume = parent._volume;\n      self._rate = parent._rate;\n      self._seek = 0;\n      self._paused = true;\n      self._ended = true;\n      self._sprite = '__default';\n\n      // Generate a unique ID for this sound.\n      self._id = ++Howler._counter;\n\n      // Add itself to the parent's pool.\n      parent._sounds.push(self);\n\n      // Create the new node.\n      self.create();\n      return self;\n    },\n    /**\n     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.\n     * @return {Sound}\n     */\n    create: function () {\n      var self = this;\n      var parent = self._parent;\n      var volume = Howler._muted || self._muted || self._parent._muted ? 0 : self._volume;\n      if (parent._webAudio) {\n        // Create the gain node for controlling volume (the source will connect to this).\n        self._node = typeof Howler.ctx.createGain === 'undefined' ? Howler.ctx.createGainNode() : Howler.ctx.createGain();\n        self._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);\n        self._node.paused = true;\n        self._node.connect(Howler.masterGain);\n      } else if (!Howler.noAudio) {\n        // Get an unlocked Audio object from the pool.\n        self._node = Howler._obtainHtml5Audio();\n\n        // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).\n        self._errorFn = self._errorListener.bind(self);\n        self._node.addEventListener('error', self._errorFn, false);\n\n        // Listen for 'canplaythrough' event to let us know the sound is ready.\n        self._loadFn = self._loadListener.bind(self);\n        self._node.addEventListener(Howler._canPlayEvent, self._loadFn, false);\n\n        // Listen for the 'ended' event on the sound to account for edge-case where\n        // a finite sound has a duration of Infinity.\n        self._endFn = self._endListener.bind(self);\n        self._node.addEventListener('ended', self._endFn, false);\n\n        // Setup the new audio node.\n        self._node.src = parent._src;\n        self._node.preload = parent._preload === true ? 'auto' : parent._preload;\n        self._node.volume = volume * Howler.volume();\n\n        // Begin loading the source.\n        self._node.load();\n      }\n      return self;\n    },\n    /**\n     * Reset the parameters of this sound to the original state (for recycle).\n     * @return {Sound}\n     */\n    reset: function () {\n      var self = this;\n      var parent = self._parent;\n\n      // Reset all of the parameters of this sound.\n      self._muted = parent._muted;\n      self._loop = parent._loop;\n      self._volume = parent._volume;\n      self._rate = parent._rate;\n      self._seek = 0;\n      self._rateSeek = 0;\n      self._paused = true;\n      self._ended = true;\n      self._sprite = '__default';\n\n      // Generate a new ID so that it isn't confused with the previous sound.\n      self._id = ++Howler._counter;\n      return self;\n    },\n    /**\n     * HTML5 Audio error listener callback.\n     */\n    _errorListener: function () {\n      var self = this;\n\n      // Fire an error event and pass back the code.\n      self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0);\n\n      // Clear the event listener.\n      self._node.removeEventListener('error', self._errorFn, false);\n    },\n    /**\n     * HTML5 Audio canplaythrough listener callback.\n     */\n    _loadListener: function () {\n      var self = this;\n      var parent = self._parent;\n\n      // Round up the duration to account for the lower precision in HTML5 Audio.\n      parent._duration = Math.ceil(self._node.duration * 10) / 10;\n\n      // Setup a sprite if none is defined.\n      if (Object.keys(parent._sprite).length === 0) {\n        parent._sprite = {\n          __default: [0, parent._duration * 1000]\n        };\n      }\n      if (parent._state !== 'loaded') {\n        parent._state = 'loaded';\n        parent._emit('load');\n        parent._loadQueue();\n      }\n\n      // Clear the event listener.\n      self._node.removeEventListener(Howler._canPlayEvent, self._loadFn, false);\n    },\n    /**\n     * HTML5 Audio ended listener callback.\n     */\n    _endListener: function () {\n      var self = this;\n      var parent = self._parent;\n\n      // Only handle the `ended`` event if the duration is Infinity.\n      if (parent._duration === Infinity) {\n        // Update the parent duration to match the real audio duration.\n        // Round up the duration to account for the lower precision in HTML5 Audio.\n        parent._duration = Math.ceil(self._node.duration * 10) / 10;\n\n        // Update the sprite that corresponds to the real duration.\n        if (parent._sprite.__default[1] === Infinity) {\n          parent._sprite.__default[1] = parent._duration * 1000;\n        }\n\n        // Run the regular ended method.\n        parent._ended(self);\n      }\n\n      // Clear the event listener since the duration is now correct.\n      self._node.removeEventListener('ended', self._endFn, false);\n    }\n  };\n\n  /** Helper Methods **/\n  /***************************************************************************/\n\n  var cache = {};\n\n  /**\n   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).\n   * @param  {Howl} self\n   */\n  var loadBuffer = function (self) {\n    var url = self._src;\n\n    // Check if the buffer has already been cached and use it instead.\n    if (cache[url]) {\n      // Set the duration from the cache.\n      self._duration = cache[url].duration;\n\n      // Load the sound into this Howl.\n      loadSound(self);\n      return;\n    }\n    if (/^data:[^;]+;base64,/.test(url)) {\n      // Decode the base64 data URI without XHR, since some browsers don't support it.\n      var data = atob(url.split(',')[1]);\n      var dataView = new Uint8Array(data.length);\n      for (var i = 0; i < data.length; ++i) {\n        dataView[i] = data.charCodeAt(i);\n      }\n      decodeAudioData(dataView.buffer, self);\n    } else {\n      // Load the buffer from the URL.\n      var xhr = new XMLHttpRequest();\n      xhr.open(self._xhr.method, url, true);\n      xhr.withCredentials = self._xhr.withCredentials;\n      xhr.responseType = 'arraybuffer';\n\n      // Apply any custom headers to the request.\n      if (self._xhr.headers) {\n        Object.keys(self._xhr.headers).forEach(function (key) {\n          xhr.setRequestHeader(key, self._xhr.headers[key]);\n        });\n      }\n      xhr.onload = function () {\n        // Make sure we get a successful response back.\n        var code = (xhr.status + '')[0];\n        if (code !== '0' && code !== '2' && code !== '3') {\n          self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');\n          return;\n        }\n        decodeAudioData(xhr.response, self);\n      };\n      xhr.onerror = function () {\n        // If there is an error, switch to HTML5 Audio.\n        if (self._webAudio) {\n          self._html5 = true;\n          self._webAudio = false;\n          self._sounds = [];\n          delete cache[url];\n          self.load();\n        }\n      };\n      safeXhrSend(xhr);\n    }\n  };\n\n  /**\n   * Send the XHR request wrapped in a try/catch.\n   * @param  {Object} xhr XHR to send.\n   */\n  var safeXhrSend = function (xhr) {\n    try {\n      xhr.send();\n    } catch (e) {\n      xhr.onerror();\n    }\n  };\n\n  /**\n   * Decode audio data from an array buffer.\n   * @param  {ArrayBuffer} arraybuffer The audio data.\n   * @param  {Howl}        self\n   */\n  var decodeAudioData = function (arraybuffer, self) {\n    // Fire a load error if something broke.\n    var error = function () {\n      self._emit('loaderror', null, 'Decoding audio data failed.');\n    };\n\n    // Load the sound on success.\n    var success = function (buffer) {\n      if (buffer && self._sounds.length > 0) {\n        cache[self._src] = buffer;\n        loadSound(self, buffer);\n      } else {\n        error();\n      }\n    };\n\n    // Decode the buffer into an audio source.\n    if (typeof Promise !== 'undefined' && Howler.ctx.decodeAudioData.length === 1) {\n      Howler.ctx.decodeAudioData(arraybuffer).then(success).catch(error);\n    } else {\n      Howler.ctx.decodeAudioData(arraybuffer, success, error);\n    }\n  };\n\n  /**\n   * Sound is now loaded, so finish setting everything up and fire the loaded event.\n   * @param  {Howl} self\n   * @param  {Object} buffer The decoded buffer sound source.\n   */\n  var loadSound = function (self, buffer) {\n    // Set the duration.\n    if (buffer && !self._duration) {\n      self._duration = buffer.duration;\n    }\n\n    // Setup a sprite if none is defined.\n    if (Object.keys(self._sprite).length === 0) {\n      self._sprite = {\n        __default: [0, self._duration * 1000]\n      };\n    }\n\n    // Fire the loaded event.\n    if (self._state !== 'loaded') {\n      self._state = 'loaded';\n      self._emit('load');\n      self._loadQueue();\n    }\n  };\n\n  /**\n   * Setup the audio context when available, or switch to HTML5 Audio mode.\n   */\n  var setupAudioContext = function () {\n    // If we have already detected that Web Audio isn't supported, don't run this step again.\n    if (!Howler.usingWebAudio) {\n      return;\n    }\n\n    // Check if we are using Web Audio and setup the AudioContext if we are.\n    try {\n      if (typeof AudioContext !== 'undefined') {\n        Howler.ctx = new AudioContext();\n      } else if (typeof webkitAudioContext !== 'undefined') {\n        Howler.ctx = new webkitAudioContext();\n      } else {\n        Howler.usingWebAudio = false;\n      }\n    } catch (e) {\n      Howler.usingWebAudio = false;\n    }\n\n    // If the audio context creation still failed, set using web audio to false.\n    if (!Howler.ctx) {\n      Howler.usingWebAudio = false;\n    }\n\n    // Check if a webview is being used on iOS8 or earlier (rather than the browser).\n    // If it is, disable Web Audio as it causes crashing.\n    var iOS = /iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform);\n    var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n    var version = appVersion ? parseInt(appVersion[1], 10) : null;\n    if (iOS && version && version < 9) {\n      var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());\n      if (Howler._navigator && !safari) {\n        Howler.usingWebAudio = false;\n      }\n    }\n\n    // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).\n    if (Howler.usingWebAudio) {\n      Howler.masterGain = typeof Howler.ctx.createGain === 'undefined' ? Howler.ctx.createGainNode() : Howler.ctx.createGain();\n      Howler.masterGain.gain.setValueAtTime(Howler._muted ? 0 : Howler._volume, Howler.ctx.currentTime);\n      Howler.masterGain.connect(Howler.ctx.destination);\n    }\n\n    // Re-run the setup on Howler.\n    Howler._setup();\n  };\n\n  // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return {\n        Howler: Howler,\n        Howl: Howl\n      };\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n\n  // Add support for CommonJS libraries such as browserify.\n  if (true) {\n    exports.Howler = Howler;\n    exports.Howl = Howl;\n  }\n\n  // Add to global in Node.js (for testing, etc).\n  if (typeof __webpack_require__.g !== 'undefined') {\n    __webpack_require__.g.HowlerGlobal = HowlerGlobal;\n    __webpack_require__.g.Howler = Howler;\n    __webpack_require__.g.Howl = Howl;\n    __webpack_require__.g.Sound = Sound;\n  } else if (typeof window !== 'undefined') {\n    // Define globally in case AMD is not available or unused.\n    window.HowlerGlobal = HowlerGlobal;\n    window.Howler = Howler;\n    window.Howl = Howl;\n    window.Sound = Sound;\n  }\n})();\n\n/*!\n *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.\n *  \n *  howler.js v2.2.4\n *  howlerjs.com\n *\n *  (c) 2013-2020, James Simpson of GoldFire Studios\n *  goldfirestudios.com\n *\n *  MIT License\n */\n\n(function () {\n  'use strict';\n\n  // Setup default properties.\n  HowlerGlobal.prototype._pos = [0, 0, 0];\n  HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];\n\n  /** Global Methods **/\n  /***************************************************************************/\n\n  /**\n   * Helper method to update the stereo panning position of all current Howls.\n   * Future Howls will not use this value unless explicitly set.\n   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.\n   * @return {Howler/Number}     Self or current stereo panning value.\n   */\n  HowlerGlobal.prototype.stereo = function (pan) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self.ctx || !self.ctx.listener) {\n      return self;\n    }\n\n    // Loop through all Howls and update their stereo panning.\n    for (var i = self._howls.length - 1; i >= 0; i--) {\n      self._howls[i].stereo(pan);\n    }\n    return self;\n  };\n\n  /**\n   * Get/set the position of the listener in 3D cartesian space. Sounds using\n   * 3D position will be relative to the listener's position.\n   * @param  {Number} x The x-position of the listener.\n   * @param  {Number} y The y-position of the listener.\n   * @param  {Number} z The z-position of the listener.\n   * @return {Howler/Array}   Self or current listener position.\n   */\n  HowlerGlobal.prototype.pos = function (x, y, z) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self.ctx || !self.ctx.listener) {\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    y = typeof y !== 'number' ? self._pos[1] : y;\n    z = typeof z !== 'number' ? self._pos[2] : z;\n    if (typeof x === 'number') {\n      self._pos = [x, y, z];\n      if (typeof self.ctx.listener.positionX !== 'undefined') {\n        self.ctx.listener.positionX.setTargetAtTime(self._pos[0], Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.positionY.setTargetAtTime(self._pos[1], Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.positionZ.setTargetAtTime(self._pos[2], Howler.ctx.currentTime, 0.1);\n      } else {\n        self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);\n      }\n    } else {\n      return self._pos;\n    }\n    return self;\n  };\n\n  /**\n   * Get/set the direction the listener is pointing in the 3D cartesian space.\n   * A front and up vector must be provided. The front is the direction the\n   * face of the listener is pointing, and up is the direction the top of the\n   * listener is pointing. Thus, these values are expected to be at right angles\n   * from each other.\n   * @param  {Number} x   The x-orientation of the listener.\n   * @param  {Number} y   The y-orientation of the listener.\n   * @param  {Number} z   The z-orientation of the listener.\n   * @param  {Number} xUp The x-orientation of the top of the listener.\n   * @param  {Number} yUp The y-orientation of the top of the listener.\n   * @param  {Number} zUp The z-orientation of the top of the listener.\n   * @return {Howler/Array}     Returns self or the current orientation vectors.\n   */\n  HowlerGlobal.prototype.orientation = function (x, y, z, xUp, yUp, zUp) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self.ctx || !self.ctx.listener) {\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    var or = self._orientation;\n    y = typeof y !== 'number' ? or[1] : y;\n    z = typeof z !== 'number' ? or[2] : z;\n    xUp = typeof xUp !== 'number' ? or[3] : xUp;\n    yUp = typeof yUp !== 'number' ? or[4] : yUp;\n    zUp = typeof zUp !== 'number' ? or[5] : zUp;\n    if (typeof x === 'number') {\n      self._orientation = [x, y, z, xUp, yUp, zUp];\n      if (typeof self.ctx.listener.forwardX !== 'undefined') {\n        self.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);\n        self.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);\n      } else {\n        self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);\n      }\n    } else {\n      return or;\n    }\n    return self;\n  };\n\n  /** Group Methods **/\n  /***************************************************************************/\n\n  /**\n   * Add new properties to the core init.\n   * @param  {Function} _super Core init method.\n   * @return {Howl}\n   */\n  Howl.prototype.init = function (_super) {\n    return function (o) {\n      var self = this;\n\n      // Setup user-defined default properties.\n      self._orientation = o.orientation || [1, 0, 0];\n      self._stereo = o.stereo || null;\n      self._pos = o.pos || null;\n      self._pannerAttr = {\n        coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : 360,\n        coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : 360,\n        coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : 0,\n        distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : 'inverse',\n        maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : 10000,\n        panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : 'HRTF',\n        refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : 1,\n        rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : 1\n      };\n\n      // Setup event listeners.\n      self._onstereo = o.onstereo ? [{\n        fn: o.onstereo\n      }] : [];\n      self._onpos = o.onpos ? [{\n        fn: o.onpos\n      }] : [];\n      self._onorientation = o.onorientation ? [{\n        fn: o.onorientation\n      }] : [];\n\n      // Complete initilization with howler.js core's init function.\n      return _super.call(this, o);\n    };\n  }(Howl.prototype.init);\n\n  /**\n   * Get/set the stereo panning of the audio source for this sound or all in the group.\n   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Number}    Returns self or the current stereo panning value.\n   */\n  Howl.prototype.stereo = function (pan, id) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.\n    if (self._state !== 'loaded') {\n      self._queue.push({\n        event: 'stereo',\n        action: function () {\n          self.stereo(pan, id);\n        }\n      });\n      return self;\n    }\n\n    // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.\n    var pannerType = typeof Howler.ctx.createStereoPanner === 'undefined' ? 'spatial' : 'stereo';\n\n    // Setup the group's stereo panning if no ID is passed.\n    if (typeof id === 'undefined') {\n      // Return the group's stereo panning if no parameters are passed.\n      if (typeof pan === 'number') {\n        self._stereo = pan;\n        self._pos = [pan, 0, 0];\n      } else {\n        return self._stereo;\n      }\n    }\n\n    // Change the streo panning of one or all sounds in group.\n    var ids = self._getSoundIds(id);\n    for (var i = 0; i < ids.length; i++) {\n      // Get the sound.\n      var sound = self._soundById(ids[i]);\n      if (sound) {\n        if (typeof pan === 'number') {\n          sound._stereo = pan;\n          sound._pos = [pan, 0, 0];\n          if (sound._node) {\n            // If we are falling back, make sure the panningModel is equalpower.\n            sound._pannerAttr.panningModel = 'equalpower';\n\n            // Check if there is a panner setup and create a new one if not.\n            if (!sound._panner || !sound._panner.pan) {\n              setupPanner(sound, pannerType);\n            }\n            if (pannerType === 'spatial') {\n              if (typeof sound._panner.positionX !== 'undefined') {\n                sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);\n                sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);\n                sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);\n              } else {\n                sound._panner.setPosition(pan, 0, 0);\n              }\n            } else {\n              sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);\n            }\n          }\n          self._emit('stereo', sound._id);\n        } else {\n          return sound._stereo;\n        }\n      }\n    }\n    return self;\n  };\n\n  /**\n   * Get/set the 3D spatial position of the audio source for this sound or group relative to the global listener.\n   * @param  {Number} x  The x-position of the audio source.\n   * @param  {Number} y  The y-position of the audio source.\n   * @param  {Number} z  The z-position of the audio source.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].\n   */\n  Howl.prototype.pos = function (x, y, z, id) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // If the sound hasn't loaded, add it to the load queue to change position when capable.\n    if (self._state !== 'loaded') {\n      self._queue.push({\n        event: 'pos',\n        action: function () {\n          self.pos(x, y, z, id);\n        }\n      });\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    y = typeof y !== 'number' ? 0 : y;\n    z = typeof z !== 'number' ? -0.5 : z;\n\n    // Setup the group's spatial position if no ID is passed.\n    if (typeof id === 'undefined') {\n      // Return the group's spatial position if no parameters are passed.\n      if (typeof x === 'number') {\n        self._pos = [x, y, z];\n      } else {\n        return self._pos;\n      }\n    }\n\n    // Change the spatial position of one or all sounds in group.\n    var ids = self._getSoundIds(id);\n    for (var i = 0; i < ids.length; i++) {\n      // Get the sound.\n      var sound = self._soundById(ids[i]);\n      if (sound) {\n        if (typeof x === 'number') {\n          sound._pos = [x, y, z];\n          if (sound._node) {\n            // Check if there is a panner setup and create a new one if not.\n            if (!sound._panner || sound._panner.pan) {\n              setupPanner(sound, 'spatial');\n            }\n            if (typeof sound._panner.positionX !== 'undefined') {\n              sound._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);\n              sound._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);\n              sound._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);\n            } else {\n              sound._panner.setPosition(x, y, z);\n            }\n          }\n          self._emit('pos', sound._id);\n        } else {\n          return sound._pos;\n        }\n      }\n    }\n    return self;\n  };\n\n  /**\n   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate\n   * space. Depending on how direction the sound is, based on the `cone` attributes,\n   * a sound pointing away from the listener can be quiet or silent.\n   * @param  {Number} x  The x-orientation of the source.\n   * @param  {Number} y  The y-orientation of the source.\n   * @param  {Number} z  The z-orientation of the source.\n   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.\n   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].\n   */\n  Howl.prototype.orientation = function (x, y, z, id) {\n    var self = this;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // If the sound hasn't loaded, add it to the load queue to change orientation when capable.\n    if (self._state !== 'loaded') {\n      self._queue.push({\n        event: 'orientation',\n        action: function () {\n          self.orientation(x, y, z, id);\n        }\n      });\n      return self;\n    }\n\n    // Set the defaults for optional 'y' & 'z'.\n    y = typeof y !== 'number' ? self._orientation[1] : y;\n    z = typeof z !== 'number' ? self._orientation[2] : z;\n\n    // Setup the group's spatial orientation if no ID is passed.\n    if (typeof id === 'undefined') {\n      // Return the group's spatial orientation if no parameters are passed.\n      if (typeof x === 'number') {\n        self._orientation = [x, y, z];\n      } else {\n        return self._orientation;\n      }\n    }\n\n    // Change the spatial orientation of one or all sounds in group.\n    var ids = self._getSoundIds(id);\n    for (var i = 0; i < ids.length; i++) {\n      // Get the sound.\n      var sound = self._soundById(ids[i]);\n      if (sound) {\n        if (typeof x === 'number') {\n          sound._orientation = [x, y, z];\n          if (sound._node) {\n            // Check if there is a panner setup and create a new one if not.\n            if (!sound._panner) {\n              // Make sure we have a position to setup the node with.\n              if (!sound._pos) {\n                sound._pos = self._pos || [0, 0, -0.5];\n              }\n              setupPanner(sound, 'spatial');\n            }\n            if (typeof sound._panner.orientationX !== 'undefined') {\n              sound._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);\n              sound._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);\n              sound._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);\n            } else {\n              sound._panner.setOrientation(x, y, z);\n            }\n          }\n          self._emit('orientation', sound._id);\n        } else {\n          return sound._orientation;\n        }\n      }\n    }\n    return self;\n  };\n\n  /**\n   * Get/set the panner node's attributes for a sound or group of sounds.\n   * This method can optionall take 0, 1 or 2 arguments.\n   *   pannerAttr() -> Returns the group's values.\n   *   pannerAttr(id) -> Returns the sound id's values.\n   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.\n   *   pannerAttr(o, id) -> Set's the values of passed sound id.\n   *\n   *   Attributes:\n   *     coneInnerAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,\n   *                      inside of which there will be no volume reduction.\n   *     coneOuterAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,\n   *                      outside of which the volume will be reduced to a constant value of `coneOuterGain`.\n   *     coneOuterGain - (0 by default) A parameter for directional audio sources, this is the gain outside of the\n   *                     `coneOuterAngle`. It is a linear value in the range `[0, 1]`.\n   *     distanceModel - ('inverse' by default) Determines algorithm used to reduce volume as audio moves away from\n   *                     listener. Can be `linear`, `inverse` or `exponential.\n   *     maxDistance - (10000 by default) The maximum distance between source and listener, after which the volume\n   *                   will not be reduced any further.\n   *     refDistance - (1 by default) A reference distance for reducing volume as source moves further from the listener.\n   *                   This is simply a variable of the distance model and has a different effect depending on which model\n   *                   is used and the scale of your coordinates. Generally, volume will be equal to 1 at this distance.\n   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener. This is simply a\n   *                     variable of the distance model and can be in the range of `[0, 1]` with `linear` and `[0, ∞]`\n   *                     with `inverse` and `exponential`.\n   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.\n   *                     Can be `HRTF` or `equalpower`.\n   *\n   * @return {Howl/Object} Returns self or current panner attributes.\n   */\n  Howl.prototype.pannerAttr = function () {\n    var self = this;\n    var args = arguments;\n    var o, id, sound;\n\n    // Stop right here if not using Web Audio.\n    if (!self._webAudio) {\n      return self;\n    }\n\n    // Determine the values based on arguments.\n    if (args.length === 0) {\n      // Return the group's panner attribute values.\n      return self._pannerAttr;\n    } else if (args.length === 1) {\n      if (typeof args[0] === 'object') {\n        o = args[0];\n\n        // Set the grou's panner attribute values.\n        if (typeof id === 'undefined') {\n          if (!o.pannerAttr) {\n            o.pannerAttr = {\n              coneInnerAngle: o.coneInnerAngle,\n              coneOuterAngle: o.coneOuterAngle,\n              coneOuterGain: o.coneOuterGain,\n              distanceModel: o.distanceModel,\n              maxDistance: o.maxDistance,\n              refDistance: o.refDistance,\n              rolloffFactor: o.rolloffFactor,\n              panningModel: o.panningModel\n            };\n          }\n          self._pannerAttr = {\n            coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== 'undefined' ? o.pannerAttr.coneInnerAngle : self._coneInnerAngle,\n            coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== 'undefined' ? o.pannerAttr.coneOuterAngle : self._coneOuterAngle,\n            coneOuterGain: typeof o.pannerAttr.coneOuterGain !== 'undefined' ? o.pannerAttr.coneOuterGain : self._coneOuterGain,\n            distanceModel: typeof o.pannerAttr.distanceModel !== 'undefined' ? o.pannerAttr.distanceModel : self._distanceModel,\n            maxDistance: typeof o.pannerAttr.maxDistance !== 'undefined' ? o.pannerAttr.maxDistance : self._maxDistance,\n            refDistance: typeof o.pannerAttr.refDistance !== 'undefined' ? o.pannerAttr.refDistance : self._refDistance,\n            rolloffFactor: typeof o.pannerAttr.rolloffFactor !== 'undefined' ? o.pannerAttr.rolloffFactor : self._rolloffFactor,\n            panningModel: typeof o.pannerAttr.panningModel !== 'undefined' ? o.pannerAttr.panningModel : self._panningModel\n          };\n        }\n      } else {\n        // Return this sound's panner attribute values.\n        sound = self._soundById(parseInt(args[0], 10));\n        return sound ? sound._pannerAttr : self._pannerAttr;\n      }\n    } else if (args.length === 2) {\n      o = args[0];\n      id = parseInt(args[1], 10);\n    }\n\n    // Update the values of the specified sounds.\n    var ids = self._getSoundIds(id);\n    for (var i = 0; i < ids.length; i++) {\n      sound = self._soundById(ids[i]);\n      if (sound) {\n        // Merge the new values into the sound.\n        var pa = sound._pannerAttr;\n        pa = {\n          coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : pa.coneInnerAngle,\n          coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : pa.coneOuterAngle,\n          coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : pa.coneOuterGain,\n          distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : pa.distanceModel,\n          maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : pa.maxDistance,\n          refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : pa.refDistance,\n          rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : pa.rolloffFactor,\n          panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : pa.panningModel\n        };\n\n        // Create a new panner node if one doesn't already exist.\n        var panner = sound._panner;\n        if (!panner) {\n          // Make sure we have a position to setup the node with.\n          if (!sound._pos) {\n            sound._pos = self._pos || [0, 0, -0.5];\n          }\n\n          // Create a new panner node.\n          setupPanner(sound, 'spatial');\n          panner = sound._panner;\n        }\n\n        // Update the panner values or create a new panner if none exists.\n        panner.coneInnerAngle = pa.coneInnerAngle;\n        panner.coneOuterAngle = pa.coneOuterAngle;\n        panner.coneOuterGain = pa.coneOuterGain;\n        panner.distanceModel = pa.distanceModel;\n        panner.maxDistance = pa.maxDistance;\n        panner.refDistance = pa.refDistance;\n        panner.rolloffFactor = pa.rolloffFactor;\n        panner.panningModel = pa.panningModel;\n      }\n    }\n    return self;\n  };\n\n  /** Single Sound Methods **/\n  /***************************************************************************/\n\n  /**\n   * Add new properties to the core Sound init.\n   * @param  {Function} _super Core Sound init method.\n   * @return {Sound}\n   */\n  Sound.prototype.init = function (_super) {\n    return function () {\n      var self = this;\n      var parent = self._parent;\n\n      // Setup user-defined default properties.\n      self._orientation = parent._orientation;\n      self._stereo = parent._stereo;\n      self._pos = parent._pos;\n      self._pannerAttr = parent._pannerAttr;\n\n      // Complete initilization with howler.js core Sound's init function.\n      _super.call(this);\n\n      // If a stereo or position was specified, set it up.\n      if (self._stereo) {\n        parent.stereo(self._stereo);\n      } else if (self._pos) {\n        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);\n      }\n    };\n  }(Sound.prototype.init);\n\n  /**\n   * Override the Sound.reset method to clean up properties from the spatial plugin.\n   * @param  {Function} _super Sound reset method.\n   * @return {Sound}\n   */\n  Sound.prototype.reset = function (_super) {\n    return function () {\n      var self = this;\n      var parent = self._parent;\n\n      // Reset all spatial plugin properties on this sound.\n      self._orientation = parent._orientation;\n      self._stereo = parent._stereo;\n      self._pos = parent._pos;\n      self._pannerAttr = parent._pannerAttr;\n\n      // If a stereo or position was specified, set it up.\n      if (self._stereo) {\n        parent.stereo(self._stereo);\n      } else if (self._pos) {\n        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);\n      } else if (self._panner) {\n        // Disconnect the panner.\n        self._panner.disconnect(0);\n        self._panner = undefined;\n        parent._refreshBuffer(self);\n      }\n\n      // Complete resetting of the sound.\n      return _super.call(this);\n    };\n  }(Sound.prototype.reset);\n\n  /** Helper Methods **/\n  /***************************************************************************/\n\n  /**\n   * Create a new panner node and save it on the sound.\n   * @param  {Sound} sound Specific sound to setup panning on.\n   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.\n   */\n  var setupPanner = function (sound, type) {\n    type = type || 'spatial';\n\n    // Create the new panner node.\n    if (type === 'spatial') {\n      sound._panner = Howler.ctx.createPanner();\n      sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;\n      sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;\n      sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;\n      sound._panner.distanceModel = sound._pannerAttr.distanceModel;\n      sound._panner.maxDistance = sound._pannerAttr.maxDistance;\n      sound._panner.refDistance = sound._pannerAttr.refDistance;\n      sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;\n      sound._panner.panningModel = sound._pannerAttr.panningModel;\n      if (typeof sound._panner.positionX !== 'undefined') {\n        sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);\n        sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);\n        sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);\n      } else {\n        sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);\n      }\n      if (typeof sound._panner.orientationX !== 'undefined') {\n        sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);\n        sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);\n        sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);\n      } else {\n        sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);\n      }\n    } else {\n      sound._panner = Howler.ctx.createStereoPanner();\n      sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);\n    }\n    sound._panner.connect(sound._node);\n\n    // Update the connections.\n    if (!sound._paused) {\n      sound._parent.pause(sound._id, true).play(sound._id, true);\n    }\n  };\n})();\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/howler/dist/howler.js?");

/***/ }),

/***/ "./node_modules/matter-js/build/matter.js":
/*!************************************************!*\
  !*** ./node_modules/matter-js/build/matter.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*!\n * matter-js 0.19.0 by @liabru\n * http://brm.io/matter-js/\n * License MIT\n * \n * The MIT License (MIT)\n * \n * Copyright (c) Liam Brummitt and contributors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (true) module.exports = factory();else {}\n})(this, function () {\n  return (/******/function (modules) {\n      // webpackBootstrap\n      /******/ // The module cache\n      /******/\n      var installedModules = {};\n      /******/\n      /******/ // The require function\n      /******/\n      function __nested_webpack_require_1824__(moduleId) {\n        /******/\n        /******/ // Check if module is in cache\n        /******/if (installedModules[moduleId]) {\n          /******/return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/ // Create a new module (and put it into the cache)\n        /******/\n        var module = installedModules[moduleId] = {\n          /******/i: moduleId,\n          /******/l: false,\n          /******/exports: {}\n          /******/\n        };\n        /******/\n        /******/ // Execute the module function\n        /******/\n        modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_1824__);\n        /******/\n        /******/ // Flag the module as loaded\n        /******/\n        module.l = true;\n        /******/\n        /******/ // Return the exports of the module\n        /******/\n        return module.exports;\n        /******/\n      }\n      /******/\n      /******/\n      /******/ // expose the modules object (__webpack_modules__)\n      /******/\n      __nested_webpack_require_1824__.m = modules;\n      /******/\n      /******/ // expose the module cache\n      /******/\n      __nested_webpack_require_1824__.c = installedModules;\n      /******/\n      /******/ // define getter function for harmony exports\n      /******/\n      __nested_webpack_require_1824__.d = function (exports, name, getter) {\n        /******/if (!__nested_webpack_require_1824__.o(exports, name)) {\n          /******/Object.defineProperty(exports, name, {\n            enumerable: true,\n            get: getter\n          });\n          /******/\n        }\n        /******/\n      };\n      /******/\n      /******/ // define __esModule on exports\n      /******/\n      __nested_webpack_require_1824__.r = function (exports) {\n        /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n          /******/Object.defineProperty(exports, Symbol.toStringTag, {\n            value: 'Module'\n          });\n          /******/\n        }\n        /******/\n        Object.defineProperty(exports, '__esModule', {\n          value: true\n        });\n        /******/\n      };\n      /******/\n      /******/ // create a fake namespace object\n      /******/ // mode & 1: value is a module id, require it\n      /******/ // mode & 2: merge all properties of value into the ns\n      /******/ // mode & 4: return value when already ns object\n      /******/ // mode & 8|1: behave like require\n      /******/\n      __nested_webpack_require_1824__.t = function (value, mode) {\n        /******/if (mode & 1) value = __nested_webpack_require_1824__(value);\n        /******/\n        if (mode & 8) return value;\n        /******/\n        if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;\n        /******/\n        var ns = Object.create(null);\n        /******/\n        __nested_webpack_require_1824__.r(ns);\n        /******/\n        Object.defineProperty(ns, 'default', {\n          enumerable: true,\n          value: value\n        });\n        /******/\n        if (mode & 2 && typeof value != 'string') for (var key in value) __nested_webpack_require_1824__.d(ns, key, function (key) {\n          return value[key];\n        }.bind(null, key));\n        /******/\n        return ns;\n        /******/\n      };\n      /******/\n      /******/ // getDefaultExport function for compatibility with non-harmony modules\n      /******/\n      __nested_webpack_require_1824__.n = function (module) {\n        /******/var getter = module && module.__esModule ? /******/function getDefault() {\n          return module['default'];\n        } : /******/function getModuleExports() {\n          return module;\n        };\n        /******/\n        __nested_webpack_require_1824__.d(getter, 'a', getter);\n        /******/\n        return getter;\n        /******/\n      };\n      /******/\n      /******/ // Object.prototype.hasOwnProperty.call\n      /******/\n      __nested_webpack_require_1824__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n      /******/ // __webpack_public_path__\n      /******/\n      __nested_webpack_require_1824__.p = \"\";\n      /******/\n      /******/\n      /******/ // Load entry module and return exports\n      /******/\n      return __nested_webpack_require_1824__(__nested_webpack_require_1824__.s = 20);\n      /******/\n    }\n    /************************************************************************/\n    /******/([/* 0 */\n    /***/function (module, exports) {\n      /**\n      * The `Matter.Common` module contains utility functions that are common to all modules.\n      *\n      * @class Common\n      */\n\n      var Common = {};\n      module.exports = Common;\n      (function () {\n        Common._baseDelta = 1000 / 60;\n        Common._nextId = 0;\n        Common._seed = 0;\n        Common._nowStartTime = +new Date();\n        Common._warnedOnce = {};\n        Common._decomp = null;\n\n        /**\n         * Extends the object in the first argument using the object in the second argument.\n         * @method extend\n         * @param {} obj\n         * @param {boolean} deep\n         * @return {} obj extended\n         */\n        Common.extend = function (obj, deep) {\n          var argsStart, args, deepClone;\n          if (typeof deep === 'boolean') {\n            argsStart = 2;\n            deepClone = deep;\n          } else {\n            argsStart = 1;\n            deepClone = true;\n          }\n          for (var i = argsStart; i < arguments.length; i++) {\n            var source = arguments[i];\n            if (source) {\n              for (var prop in source) {\n                if (deepClone && source[prop] && source[prop].constructor === Object) {\n                  if (!obj[prop] || obj[prop].constructor === Object) {\n                    obj[prop] = obj[prop] || {};\n                    Common.extend(obj[prop], deepClone, source[prop]);\n                  } else {\n                    obj[prop] = source[prop];\n                  }\n                } else {\n                  obj[prop] = source[prop];\n                }\n              }\n            }\n          }\n          return obj;\n        };\n\n        /**\n         * Creates a new clone of the object, if deep is true references will also be cloned.\n         * @method clone\n         * @param {} obj\n         * @param {bool} deep\n         * @return {} obj cloned\n         */\n        Common.clone = function (obj, deep) {\n          return Common.extend({}, deep, obj);\n        };\n\n        /**\n         * Returns the list of keys for the given object.\n         * @method keys\n         * @param {} obj\n         * @return {string[]} keys\n         */\n        Common.keys = function (obj) {\n          if (Object.keys) return Object.keys(obj);\n\n          // avoid hasOwnProperty for performance\n          var keys = [];\n          for (var key in obj) keys.push(key);\n          return keys;\n        };\n\n        /**\n         * Returns the list of values for the given object.\n         * @method values\n         * @param {} obj\n         * @return {array} Array of the objects property values\n         */\n        Common.values = function (obj) {\n          var values = [];\n          if (Object.keys) {\n            var keys = Object.keys(obj);\n            for (var i = 0; i < keys.length; i++) {\n              values.push(obj[keys[i]]);\n            }\n            return values;\n          }\n\n          // avoid hasOwnProperty for performance\n          for (var key in obj) values.push(obj[key]);\n          return values;\n        };\n\n        /**\n         * Gets a value from `base` relative to the `path` string.\n         * @method get\n         * @param {} obj The base object\n         * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'\n         * @param {number} [begin] Path slice begin\n         * @param {number} [end] Path slice end\n         * @return {} The object at the given path\n         */\n        Common.get = function (obj, path, begin, end) {\n          path = path.split('.').slice(begin, end);\n          for (var i = 0; i < path.length; i += 1) {\n            obj = obj[path[i]];\n          }\n          return obj;\n        };\n\n        /**\n         * Sets a value on `base` relative to the given `path` string.\n         * @method set\n         * @param {} obj The base object\n         * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'\n         * @param {} val The value to set\n         * @param {number} [begin] Path slice begin\n         * @param {number} [end] Path slice end\n         * @return {} Pass through `val` for chaining\n         */\n        Common.set = function (obj, path, val, begin, end) {\n          var parts = path.split('.').slice(begin, end);\n          Common.get(obj, path, 0, -1)[parts[parts.length - 1]] = val;\n          return val;\n        };\n\n        /**\n         * Shuffles the given array in-place.\n         * The function uses a seeded random generator.\n         * @method shuffle\n         * @param {array} array\n         * @return {array} array shuffled randomly\n         */\n        Common.shuffle = function (array) {\n          for (var i = array.length - 1; i > 0; i--) {\n            var j = Math.floor(Common.random() * (i + 1));\n            var temp = array[i];\n            array[i] = array[j];\n            array[j] = temp;\n          }\n          return array;\n        };\n\n        /**\n         * Randomly chooses a value from a list with equal probability.\n         * The function uses a seeded random generator.\n         * @method choose\n         * @param {array} choices\n         * @return {object} A random choice object from the array\n         */\n        Common.choose = function (choices) {\n          return choices[Math.floor(Common.random() * choices.length)];\n        };\n\n        /**\n         * Returns true if the object is a HTMLElement, otherwise false.\n         * @method isElement\n         * @param {object} obj\n         * @return {boolean} True if the object is a HTMLElement, otherwise false\n         */\n        Common.isElement = function (obj) {\n          if (typeof HTMLElement !== 'undefined') {\n            return obj instanceof HTMLElement;\n          }\n          return !!(obj && obj.nodeType && obj.nodeName);\n        };\n\n        /**\n         * Returns true if the object is an array.\n         * @method isArray\n         * @param {object} obj\n         * @return {boolean} True if the object is an array, otherwise false\n         */\n        Common.isArray = function (obj) {\n          return Object.prototype.toString.call(obj) === '[object Array]';\n        };\n\n        /**\n         * Returns true if the object is a function.\n         * @method isFunction\n         * @param {object} obj\n         * @return {boolean} True if the object is a function, otherwise false\n         */\n        Common.isFunction = function (obj) {\n          return typeof obj === \"function\";\n        };\n\n        /**\n         * Returns true if the object is a plain object.\n         * @method isPlainObject\n         * @param {object} obj\n         * @return {boolean} True if the object is a plain object, otherwise false\n         */\n        Common.isPlainObject = function (obj) {\n          return typeof obj === 'object' && obj.constructor === Object;\n        };\n\n        /**\n         * Returns true if the object is a string.\n         * @method isString\n         * @param {object} obj\n         * @return {boolean} True if the object is a string, otherwise false\n         */\n        Common.isString = function (obj) {\n          return toString.call(obj) === '[object String]';\n        };\n\n        /**\n         * Returns the given value clamped between a minimum and maximum value.\n         * @method clamp\n         * @param {number} value\n         * @param {number} min\n         * @param {number} max\n         * @return {number} The value clamped between min and max inclusive\n         */\n        Common.clamp = function (value, min, max) {\n          if (value < min) return min;\n          if (value > max) return max;\n          return value;\n        };\n\n        /**\n         * Returns the sign of the given value.\n         * @method sign\n         * @param {number} value\n         * @return {number} -1 if negative, +1 if 0 or positive\n         */\n        Common.sign = function (value) {\n          return value < 0 ? -1 : 1;\n        };\n\n        /**\n         * Returns the current timestamp since the time origin (e.g. from page load).\n         * The result is in milliseconds and will use high-resolution timing if available.\n         * @method now\n         * @return {number} the current timestamp in milliseconds\n         */\n        Common.now = function () {\n          if (typeof window !== 'undefined' && window.performance) {\n            if (window.performance.now) {\n              return window.performance.now();\n            } else if (window.performance.webkitNow) {\n              return window.performance.webkitNow();\n            }\n          }\n          if (Date.now) {\n            return Date.now();\n          }\n          return new Date() - Common._nowStartTime;\n        };\n\n        /**\n         * Returns a random value between a minimum and a maximum value inclusive.\n         * The function uses a seeded random generator.\n         * @method random\n         * @param {number} min\n         * @param {number} max\n         * @return {number} A random number between min and max inclusive\n         */\n        Common.random = function (min, max) {\n          min = typeof min !== \"undefined\" ? min : 0;\n          max = typeof max !== \"undefined\" ? max : 1;\n          return min + _seededRandom() * (max - min);\n        };\n        var _seededRandom = function () {\n          // https://en.wikipedia.org/wiki/Linear_congruential_generator\n          Common._seed = (Common._seed * 9301 + 49297) % 233280;\n          return Common._seed / 233280;\n        };\n\n        /**\n         * Converts a CSS hex colour string into an integer.\n         * @method colorToNumber\n         * @param {string} colorString\n         * @return {number} An integer representing the CSS hex string\n         */\n        Common.colorToNumber = function (colorString) {\n          colorString = colorString.replace('#', '');\n          if (colorString.length == 3) {\n            colorString = colorString.charAt(0) + colorString.charAt(0) + colorString.charAt(1) + colorString.charAt(1) + colorString.charAt(2) + colorString.charAt(2);\n          }\n          return parseInt(colorString, 16);\n        };\n\n        /**\n         * The console logging level to use, where each level includes all levels above and excludes the levels below.\n         * The default level is 'debug' which shows all console messages.  \n         *\n         * Possible level values are:\n         * - 0 = None\n         * - 1 = Debug\n         * - 2 = Info\n         * - 3 = Warn\n         * - 4 = Error\n         * @static\n         * @property logLevel\n         * @type {Number}\n         * @default 1\n         */\n        Common.logLevel = 1;\n\n        /**\n         * Shows a `console.log` message only if the current `Common.logLevel` allows it.\n         * The message will be prefixed with 'matter-js' to make it easily identifiable.\n         * @method log\n         * @param ...objs {} The objects to log.\n         */\n        Common.log = function () {\n          if (console && Common.logLevel > 0 && Common.logLevel <= 3) {\n            console.log.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));\n          }\n        };\n\n        /**\n         * Shows a `console.info` message only if the current `Common.logLevel` allows it.\n         * The message will be prefixed with 'matter-js' to make it easily identifiable.\n         * @method info\n         * @param ...objs {} The objects to log.\n         */\n        Common.info = function () {\n          if (console && Common.logLevel > 0 && Common.logLevel <= 2) {\n            console.info.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));\n          }\n        };\n\n        /**\n         * Shows a `console.warn` message only if the current `Common.logLevel` allows it.\n         * The message will be prefixed with 'matter-js' to make it easily identifiable.\n         * @method warn\n         * @param ...objs {} The objects to log.\n         */\n        Common.warn = function () {\n          if (console && Common.logLevel > 0 && Common.logLevel <= 3) {\n            console.warn.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));\n          }\n        };\n\n        /**\n         * Uses `Common.warn` to log the given message one time only.\n         * @method warnOnce\n         * @param ...objs {} The objects to log.\n         */\n        Common.warnOnce = function () {\n          var message = Array.prototype.slice.call(arguments).join(' ');\n          if (!Common._warnedOnce[message]) {\n            Common.warn(message);\n            Common._warnedOnce[message] = true;\n          }\n        };\n\n        /**\n         * Shows a deprecated console warning when the function on the given object is called.\n         * The target function will be replaced with a new function that first shows the warning\n         * and then calls the original function.\n         * @method deprecated\n         * @param {object} obj The object or module\n         * @param {string} name The property name of the function on obj\n         * @param {string} warning The one-time message to show if the function is called\n         */\n        Common.deprecated = function (obj, prop, warning) {\n          obj[prop] = Common.chain(function () {\n            Common.warnOnce('🔅 deprecated 🔅', warning);\n          }, obj[prop]);\n        };\n\n        /**\n         * Returns the next unique sequential ID.\n         * @method nextId\n         * @return {Number} Unique sequential ID\n         */\n        Common.nextId = function () {\n          return Common._nextId++;\n        };\n\n        /**\n         * A cross browser compatible indexOf implementation.\n         * @method indexOf\n         * @param {array} haystack\n         * @param {object} needle\n         * @return {number} The position of needle in haystack, otherwise -1.\n         */\n        Common.indexOf = function (haystack, needle) {\n          if (haystack.indexOf) return haystack.indexOf(needle);\n          for (var i = 0; i < haystack.length; i++) {\n            if (haystack[i] === needle) return i;\n          }\n          return -1;\n        };\n\n        /**\n         * A cross browser compatible array map implementation.\n         * @method map\n         * @param {array} list\n         * @param {function} func\n         * @return {array} Values from list transformed by func.\n         */\n        Common.map = function (list, func) {\n          if (list.map) {\n            return list.map(func);\n          }\n          var mapped = [];\n          for (var i = 0; i < list.length; i += 1) {\n            mapped.push(func(list[i]));\n          }\n          return mapped;\n        };\n\n        /**\n         * Takes a directed graph and returns the partially ordered set of vertices in topological order.\n         * Circular dependencies are allowed.\n         * @method topologicalSort\n         * @param {object} graph\n         * @return {array} Partially ordered set of vertices in topological order.\n         */\n        Common.topologicalSort = function (graph) {\n          // https://github.com/mgechev/javascript-algorithms\n          // Copyright (c) Minko Gechev (MIT license)\n          // Modifications: tidy formatting and naming\n          var result = [],\n            visited = [],\n            temp = [];\n          for (var node in graph) {\n            if (!visited[node] && !temp[node]) {\n              Common._topologicalSort(node, visited, temp, graph, result);\n            }\n          }\n          return result;\n        };\n        Common._topologicalSort = function (node, visited, temp, graph, result) {\n          var neighbors = graph[node] || [];\n          temp[node] = true;\n          for (var i = 0; i < neighbors.length; i += 1) {\n            var neighbor = neighbors[i];\n            if (temp[neighbor]) {\n              // skip circular dependencies\n              continue;\n            }\n            if (!visited[neighbor]) {\n              Common._topologicalSort(neighbor, visited, temp, graph, result);\n            }\n          }\n          temp[node] = false;\n          visited[node] = true;\n          result.push(node);\n        };\n\n        /**\n         * Takes _n_ functions as arguments and returns a new function that calls them in order.\n         * The arguments applied when calling the new function will also be applied to every function passed.\n         * The value of `this` refers to the last value returned in the chain that was not `undefined`.\n         * Therefore if a passed function does not return a value, the previously returned value is maintained.\n         * After all passed functions have been called the new function returns the last returned value (if any).\n         * If any of the passed functions are a chain, then the chain will be flattened.\n         * @method chain\n         * @param ...funcs {function} The functions to chain.\n         * @return {function} A new function that calls the passed functions in order.\n         */\n        Common.chain = function () {\n          var funcs = [];\n          for (var i = 0; i < arguments.length; i += 1) {\n            var func = arguments[i];\n            if (func._chained) {\n              // flatten already chained functions\n              funcs.push.apply(funcs, func._chained);\n            } else {\n              funcs.push(func);\n            }\n          }\n          var chain = function () {\n            // https://github.com/GoogleChrome/devtools-docs/issues/53#issuecomment-51941358\n            var lastResult,\n              args = new Array(arguments.length);\n            for (var i = 0, l = arguments.length; i < l; i++) {\n              args[i] = arguments[i];\n            }\n            for (i = 0; i < funcs.length; i += 1) {\n              var result = funcs[i].apply(lastResult, args);\n              if (typeof result !== 'undefined') {\n                lastResult = result;\n              }\n            }\n            return lastResult;\n          };\n          chain._chained = funcs;\n          return chain;\n        };\n\n        /**\n         * Chains a function to excute before the original function on the given `path` relative to `base`.\n         * See also docs for `Common.chain`.\n         * @method chainPathBefore\n         * @param {} base The base object\n         * @param {string} path The path relative to `base`\n         * @param {function} func The function to chain before the original\n         * @return {function} The chained function that replaced the original\n         */\n        Common.chainPathBefore = function (base, path, func) {\n          return Common.set(base, path, Common.chain(func, Common.get(base, path)));\n        };\n\n        /**\n         * Chains a function to excute after the original function on the given `path` relative to `base`.\n         * See also docs for `Common.chain`.\n         * @method chainPathAfter\n         * @param {} base The base object\n         * @param {string} path The path relative to `base`\n         * @param {function} func The function to chain after the original\n         * @return {function} The chained function that replaced the original\n         */\n        Common.chainPathAfter = function (base, path, func) {\n          return Common.set(base, path, Common.chain(Common.get(base, path), func));\n        };\n\n        /**\n         * Provide the [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module to enable\n         * concave vertex decomposition support when using `Bodies.fromVertices` e.g. `Common.setDecomp(require('poly-decomp'))`.\n         * @method setDecomp\n         * @param {} decomp The [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module.\n         */\n        Common.setDecomp = function (decomp) {\n          Common._decomp = decomp;\n        };\n\n        /**\n         * Returns the [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module provided through `Common.setDecomp`,\n         * otherwise returns the global `decomp` if set.\n         * @method getDecomp\n         * @return {} The [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module if provided.\n         */\n        Common.getDecomp = function () {\n          // get user provided decomp if set\n          var decomp = Common._decomp;\n          try {\n            // otherwise from window global\n            if (!decomp && typeof window !== 'undefined') {\n              decomp = window.decomp;\n            }\n\n            // otherwise from node global\n            if (!decomp && typeof __webpack_require__.g !== 'undefined') {\n              decomp = __webpack_require__.g.decomp;\n            }\n          } catch (e) {\n            // decomp not available\n            decomp = null;\n          }\n          return decomp;\n        };\n      })();\n\n      /***/\n    }, /* 1 */\n    /***/function (module, exports) {\n      /**\n      * The `Matter.Bounds` module contains methods for creating and manipulating axis-aligned bounding boxes (AABB).\n      *\n      * @class Bounds\n      */\n\n      var Bounds = {};\n      module.exports = Bounds;\n      (function () {\n        /**\n         * Creates a new axis-aligned bounding box (AABB) for the given vertices.\n         * @method create\n         * @param {vertices} vertices\n         * @return {bounds} A new bounds object\n         */\n        Bounds.create = function (vertices) {\n          var bounds = {\n            min: {\n              x: 0,\n              y: 0\n            },\n            max: {\n              x: 0,\n              y: 0\n            }\n          };\n          if (vertices) Bounds.update(bounds, vertices);\n          return bounds;\n        };\n\n        /**\n         * Updates bounds using the given vertices and extends the bounds given a velocity.\n         * @method update\n         * @param {bounds} bounds\n         * @param {vertices} vertices\n         * @param {vector} velocity\n         */\n        Bounds.update = function (bounds, vertices, velocity) {\n          bounds.min.x = Infinity;\n          bounds.max.x = -Infinity;\n          bounds.min.y = Infinity;\n          bounds.max.y = -Infinity;\n          for (var i = 0; i < vertices.length; i++) {\n            var vertex = vertices[i];\n            if (vertex.x > bounds.max.x) bounds.max.x = vertex.x;\n            if (vertex.x < bounds.min.x) bounds.min.x = vertex.x;\n            if (vertex.y > bounds.max.y) bounds.max.y = vertex.y;\n            if (vertex.y < bounds.min.y) bounds.min.y = vertex.y;\n          }\n          if (velocity) {\n            if (velocity.x > 0) {\n              bounds.max.x += velocity.x;\n            } else {\n              bounds.min.x += velocity.x;\n            }\n            if (velocity.y > 0) {\n              bounds.max.y += velocity.y;\n            } else {\n              bounds.min.y += velocity.y;\n            }\n          }\n        };\n\n        /**\n         * Returns true if the bounds contains the given point.\n         * @method contains\n         * @param {bounds} bounds\n         * @param {vector} point\n         * @return {boolean} True if the bounds contain the point, otherwise false\n         */\n        Bounds.contains = function (bounds, point) {\n          return point.x >= bounds.min.x && point.x <= bounds.max.x && point.y >= bounds.min.y && point.y <= bounds.max.y;\n        };\n\n        /**\n         * Returns true if the two bounds intersect.\n         * @method overlaps\n         * @param {bounds} boundsA\n         * @param {bounds} boundsB\n         * @return {boolean} True if the bounds overlap, otherwise false\n         */\n        Bounds.overlaps = function (boundsA, boundsB) {\n          return boundsA.min.x <= boundsB.max.x && boundsA.max.x >= boundsB.min.x && boundsA.max.y >= boundsB.min.y && boundsA.min.y <= boundsB.max.y;\n        };\n\n        /**\n         * Translates the bounds by the given vector.\n         * @method translate\n         * @param {bounds} bounds\n         * @param {vector} vector\n         */\n        Bounds.translate = function (bounds, vector) {\n          bounds.min.x += vector.x;\n          bounds.max.x += vector.x;\n          bounds.min.y += vector.y;\n          bounds.max.y += vector.y;\n        };\n\n        /**\n         * Shifts the bounds to the given position.\n         * @method shift\n         * @param {bounds} bounds\n         * @param {vector} position\n         */\n        Bounds.shift = function (bounds, position) {\n          var deltaX = bounds.max.x - bounds.min.x,\n            deltaY = bounds.max.y - bounds.min.y;\n          bounds.min.x = position.x;\n          bounds.max.x = position.x + deltaX;\n          bounds.min.y = position.y;\n          bounds.max.y = position.y + deltaY;\n        };\n      })();\n\n      /***/\n    }, /* 2 */\n    /***/function (module, exports) {\n      /**\n      * The `Matter.Vector` module contains methods for creating and manipulating vectors.\n      * Vectors are the basis of all the geometry related operations in the engine.\n      * A `Matter.Vector` object is of the form `{ x: 0, y: 0 }`.\n      *\n      * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n      *\n      * @class Vector\n      */\n\n      // TODO: consider params for reusing vector objects\n\n      var Vector = {};\n      module.exports = Vector;\n      (function () {\n        /**\n         * Creates a new vector.\n         * @method create\n         * @param {number} x\n         * @param {number} y\n         * @return {vector} A new vector\n         */\n        Vector.create = function (x, y) {\n          return {\n            x: x || 0,\n            y: y || 0\n          };\n        };\n\n        /**\n         * Returns a new vector with `x` and `y` copied from the given `vector`.\n         * @method clone\n         * @param {vector} vector\n         * @return {vector} A new cloned vector\n         */\n        Vector.clone = function (vector) {\n          return {\n            x: vector.x,\n            y: vector.y\n          };\n        };\n\n        /**\n         * Returns the magnitude (length) of a vector.\n         * @method magnitude\n         * @param {vector} vector\n         * @return {number} The magnitude of the vector\n         */\n        Vector.magnitude = function (vector) {\n          return Math.sqrt(vector.x * vector.x + vector.y * vector.y);\n        };\n\n        /**\n         * Returns the magnitude (length) of a vector (therefore saving a `sqrt` operation).\n         * @method magnitudeSquared\n         * @param {vector} vector\n         * @return {number} The squared magnitude of the vector\n         */\n        Vector.magnitudeSquared = function (vector) {\n          return vector.x * vector.x + vector.y * vector.y;\n        };\n\n        /**\n         * Rotates the vector about (0, 0) by specified angle.\n         * @method rotate\n         * @param {vector} vector\n         * @param {number} angle\n         * @param {vector} [output]\n         * @return {vector} The vector rotated about (0, 0)\n         */\n        Vector.rotate = function (vector, angle, output) {\n          var cos = Math.cos(angle),\n            sin = Math.sin(angle);\n          if (!output) output = {};\n          var x = vector.x * cos - vector.y * sin;\n          output.y = vector.x * sin + vector.y * cos;\n          output.x = x;\n          return output;\n        };\n\n        /**\n         * Rotates the vector about a specified point by specified angle.\n         * @method rotateAbout\n         * @param {vector} vector\n         * @param {number} angle\n         * @param {vector} point\n         * @param {vector} [output]\n         * @return {vector} A new vector rotated about the point\n         */\n        Vector.rotateAbout = function (vector, angle, point, output) {\n          var cos = Math.cos(angle),\n            sin = Math.sin(angle);\n          if (!output) output = {};\n          var x = point.x + ((vector.x - point.x) * cos - (vector.y - point.y) * sin);\n          output.y = point.y + ((vector.x - point.x) * sin + (vector.y - point.y) * cos);\n          output.x = x;\n          return output;\n        };\n\n        /**\n         * Normalises a vector (such that its magnitude is `1`).\n         * @method normalise\n         * @param {vector} vector\n         * @return {vector} A new vector normalised\n         */\n        Vector.normalise = function (vector) {\n          var magnitude = Vector.magnitude(vector);\n          if (magnitude === 0) return {\n            x: 0,\n            y: 0\n          };\n          return {\n            x: vector.x / magnitude,\n            y: vector.y / magnitude\n          };\n        };\n\n        /**\n         * Returns the dot-product of two vectors.\n         * @method dot\n         * @param {vector} vectorA\n         * @param {vector} vectorB\n         * @return {number} The dot product of the two vectors\n         */\n        Vector.dot = function (vectorA, vectorB) {\n          return vectorA.x * vectorB.x + vectorA.y * vectorB.y;\n        };\n\n        /**\n         * Returns the cross-product of two vectors.\n         * @method cross\n         * @param {vector} vectorA\n         * @param {vector} vectorB\n         * @return {number} The cross product of the two vectors\n         */\n        Vector.cross = function (vectorA, vectorB) {\n          return vectorA.x * vectorB.y - vectorA.y * vectorB.x;\n        };\n\n        /**\n         * Returns the cross-product of three vectors.\n         * @method cross3\n         * @param {vector} vectorA\n         * @param {vector} vectorB\n         * @param {vector} vectorC\n         * @return {number} The cross product of the three vectors\n         */\n        Vector.cross3 = function (vectorA, vectorB, vectorC) {\n          return (vectorB.x - vectorA.x) * (vectorC.y - vectorA.y) - (vectorB.y - vectorA.y) * (vectorC.x - vectorA.x);\n        };\n\n        /**\n         * Adds the two vectors.\n         * @method add\n         * @param {vector} vectorA\n         * @param {vector} vectorB\n         * @param {vector} [output]\n         * @return {vector} A new vector of vectorA and vectorB added\n         */\n        Vector.add = function (vectorA, vectorB, output) {\n          if (!output) output = {};\n          output.x = vectorA.x + vectorB.x;\n          output.y = vectorA.y + vectorB.y;\n          return output;\n        };\n\n        /**\n         * Subtracts the two vectors.\n         * @method sub\n         * @param {vector} vectorA\n         * @param {vector} vectorB\n         * @param {vector} [output]\n         * @return {vector} A new vector of vectorA and vectorB subtracted\n         */\n        Vector.sub = function (vectorA, vectorB, output) {\n          if (!output) output = {};\n          output.x = vectorA.x - vectorB.x;\n          output.y = vectorA.y - vectorB.y;\n          return output;\n        };\n\n        /**\n         * Multiplies a vector and a scalar.\n         * @method mult\n         * @param {vector} vector\n         * @param {number} scalar\n         * @return {vector} A new vector multiplied by scalar\n         */\n        Vector.mult = function (vector, scalar) {\n          return {\n            x: vector.x * scalar,\n            y: vector.y * scalar\n          };\n        };\n\n        /**\n         * Divides a vector and a scalar.\n         * @method div\n         * @param {vector} vector\n         * @param {number} scalar\n         * @return {vector} A new vector divided by scalar\n         */\n        Vector.div = function (vector, scalar) {\n          return {\n            x: vector.x / scalar,\n            y: vector.y / scalar\n          };\n        };\n\n        /**\n         * Returns the perpendicular vector. Set `negate` to true for the perpendicular in the opposite direction.\n         * @method perp\n         * @param {vector} vector\n         * @param {bool} [negate=false]\n         * @return {vector} The perpendicular vector\n         */\n        Vector.perp = function (vector, negate) {\n          negate = negate === true ? -1 : 1;\n          return {\n            x: negate * -vector.y,\n            y: negate * vector.x\n          };\n        };\n\n        /**\n         * Negates both components of a vector such that it points in the opposite direction.\n         * @method neg\n         * @param {vector} vector\n         * @return {vector} The negated vector\n         */\n        Vector.neg = function (vector) {\n          return {\n            x: -vector.x,\n            y: -vector.y\n          };\n        };\n\n        /**\n         * Returns the angle between the vector `vectorB - vectorA` and the x-axis in radians.\n         * @method angle\n         * @param {vector} vectorA\n         * @param {vector} vectorB\n         * @return {number} The angle in radians\n         */\n        Vector.angle = function (vectorA, vectorB) {\n          return Math.atan2(vectorB.y - vectorA.y, vectorB.x - vectorA.x);\n        };\n\n        /**\n         * Temporary vector pool (not thread-safe).\n         * @property _temp\n         * @type {vector[]}\n         * @private\n         */\n        Vector._temp = [Vector.create(), Vector.create(), Vector.create(), Vector.create(), Vector.create(), Vector.create()];\n      })();\n\n      /***/\n    }, /* 3 */\n    /***/function (module, exports, __nested_webpack_require_38819__) {\n      /**\n      * The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.\n      * A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.\n      * A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).\n      *\n      * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n      *\n      * @class Vertices\n      */\n\n      var Vertices = {};\n      module.exports = Vertices;\n      var Vector = __nested_webpack_require_38819__(2);\n      var Common = __nested_webpack_require_38819__(0);\n      (function () {\n        /**\n         * Creates a new set of `Matter.Body` compatible vertices.\n         * The `points` argument accepts an array of `Matter.Vector` points orientated around the origin `(0, 0)`, for example:\n         *\n         *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]\n         *\n         * The `Vertices.create` method returns a new array of vertices, which are similar to Matter.Vector objects,\n         * but with some additional references required for efficient collision detection routines.\n         *\n         * Vertices must be specified in clockwise order.\n         *\n         * Note that the `body` argument is not optional, a `Matter.Body` reference must be provided.\n         *\n         * @method create\n         * @param {vector[]} points\n         * @param {body} body\n         */\n        Vertices.create = function (points, body) {\n          var vertices = [];\n          for (var i = 0; i < points.length; i++) {\n            var point = points[i],\n              vertex = {\n                x: point.x,\n                y: point.y,\n                index: i,\n                body: body,\n                isInternal: false\n              };\n            vertices.push(vertex);\n          }\n          return vertices;\n        };\n\n        /**\n         * Parses a string containing ordered x y pairs separated by spaces (and optionally commas), \n         * into a `Matter.Vertices` object for the given `Matter.Body`.\n         * For parsing SVG paths, see `Svg.pathToVertices`.\n         * @method fromPath\n         * @param {string} path\n         * @param {body} body\n         * @return {vertices} vertices\n         */\n        Vertices.fromPath = function (path, body) {\n          var pathPattern = /L?\\s*([-\\d.e]+)[\\s,]*([-\\d.e]+)*/ig,\n            points = [];\n          path.replace(pathPattern, function (match, x, y) {\n            points.push({\n              x: parseFloat(x),\n              y: parseFloat(y)\n            });\n          });\n          return Vertices.create(points, body);\n        };\n\n        /**\n         * Returns the centre (centroid) of the set of vertices.\n         * @method centre\n         * @param {vertices} vertices\n         * @return {vector} The centre point\n         */\n        Vertices.centre = function (vertices) {\n          var area = Vertices.area(vertices, true),\n            centre = {\n              x: 0,\n              y: 0\n            },\n            cross,\n            temp,\n            j;\n          for (var i = 0; i < vertices.length; i++) {\n            j = (i + 1) % vertices.length;\n            cross = Vector.cross(vertices[i], vertices[j]);\n            temp = Vector.mult(Vector.add(vertices[i], vertices[j]), cross);\n            centre = Vector.add(centre, temp);\n          }\n          return Vector.div(centre, 6 * area);\n        };\n\n        /**\n         * Returns the average (mean) of the set of vertices.\n         * @method mean\n         * @param {vertices} vertices\n         * @return {vector} The average point\n         */\n        Vertices.mean = function (vertices) {\n          var average = {\n            x: 0,\n            y: 0\n          };\n          for (var i = 0; i < vertices.length; i++) {\n            average.x += vertices[i].x;\n            average.y += vertices[i].y;\n          }\n          return Vector.div(average, vertices.length);\n        };\n\n        /**\n         * Returns the area of the set of vertices.\n         * @method area\n         * @param {vertices} vertices\n         * @param {bool} signed\n         * @return {number} The area\n         */\n        Vertices.area = function (vertices, signed) {\n          var area = 0,\n            j = vertices.length - 1;\n          for (var i = 0; i < vertices.length; i++) {\n            area += (vertices[j].x - vertices[i].x) * (vertices[j].y + vertices[i].y);\n            j = i;\n          }\n          if (signed) return area / 2;\n          return Math.abs(area) / 2;\n        };\n\n        /**\n         * Returns the moment of inertia (second moment of area) of the set of vertices given the total mass.\n         * @method inertia\n         * @param {vertices} vertices\n         * @param {number} mass\n         * @return {number} The polygon's moment of inertia\n         */\n        Vertices.inertia = function (vertices, mass) {\n          var numerator = 0,\n            denominator = 0,\n            v = vertices,\n            cross,\n            j;\n\n          // find the polygon's moment of inertia, using second moment of area\n          // from equations at http://www.physicsforums.com/showthread.php?t=25293\n          for (var n = 0; n < v.length; n++) {\n            j = (n + 1) % v.length;\n            cross = Math.abs(Vector.cross(v[j], v[n]));\n            numerator += cross * (Vector.dot(v[j], v[j]) + Vector.dot(v[j], v[n]) + Vector.dot(v[n], v[n]));\n            denominator += cross;\n          }\n          return mass / 6 * (numerator / denominator);\n        };\n\n        /**\n         * Translates the set of vertices in-place.\n         * @method translate\n         * @param {vertices} vertices\n         * @param {vector} vector\n         * @param {number} scalar\n         */\n        Vertices.translate = function (vertices, vector, scalar) {\n          scalar = typeof scalar !== 'undefined' ? scalar : 1;\n          var verticesLength = vertices.length,\n            translateX = vector.x * scalar,\n            translateY = vector.y * scalar,\n            i;\n          for (i = 0; i < verticesLength; i++) {\n            vertices[i].x += translateX;\n            vertices[i].y += translateY;\n          }\n          return vertices;\n        };\n\n        /**\n         * Rotates the set of vertices in-place.\n         * @method rotate\n         * @param {vertices} vertices\n         * @param {number} angle\n         * @param {vector} point\n         */\n        Vertices.rotate = function (vertices, angle, point) {\n          if (angle === 0) return;\n          var cos = Math.cos(angle),\n            sin = Math.sin(angle),\n            pointX = point.x,\n            pointY = point.y,\n            verticesLength = vertices.length,\n            vertex,\n            dx,\n            dy,\n            i;\n          for (i = 0; i < verticesLength; i++) {\n            vertex = vertices[i];\n            dx = vertex.x - pointX;\n            dy = vertex.y - pointY;\n            vertex.x = pointX + (dx * cos - dy * sin);\n            vertex.y = pointY + (dx * sin + dy * cos);\n          }\n          return vertices;\n        };\n\n        /**\n         * Returns `true` if the `point` is inside the set of `vertices`.\n         * @method contains\n         * @param {vertices} vertices\n         * @param {vector} point\n         * @return {boolean} True if the vertices contains point, otherwise false\n         */\n        Vertices.contains = function (vertices, point) {\n          var pointX = point.x,\n            pointY = point.y,\n            verticesLength = vertices.length,\n            vertex = vertices[verticesLength - 1],\n            nextVertex;\n          for (var i = 0; i < verticesLength; i++) {\n            nextVertex = vertices[i];\n            if ((pointX - vertex.x) * (nextVertex.y - vertex.y) + (pointY - vertex.y) * (vertex.x - nextVertex.x) > 0) {\n              return false;\n            }\n            vertex = nextVertex;\n          }\n          return true;\n        };\n\n        /**\n         * Scales the vertices from a point (default is centre) in-place.\n         * @method scale\n         * @param {vertices} vertices\n         * @param {number} scaleX\n         * @param {number} scaleY\n         * @param {vector} point\n         */\n        Vertices.scale = function (vertices, scaleX, scaleY, point) {\n          if (scaleX === 1 && scaleY === 1) return vertices;\n          point = point || Vertices.centre(vertices);\n          var vertex, delta;\n          for (var i = 0; i < vertices.length; i++) {\n            vertex = vertices[i];\n            delta = Vector.sub(vertex, point);\n            vertices[i].x = point.x + delta.x * scaleX;\n            vertices[i].y = point.y + delta.y * scaleY;\n          }\n          return vertices;\n        };\n\n        /**\n         * Chamfers a set of vertices by giving them rounded corners, returns a new set of vertices.\n         * The radius parameter is a single number or an array to specify the radius for each vertex.\n         * @method chamfer\n         * @param {vertices} vertices\n         * @param {number[]} radius\n         * @param {number} quality\n         * @param {number} qualityMin\n         * @param {number} qualityMax\n         */\n        Vertices.chamfer = function (vertices, radius, quality, qualityMin, qualityMax) {\n          if (typeof radius === 'number') {\n            radius = [radius];\n          } else {\n            radius = radius || [8];\n          }\n\n          // quality defaults to -1, which is auto\n          quality = typeof quality !== 'undefined' ? quality : -1;\n          qualityMin = qualityMin || 2;\n          qualityMax = qualityMax || 14;\n          var newVertices = [];\n          for (var i = 0; i < vertices.length; i++) {\n            var prevVertex = vertices[i - 1 >= 0 ? i - 1 : vertices.length - 1],\n              vertex = vertices[i],\n              nextVertex = vertices[(i + 1) % vertices.length],\n              currentRadius = radius[i < radius.length ? i : radius.length - 1];\n            if (currentRadius === 0) {\n              newVertices.push(vertex);\n              continue;\n            }\n            var prevNormal = Vector.normalise({\n              x: vertex.y - prevVertex.y,\n              y: prevVertex.x - vertex.x\n            });\n            var nextNormal = Vector.normalise({\n              x: nextVertex.y - vertex.y,\n              y: vertex.x - nextVertex.x\n            });\n            var diagonalRadius = Math.sqrt(2 * Math.pow(currentRadius, 2)),\n              radiusVector = Vector.mult(Common.clone(prevNormal), currentRadius),\n              midNormal = Vector.normalise(Vector.mult(Vector.add(prevNormal, nextNormal), 0.5)),\n              scaledVertex = Vector.sub(vertex, Vector.mult(midNormal, diagonalRadius));\n            var precision = quality;\n            if (quality === -1) {\n              // automatically decide precision\n              precision = Math.pow(currentRadius, 0.32) * 1.75;\n            }\n            precision = Common.clamp(precision, qualityMin, qualityMax);\n\n            // use an even value for precision, more likely to reduce axes by using symmetry\n            if (precision % 2 === 1) precision += 1;\n            var alpha = Math.acos(Vector.dot(prevNormal, nextNormal)),\n              theta = alpha / precision;\n            for (var j = 0; j < precision; j++) {\n              newVertices.push(Vector.add(Vector.rotate(radiusVector, theta * j), scaledVertex));\n            }\n          }\n          return newVertices;\n        };\n\n        /**\n         * Sorts the input vertices into clockwise order in place.\n         * @method clockwiseSort\n         * @param {vertices} vertices\n         * @return {vertices} vertices\n         */\n        Vertices.clockwiseSort = function (vertices) {\n          var centre = Vertices.mean(vertices);\n          vertices.sort(function (vertexA, vertexB) {\n            return Vector.angle(centre, vertexA) - Vector.angle(centre, vertexB);\n          });\n          return vertices;\n        };\n\n        /**\n         * Returns true if the vertices form a convex shape (vertices must be in clockwise order).\n         * @method isConvex\n         * @param {vertices} vertices\n         * @return {bool} `true` if the `vertices` are convex, `false` if not (or `null` if not computable).\n         */\n        Vertices.isConvex = function (vertices) {\n          // http://paulbourke.net/geometry/polygonmesh/\n          // Copyright (c) Paul Bourke (use permitted)\n\n          var flag = 0,\n            n = vertices.length,\n            i,\n            j,\n            k,\n            z;\n          if (n < 3) return null;\n          for (i = 0; i < n; i++) {\n            j = (i + 1) % n;\n            k = (i + 2) % n;\n            z = (vertices[j].x - vertices[i].x) * (vertices[k].y - vertices[j].y);\n            z -= (vertices[j].y - vertices[i].y) * (vertices[k].x - vertices[j].x);\n            if (z < 0) {\n              flag |= 1;\n            } else if (z > 0) {\n              flag |= 2;\n            }\n            if (flag === 3) {\n              return false;\n            }\n          }\n          if (flag !== 0) {\n            return true;\n          } else {\n            return null;\n          }\n        };\n\n        /**\n         * Returns the convex hull of the input vertices as a new array of points.\n         * @method hull\n         * @param {vertices} vertices\n         * @return [vertex] vertices\n         */\n        Vertices.hull = function (vertices) {\n          // http://geomalgorithms.com/a10-_hull-1.html\n\n          var upper = [],\n            lower = [],\n            vertex,\n            i;\n\n          // sort vertices on x-axis (y-axis for ties)\n          vertices = vertices.slice(0);\n          vertices.sort(function (vertexA, vertexB) {\n            var dx = vertexA.x - vertexB.x;\n            return dx !== 0 ? dx : vertexA.y - vertexB.y;\n          });\n\n          // build lower hull\n          for (i = 0; i < vertices.length; i += 1) {\n            vertex = vertices[i];\n            while (lower.length >= 2 && Vector.cross3(lower[lower.length - 2], lower[lower.length - 1], vertex) <= 0) {\n              lower.pop();\n            }\n            lower.push(vertex);\n          }\n\n          // build upper hull\n          for (i = vertices.length - 1; i >= 0; i -= 1) {\n            vertex = vertices[i];\n            while (upper.length >= 2 && Vector.cross3(upper[upper.length - 2], upper[upper.length - 1], vertex) <= 0) {\n              upper.pop();\n            }\n            upper.push(vertex);\n          }\n\n          // concatenation of the lower and upper hulls gives the convex hull\n          // omit last points because they are repeated at the beginning of the other list\n          upper.pop();\n          lower.pop();\n          return upper.concat(lower);\n        };\n      })();\n\n      /***/\n    }, /* 4 */\n    /***/function (module, exports, __nested_webpack_require_53625__) {\n      /**\n      * The `Matter.Body` module contains methods for creating and manipulating rigid bodies.\n      * For creating bodies with common configurations such as rectangles, circles and other polygons see the module `Matter.Bodies`.\n      *\n      * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n      \n      * @class Body\n      */\n\n      var Body = {};\n      module.exports = Body;\n      var Vertices = __nested_webpack_require_53625__(3);\n      var Vector = __nested_webpack_require_53625__(2);\n      var Sleeping = __nested_webpack_require_53625__(7);\n      var Common = __nested_webpack_require_53625__(0);\n      var Bounds = __nested_webpack_require_53625__(1);\n      var Axes = __nested_webpack_require_53625__(11);\n      (function () {\n        Body._timeCorrection = true;\n        Body._inertiaScale = 4;\n        Body._nextCollidingGroupId = 1;\n        Body._nextNonCollidingGroupId = -1;\n        Body._nextCategory = 0x0001;\n        Body._baseDelta = 1000 / 60;\n\n        /**\n         * Creates a new rigid body model. The options parameter is an object that specifies any properties you wish to override the defaults.\n         * All properties have default values, and many are pre-calculated automatically based on other properties.\n         * Vertices must be specified in clockwise order.\n         * See the properties section below for detailed information on what you can pass via the `options` object.\n         * @method create\n         * @param {} options\n         * @return {body} body\n         */\n        Body.create = function (options) {\n          var defaults = {\n            id: Common.nextId(),\n            type: 'body',\n            label: 'Body',\n            parts: [],\n            plugin: {},\n            angle: 0,\n            vertices: Vertices.fromPath('L 0 0 L 40 0 L 40 40 L 0 40'),\n            position: {\n              x: 0,\n              y: 0\n            },\n            force: {\n              x: 0,\n              y: 0\n            },\n            torque: 0,\n            positionImpulse: {\n              x: 0,\n              y: 0\n            },\n            constraintImpulse: {\n              x: 0,\n              y: 0,\n              angle: 0\n            },\n            totalContacts: 0,\n            speed: 0,\n            angularSpeed: 0,\n            velocity: {\n              x: 0,\n              y: 0\n            },\n            angularVelocity: 0,\n            isSensor: false,\n            isStatic: false,\n            isSleeping: false,\n            motion: 0,\n            sleepThreshold: 60,\n            density: 0.001,\n            restitution: 0,\n            friction: 0.1,\n            frictionStatic: 0.5,\n            frictionAir: 0.01,\n            collisionFilter: {\n              category: 0x0001,\n              mask: 0xFFFFFFFF,\n              group: 0\n            },\n            slop: 0.05,\n            timeScale: 1,\n            render: {\n              visible: true,\n              opacity: 1,\n              strokeStyle: null,\n              fillStyle: null,\n              lineWidth: null,\n              sprite: {\n                xScale: 1,\n                yScale: 1,\n                xOffset: 0,\n                yOffset: 0\n              }\n            },\n            events: null,\n            bounds: null,\n            chamfer: null,\n            circleRadius: 0,\n            positionPrev: null,\n            anglePrev: 0,\n            parent: null,\n            axes: null,\n            area: 0,\n            mass: 0,\n            inertia: 0,\n            deltaTime: 1000 / 60,\n            _original: null\n          };\n          var body = Common.extend(defaults, options);\n          _initProperties(body, options);\n          return body;\n        };\n\n        /**\n         * Returns the next unique group index for which bodies will collide.\n         * If `isNonColliding` is `true`, returns the next unique group index for which bodies will _not_ collide.\n         * See `body.collisionFilter` for more information.\n         * @method nextGroup\n         * @param {bool} [isNonColliding=false]\n         * @return {Number} Unique group index\n         */\n        Body.nextGroup = function (isNonColliding) {\n          if (isNonColliding) return Body._nextNonCollidingGroupId--;\n          return Body._nextCollidingGroupId++;\n        };\n\n        /**\n         * Returns the next unique category bitfield (starting after the initial default category `0x0001`).\n         * There are 32 available. See `body.collisionFilter` for more information.\n         * @method nextCategory\n         * @return {Number} Unique category bitfield\n         */\n        Body.nextCategory = function () {\n          Body._nextCategory = Body._nextCategory << 1;\n          return Body._nextCategory;\n        };\n\n        /**\n         * Initialises body properties.\n         * @method _initProperties\n         * @private\n         * @param {body} body\n         * @param {} [options]\n         */\n        var _initProperties = function (body, options) {\n          options = options || {};\n\n          // init required properties (order is important)\n          Body.set(body, {\n            bounds: body.bounds || Bounds.create(body.vertices),\n            positionPrev: body.positionPrev || Vector.clone(body.position),\n            anglePrev: body.anglePrev || body.angle,\n            vertices: body.vertices,\n            parts: body.parts || [body],\n            isStatic: body.isStatic,\n            isSleeping: body.isSleeping,\n            parent: body.parent || body\n          });\n          Vertices.rotate(body.vertices, body.angle, body.position);\n          Axes.rotate(body.axes, body.angle);\n          Bounds.update(body.bounds, body.vertices, body.velocity);\n\n          // allow options to override the automatically calculated properties\n          Body.set(body, {\n            axes: options.axes || body.axes,\n            area: options.area || body.area,\n            mass: options.mass || body.mass,\n            inertia: options.inertia || body.inertia\n          });\n\n          // render properties\n          var defaultFillStyle = body.isStatic ? '#14151f' : Common.choose(['#f19648', '#f5d259', '#f55a3c', '#063e7b', '#ececd1']),\n            defaultStrokeStyle = body.isStatic ? '#555' : '#ccc',\n            defaultLineWidth = body.isStatic && body.render.fillStyle === null ? 1 : 0;\n          body.render.fillStyle = body.render.fillStyle || defaultFillStyle;\n          body.render.strokeStyle = body.render.strokeStyle || defaultStrokeStyle;\n          body.render.lineWidth = body.render.lineWidth || defaultLineWidth;\n          body.render.sprite.xOffset += -(body.bounds.min.x - body.position.x) / (body.bounds.max.x - body.bounds.min.x);\n          body.render.sprite.yOffset += -(body.bounds.min.y - body.position.y) / (body.bounds.max.y - body.bounds.min.y);\n        };\n\n        /**\n         * Given a property and a value (or map of), sets the property(s) on the body, using the appropriate setter functions if they exist.\n         * Prefer to use the actual setter functions in performance critical situations.\n         * @method set\n         * @param {body} body\n         * @param {} settings A property name (or map of properties and values) to set on the body.\n         * @param {} value The value to set if `settings` is a single property name.\n         */\n        Body.set = function (body, settings, value) {\n          var property;\n          if (typeof settings === 'string') {\n            property = settings;\n            settings = {};\n            settings[property] = value;\n          }\n          for (property in settings) {\n            if (!Object.prototype.hasOwnProperty.call(settings, property)) continue;\n            value = settings[property];\n            switch (property) {\n              case 'isStatic':\n                Body.setStatic(body, value);\n                break;\n              case 'isSleeping':\n                Sleeping.set(body, value);\n                break;\n              case 'mass':\n                Body.setMass(body, value);\n                break;\n              case 'density':\n                Body.setDensity(body, value);\n                break;\n              case 'inertia':\n                Body.setInertia(body, value);\n                break;\n              case 'vertices':\n                Body.setVertices(body, value);\n                break;\n              case 'position':\n                Body.setPosition(body, value);\n                break;\n              case 'angle':\n                Body.setAngle(body, value);\n                break;\n              case 'velocity':\n                Body.setVelocity(body, value);\n                break;\n              case 'angularVelocity':\n                Body.setAngularVelocity(body, value);\n                break;\n              case 'speed':\n                Body.setSpeed(body, value);\n                break;\n              case 'angularSpeed':\n                Body.setAngularSpeed(body, value);\n                break;\n              case 'parts':\n                Body.setParts(body, value);\n                break;\n              case 'centre':\n                Body.setCentre(body, value);\n                break;\n              default:\n                body[property] = value;\n            }\n          }\n        };\n\n        /**\n         * Sets the body as static, including isStatic flag and setting mass and inertia to Infinity.\n         * @method setStatic\n         * @param {body} body\n         * @param {bool} isStatic\n         */\n        Body.setStatic = function (body, isStatic) {\n          for (var i = 0; i < body.parts.length; i++) {\n            var part = body.parts[i];\n            part.isStatic = isStatic;\n            if (isStatic) {\n              part._original = {\n                restitution: part.restitution,\n                friction: part.friction,\n                mass: part.mass,\n                inertia: part.inertia,\n                density: part.density,\n                inverseMass: part.inverseMass,\n                inverseInertia: part.inverseInertia\n              };\n              part.restitution = 0;\n              part.friction = 1;\n              part.mass = part.inertia = part.density = Infinity;\n              part.inverseMass = part.inverseInertia = 0;\n              part.positionPrev.x = part.position.x;\n              part.positionPrev.y = part.position.y;\n              part.anglePrev = part.angle;\n              part.angularVelocity = 0;\n              part.speed = 0;\n              part.angularSpeed = 0;\n              part.motion = 0;\n            } else if (part._original) {\n              part.restitution = part._original.restitution;\n              part.friction = part._original.friction;\n              part.mass = part._original.mass;\n              part.inertia = part._original.inertia;\n              part.density = part._original.density;\n              part.inverseMass = part._original.inverseMass;\n              part.inverseInertia = part._original.inverseInertia;\n              part._original = null;\n            }\n          }\n        };\n\n        /**\n         * Sets the mass of the body. Inverse mass, density and inertia are automatically updated to reflect the change.\n         * @method setMass\n         * @param {body} body\n         * @param {number} mass\n         */\n        Body.setMass = function (body, mass) {\n          var moment = body.inertia / (body.mass / 6);\n          body.inertia = moment * (mass / 6);\n          body.inverseInertia = 1 / body.inertia;\n          body.mass = mass;\n          body.inverseMass = 1 / body.mass;\n          body.density = body.mass / body.area;\n        };\n\n        /**\n         * Sets the density of the body. Mass and inertia are automatically updated to reflect the change.\n         * @method setDensity\n         * @param {body} body\n         * @param {number} density\n         */\n        Body.setDensity = function (body, density) {\n          Body.setMass(body, density * body.area);\n          body.density = density;\n        };\n\n        /**\n         * Sets the moment of inertia of the body. This is the second moment of area in two dimensions.\n         * Inverse inertia is automatically updated to reflect the change. Mass is not changed.\n         * @method setInertia\n         * @param {body} body\n         * @param {number} inertia\n         */\n        Body.setInertia = function (body, inertia) {\n          body.inertia = inertia;\n          body.inverseInertia = 1 / body.inertia;\n        };\n\n        /**\n         * Sets the body's vertices and updates body properties accordingly, including inertia, area and mass (with respect to `body.density`).\n         * Vertices will be automatically transformed to be orientated around their centre of mass as the origin.\n         * They are then automatically translated to world space based on `body.position`.\n         *\n         * The `vertices` argument should be passed as an array of `Matter.Vector` points (or a `Matter.Vertices` array).\n         * Vertices must form a convex hull. Concave vertices must be decomposed into convex parts.\n         * \n         * @method setVertices\n         * @param {body} body\n         * @param {vector[]} vertices\n         */\n        Body.setVertices = function (body, vertices) {\n          // change vertices\n          if (vertices[0].body === body) {\n            body.vertices = vertices;\n          } else {\n            body.vertices = Vertices.create(vertices, body);\n          }\n\n          // update properties\n          body.axes = Axes.fromVertices(body.vertices);\n          body.area = Vertices.area(body.vertices);\n          Body.setMass(body, body.density * body.area);\n\n          // orient vertices around the centre of mass at origin (0, 0)\n          var centre = Vertices.centre(body.vertices);\n          Vertices.translate(body.vertices, centre, -1);\n\n          // update inertia while vertices are at origin (0, 0)\n          Body.setInertia(body, Body._inertiaScale * Vertices.inertia(body.vertices, body.mass));\n\n          // update geometry\n          Vertices.translate(body.vertices, body.position);\n          Bounds.update(body.bounds, body.vertices, body.velocity);\n        };\n\n        /**\n         * Sets the parts of the `body` and updates mass, inertia and centroid.\n         * Each part will have its parent set to `body`.\n         * By default the convex hull will be automatically computed and set on `body`, unless `autoHull` is set to `false.`\n         * Note that this method will ensure that the first part in `body.parts` will always be the `body`.\n         * @method setParts\n         * @param {body} body\n         * @param {body[]} parts\n         * @param {bool} [autoHull=true]\n         */\n        Body.setParts = function (body, parts, autoHull) {\n          var i;\n\n          // add all the parts, ensuring that the first part is always the parent body\n          parts = parts.slice(0);\n          body.parts.length = 0;\n          body.parts.push(body);\n          body.parent = body;\n          for (i = 0; i < parts.length; i++) {\n            var part = parts[i];\n            if (part !== body) {\n              part.parent = body;\n              body.parts.push(part);\n            }\n          }\n          if (body.parts.length === 1) return;\n          autoHull = typeof autoHull !== 'undefined' ? autoHull : true;\n\n          // find the convex hull of all parts to set on the parent body\n          if (autoHull) {\n            var vertices = [];\n            for (i = 0; i < parts.length; i++) {\n              vertices = vertices.concat(parts[i].vertices);\n            }\n            Vertices.clockwiseSort(vertices);\n            var hull = Vertices.hull(vertices),\n              hullCentre = Vertices.centre(hull);\n            Body.setVertices(body, hull);\n            Vertices.translate(body.vertices, hullCentre);\n          }\n\n          // sum the properties of all compound parts of the parent body\n          var total = Body._totalProperties(body);\n          body.area = total.area;\n          body.parent = body;\n          body.position.x = total.centre.x;\n          body.position.y = total.centre.y;\n          body.positionPrev.x = total.centre.x;\n          body.positionPrev.y = total.centre.y;\n          Body.setMass(body, total.mass);\n          Body.setInertia(body, total.inertia);\n          Body.setPosition(body, total.centre);\n        };\n\n        /**\n         * Set the centre of mass of the body. \n         * The `centre` is a vector in world-space unless `relative` is set, in which case it is a translation.\n         * The centre of mass is the point the body rotates about and can be used to simulate non-uniform density.\n         * This is equal to moving `body.position` but not the `body.vertices`.\n         * Invalid if the `centre` falls outside the body's convex hull.\n         * @method setCentre\n         * @param {body} body\n         * @param {vector} centre\n         * @param {bool} relative\n         */\n        Body.setCentre = function (body, centre, relative) {\n          if (!relative) {\n            body.positionPrev.x = centre.x - (body.position.x - body.positionPrev.x);\n            body.positionPrev.y = centre.y - (body.position.y - body.positionPrev.y);\n            body.position.x = centre.x;\n            body.position.y = centre.y;\n          } else {\n            body.positionPrev.x += centre.x;\n            body.positionPrev.y += centre.y;\n            body.position.x += centre.x;\n            body.position.y += centre.y;\n          }\n        };\n\n        /**\n         * Sets the position of the body. By default velocity is unchanged.\n         * If `updateVelocity` is `true` then velocity is inferred from the change in position.\n         * @method setPosition\n         * @param {body} body\n         * @param {vector} position\n         * @param {boolean} [updateVelocity=false]\n         */\n        Body.setPosition = function (body, position, updateVelocity) {\n          var delta = Vector.sub(position, body.position);\n          if (updateVelocity) {\n            body.positionPrev.x = body.position.x;\n            body.positionPrev.y = body.position.y;\n            body.velocity.x = delta.x;\n            body.velocity.y = delta.y;\n            body.speed = Vector.magnitude(delta);\n          } else {\n            body.positionPrev.x += delta.x;\n            body.positionPrev.y += delta.y;\n          }\n          for (var i = 0; i < body.parts.length; i++) {\n            var part = body.parts[i];\n            part.position.x += delta.x;\n            part.position.y += delta.y;\n            Vertices.translate(part.vertices, delta);\n            Bounds.update(part.bounds, part.vertices, body.velocity);\n          }\n        };\n\n        /**\n         * Sets the angle of the body. By default angular velocity is unchanged.\n         * If `updateVelocity` is `true` then angular velocity is inferred from the change in angle.\n         * @method setAngle\n         * @param {body} body\n         * @param {number} angle\n         * @param {boolean} [updateVelocity=false]\n         */\n        Body.setAngle = function (body, angle, updateVelocity) {\n          var delta = angle - body.angle;\n          if (updateVelocity) {\n            body.anglePrev = body.angle;\n            body.angularVelocity = delta;\n            body.angularSpeed = Math.abs(delta);\n          } else {\n            body.anglePrev += delta;\n          }\n          for (var i = 0; i < body.parts.length; i++) {\n            var part = body.parts[i];\n            part.angle += delta;\n            Vertices.rotate(part.vertices, delta, body.position);\n            Axes.rotate(part.axes, delta);\n            Bounds.update(part.bounds, part.vertices, body.velocity);\n            if (i > 0) {\n              Vector.rotateAbout(part.position, delta, body.position, part.position);\n            }\n          }\n        };\n\n        /**\n         * Sets the current linear velocity of the body.  \n         * Affects body speed.\n         * @method setVelocity\n         * @param {body} body\n         * @param {vector} velocity\n         */\n        Body.setVelocity = function (body, velocity) {\n          var timeScale = body.deltaTime / Body._baseDelta;\n          body.positionPrev.x = body.position.x - velocity.x * timeScale;\n          body.positionPrev.y = body.position.y - velocity.y * timeScale;\n          body.velocity.x = (body.position.x - body.positionPrev.x) / timeScale;\n          body.velocity.y = (body.position.y - body.positionPrev.y) / timeScale;\n          body.speed = Vector.magnitude(body.velocity);\n        };\n\n        /**\n         * Gets the current linear velocity of the body.\n         * @method getVelocity\n         * @param {body} body\n         * @return {vector} velocity\n         */\n        Body.getVelocity = function (body) {\n          var timeScale = Body._baseDelta / body.deltaTime;\n          return {\n            x: (body.position.x - body.positionPrev.x) * timeScale,\n            y: (body.position.y - body.positionPrev.y) * timeScale\n          };\n        };\n\n        /**\n         * Gets the current linear speed of the body.  \n         * Equivalent to the magnitude of its velocity.\n         * @method getSpeed\n         * @param {body} body\n         * @return {number} speed\n         */\n        Body.getSpeed = function (body) {\n          return Vector.magnitude(Body.getVelocity(body));\n        };\n\n        /**\n         * Sets the current linear speed of the body.  \n         * Direction is maintained. Affects body velocity.\n         * @method setSpeed\n         * @param {body} body\n         * @param {number} speed\n         */\n        Body.setSpeed = function (body, speed) {\n          Body.setVelocity(body, Vector.mult(Vector.normalise(Body.getVelocity(body)), speed));\n        };\n\n        /**\n         * Sets the current rotational velocity of the body.  \n         * Affects body angular speed.\n         * @method setAngularVelocity\n         * @param {body} body\n         * @param {number} velocity\n         */\n        Body.setAngularVelocity = function (body, velocity) {\n          var timeScale = body.deltaTime / Body._baseDelta;\n          body.anglePrev = body.angle - velocity * timeScale;\n          body.angularVelocity = (body.angle - body.anglePrev) / timeScale;\n          body.angularSpeed = Math.abs(body.angularVelocity);\n        };\n\n        /**\n         * Gets the current rotational velocity of the body.\n         * @method getAngularVelocity\n         * @param {body} body\n         * @return {number} angular velocity\n         */\n        Body.getAngularVelocity = function (body) {\n          return (body.angle - body.anglePrev) * Body._baseDelta / body.deltaTime;\n        };\n\n        /**\n         * Gets the current rotational speed of the body.  \n         * Equivalent to the magnitude of its angular velocity.\n         * @method getAngularSpeed\n         * @param {body} body\n         * @return {number} angular speed\n         */\n        Body.getAngularSpeed = function (body) {\n          return Math.abs(Body.getAngularVelocity(body));\n        };\n\n        /**\n         * Sets the current rotational speed of the body.  \n         * Direction is maintained. Affects body angular velocity.\n         * @method setAngularSpeed\n         * @param {body} body\n         * @param {number} speed\n         */\n        Body.setAngularSpeed = function (body, speed) {\n          Body.setAngularVelocity(body, Common.sign(Body.getAngularVelocity(body)) * speed);\n        };\n\n        /**\n         * Moves a body by a given vector relative to its current position. By default velocity is unchanged.\n         * If `updateVelocity` is `true` then velocity is inferred from the change in position.\n         * @method translate\n         * @param {body} body\n         * @param {vector} translation\n         * @param {boolean} [updateVelocity=false]\n         */\n        Body.translate = function (body, translation, updateVelocity) {\n          Body.setPosition(body, Vector.add(body.position, translation), updateVelocity);\n        };\n\n        /**\n         * Rotates a body by a given angle relative to its current angle. By default angular velocity is unchanged.\n         * If `updateVelocity` is `true` then angular velocity is inferred from the change in angle.\n         * @method rotate\n         * @param {body} body\n         * @param {number} rotation\n         * @param {vector} [point]\n         * @param {boolean} [updateVelocity=false]\n         */\n        Body.rotate = function (body, rotation, point, updateVelocity) {\n          if (!point) {\n            Body.setAngle(body, body.angle + rotation, updateVelocity);\n          } else {\n            var cos = Math.cos(rotation),\n              sin = Math.sin(rotation),\n              dx = body.position.x - point.x,\n              dy = body.position.y - point.y;\n            Body.setPosition(body, {\n              x: point.x + (dx * cos - dy * sin),\n              y: point.y + (dx * sin + dy * cos)\n            }, updateVelocity);\n            Body.setAngle(body, body.angle + rotation, updateVelocity);\n          }\n        };\n\n        /**\n         * Scales the body, including updating physical properties (mass, area, axes, inertia), from a world-space point (default is body centre).\n         * @method scale\n         * @param {body} body\n         * @param {number} scaleX\n         * @param {number} scaleY\n         * @param {vector} [point]\n         */\n        Body.scale = function (body, scaleX, scaleY, point) {\n          var totalArea = 0,\n            totalInertia = 0;\n          point = point || body.position;\n          for (var i = 0; i < body.parts.length; i++) {\n            var part = body.parts[i];\n\n            // scale vertices\n            Vertices.scale(part.vertices, scaleX, scaleY, point);\n\n            // update properties\n            part.axes = Axes.fromVertices(part.vertices);\n            part.area = Vertices.area(part.vertices);\n            Body.setMass(part, body.density * part.area);\n\n            // update inertia (requires vertices to be at origin)\n            Vertices.translate(part.vertices, {\n              x: -part.position.x,\n              y: -part.position.y\n            });\n            Body.setInertia(part, Body._inertiaScale * Vertices.inertia(part.vertices, part.mass));\n            Vertices.translate(part.vertices, {\n              x: part.position.x,\n              y: part.position.y\n            });\n            if (i > 0) {\n              totalArea += part.area;\n              totalInertia += part.inertia;\n            }\n\n            // scale position\n            part.position.x = point.x + (part.position.x - point.x) * scaleX;\n            part.position.y = point.y + (part.position.y - point.y) * scaleY;\n\n            // update bounds\n            Bounds.update(part.bounds, part.vertices, body.velocity);\n          }\n\n          // handle parent body\n          if (body.parts.length > 1) {\n            body.area = totalArea;\n            if (!body.isStatic) {\n              Body.setMass(body, body.density * totalArea);\n              Body.setInertia(body, totalInertia);\n            }\n          }\n\n          // handle circles\n          if (body.circleRadius) {\n            if (scaleX === scaleY) {\n              body.circleRadius *= scaleX;\n            } else {\n              // body is no longer a circle\n              body.circleRadius = null;\n            }\n          }\n        };\n\n        /**\n         * Performs an update by integrating the equations of motion on the `body`.\n         * This is applied every update by `Matter.Engine` automatically.\n         * @method update\n         * @param {body} body\n         * @param {number} [deltaTime=16.666]\n         */\n        Body.update = function (body, deltaTime) {\n          deltaTime = (typeof deltaTime !== 'undefined' ? deltaTime : 1000 / 60) * body.timeScale;\n          var deltaTimeSquared = deltaTime * deltaTime,\n            correction = Body._timeCorrection ? deltaTime / (body.deltaTime || deltaTime) : 1;\n\n          // from the previous step\n          var frictionAir = 1 - body.frictionAir * (deltaTime / Common._baseDelta),\n            velocityPrevX = (body.position.x - body.positionPrev.x) * correction,\n            velocityPrevY = (body.position.y - body.positionPrev.y) * correction;\n\n          // update velocity with Verlet integration\n          body.velocity.x = velocityPrevX * frictionAir + body.force.x / body.mass * deltaTimeSquared;\n          body.velocity.y = velocityPrevY * frictionAir + body.force.y / body.mass * deltaTimeSquared;\n          body.positionPrev.x = body.position.x;\n          body.positionPrev.y = body.position.y;\n          body.position.x += body.velocity.x;\n          body.position.y += body.velocity.y;\n          body.deltaTime = deltaTime;\n\n          // update angular velocity with Verlet integration\n          body.angularVelocity = (body.angle - body.anglePrev) * frictionAir * correction + body.torque / body.inertia * deltaTimeSquared;\n          body.anglePrev = body.angle;\n          body.angle += body.angularVelocity;\n\n          // transform the body geometry\n          for (var i = 0; i < body.parts.length; i++) {\n            var part = body.parts[i];\n            Vertices.translate(part.vertices, body.velocity);\n            if (i > 0) {\n              part.position.x += body.velocity.x;\n              part.position.y += body.velocity.y;\n            }\n            if (body.angularVelocity !== 0) {\n              Vertices.rotate(part.vertices, body.angularVelocity, body.position);\n              Axes.rotate(part.axes, body.angularVelocity);\n              if (i > 0) {\n                Vector.rotateAbout(part.position, body.angularVelocity, body.position, part.position);\n              }\n            }\n            Bounds.update(part.bounds, part.vertices, body.velocity);\n          }\n        };\n\n        /**\n         * Updates properties `body.velocity`, `body.speed`, `body.angularVelocity` and `body.angularSpeed` which are normalised in relation to `Body._baseDelta`.\n         * @method updateVelocities\n         * @param {body} body\n         */\n        Body.updateVelocities = function (body) {\n          var timeScale = Body._baseDelta / body.deltaTime,\n            bodyVelocity = body.velocity;\n          bodyVelocity.x = (body.position.x - body.positionPrev.x) * timeScale;\n          bodyVelocity.y = (body.position.y - body.positionPrev.y) * timeScale;\n          body.speed = Math.sqrt(bodyVelocity.x * bodyVelocity.x + bodyVelocity.y * bodyVelocity.y);\n          body.angularVelocity = (body.angle - body.anglePrev) * timeScale;\n          body.angularSpeed = Math.abs(body.angularVelocity);\n        };\n\n        /**\n         * Applies the `force` to the `body` from the force origin `position` in world-space, over a single timestep, including applying any resulting angular torque.\n         * \n         * Forces are useful for effects like gravity, wind or rocket thrust, but can be difficult in practice when precise control is needed. In these cases see `Body.setVelocity` and `Body.setPosition` as an alternative.\n         * \n         * The force from this function is only applied once for the duration of a single timestep, in other words the duration depends directly on the current engine update `delta` and the rate of calls to this function.\n         * \n         * Therefore to account for time, you should apply the force constantly over as many engine updates as equivalent to the intended duration.\n         * \n         * If all or part of the force duration is some fraction of a timestep, first multiply the force by `duration / timestep`.\n         * \n         * The force origin `position` in world-space must also be specified. Passing `body.position` will result in zero angular effect as the force origin would be at the centre of mass.\n         * \n         * The `body` will take time to accelerate under a force, the resulting effect depends on duration of the force, the body mass and other forces on the body including friction combined.\n         * @method applyForce\n         * @param {body} body\n         * @param {vector} position The force origin in world-space. Pass `body.position` to avoid angular torque.\n         * @param {vector} force\n         */\n        Body.applyForce = function (body, position, force) {\n          var offset = {\n            x: position.x - body.position.x,\n            y: position.y - body.position.y\n          };\n          body.force.x += force.x;\n          body.force.y += force.y;\n          body.torque += offset.x * force.y - offset.y * force.x;\n        };\n\n        /**\n         * Returns the sums of the properties of all compound parts of the parent body.\n         * @method _totalProperties\n         * @private\n         * @param {body} body\n         * @return {}\n         */\n        Body._totalProperties = function (body) {\n          // from equations at:\n          // https://ecourses.ou.edu/cgi-bin/ebook.cgi?doc=&topic=st&chap_sec=07.2&page=theory\n          // http://output.to/sideway/default.asp?qno=121100087\n\n          var properties = {\n            mass: 0,\n            area: 0,\n            inertia: 0,\n            centre: {\n              x: 0,\n              y: 0\n            }\n          };\n\n          // sum the properties of all compound parts of the parent body\n          for (var i = body.parts.length === 1 ? 0 : 1; i < body.parts.length; i++) {\n            var part = body.parts[i],\n              mass = part.mass !== Infinity ? part.mass : 1;\n            properties.mass += mass;\n            properties.area += part.area;\n            properties.inertia += part.inertia;\n            properties.centre = Vector.add(properties.centre, Vector.mult(part.position, mass));\n          }\n          properties.centre = Vector.div(properties.centre, properties.mass);\n          return properties;\n        };\n\n        /*\n        *\n        *  Events Documentation\n        *\n        */\n\n        /**\n        * Fired when a body starts sleeping (where `this` is the body).\n        *\n        * @event sleepStart\n        * @this {body} The body that has started sleeping\n        * @param {} event An event object\n        * @param {} event.source The source object of the event\n        * @param {} event.name The name of the event\n        */\n\n        /**\n        * Fired when a body ends sleeping (where `this` is the body).\n        *\n        * @event sleepEnd\n        * @this {body} The body that has ended sleeping\n        * @param {} event An event object\n        * @param {} event.source The source object of the event\n        * @param {} event.name The name of the event\n        */\n\n        /*\n        *\n        *  Properties Documentation\n        *\n        */\n\n        /**\n         * An integer `Number` uniquely identifying number generated in `Body.create` by `Common.nextId`.\n         *\n         * @property id\n         * @type number\n         */\n\n        /**\n         * _Read only_. Set by `Body.create`.\n         * \n         * A `String` denoting the type of object.\n         *\n         * @readOnly\n         * @property type\n         * @type string\n         * @default \"body\"\n         */\n\n        /**\n         * An arbitrary `String` name to help the user identify and manage bodies.\n         *\n         * @property label\n         * @type string\n         * @default \"Body\"\n         */\n\n        /**\n         * _Read only_. Use `Body.setParts` to set. \n         * \n         * An array of bodies that make up this body. \n         * The first body in the array must always be a self reference to the current body instance.\n         * All bodies in the `parts` array together form a single rigid compound body.\n         * Parts are allowed to overlap, have gaps or holes or even form concave bodies.\n         * Parts themselves should never be added to a `World`, only the parent body should be.\n         * Use `Body.setParts` when setting parts to ensure correct updates of all properties.\n         *\n         * @readOnly\n         * @property parts\n         * @type body[]\n         */\n\n        /**\n         * An object reserved for storing plugin-specific properties.\n         *\n         * @property plugin\n         * @type {}\n         */\n\n        /**\n         * _Read only_. Updated by `Body.setParts`.\n         * \n         * A reference to the body that this is a part of. See `body.parts`.\n         * This is a self reference if the body is not a part of another body.\n         *\n         * @readOnly\n         * @property parent\n         * @type body\n         */\n\n        /**\n         * A `Number` specifying the angle of the body, in radians.\n         *\n         * @property angle\n         * @type number\n         * @default 0\n         */\n\n        /**\n         * _Read only_. Use `Body.setVertices` or `Body.setParts` to set. See also `Bodies.fromVertices`.\n         * \n         * An array of `Vector` objects that specify the convex hull of the rigid body.\n         * These should be provided about the origin `(0, 0)`. E.g.\n         *\n         * `[{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]`\n         * \n         * Vertices must always be convex, in clockwise order and must not contain any duplicate points.\n         * \n         * Concave vertices should be decomposed into convex `parts`, see `Bodies.fromVertices` and `Body.setParts`.\n         *\n         * When set the vertices are translated such that `body.position` is at the centre of mass.\n         * Many other body properties are automatically calculated from these vertices when set including `density`, `area` and `inertia`.\n         * \n         * The module `Matter.Vertices` contains useful methods for working with vertices.\n         *\n         * @readOnly\n         * @property vertices\n         * @type vector[]\n         */\n\n        /**\n         * _Read only_. Use `Body.setPosition` to set. \n         * \n         * A `Vector` that specifies the current world-space position of the body.\n         * \n         * @readOnly\n         * @property position\n         * @type vector\n         * @default { x: 0, y: 0 }\n         */\n\n        /**\n         * A `Vector` that accumulates the total force applied to the body for a single update.\n         * Force is zeroed after every `Engine.update`, so constant forces should be applied for every update they are needed. See also `Body.applyForce`.\n         * \n         * @property force\n         * @type vector\n         * @default { x: 0, y: 0 }\n         */\n\n        /**\n         * A `Number` that accumulates the total torque (turning force) applied to the body for a single update. See also `Body.applyForce`.\n         * Torque is zeroed after every `Engine.update`, so constant torques should be applied for every update they are needed.\n         *\n         * Torques result in angular acceleration on every update, which depends on body inertia and the engine update delta.\n         * \n         * @property torque\n         * @type number\n         * @default 0\n         */\n\n        /**\n         * _Read only_. Use `Body.setSpeed` to set. \n         * \n         * See `Body.getSpeed` for details.\n         * \n         * Equivalent to the magnitude of `body.velocity` (always positive).\n         * \n         * @readOnly\n         * @property speed\n         * @type number\n         * @default 0\n         */\n\n        /**\n         * _Read only_. Use `Body.setVelocity` to set. \n         * \n         * See `Body.getVelocity` for details.\n         * \n         * Equivalent to the magnitude of `body.angularVelocity` (always positive).\n         * \n         * @readOnly\n         * @property velocity\n         * @type vector\n         * @default { x: 0, y: 0 }\n         */\n\n        /**\n         * _Read only_. Use `Body.setAngularSpeed` to set. \n         * \n         * See `Body.getAngularSpeed` for details.\n         * \n         * \n         * @readOnly\n         * @property angularSpeed\n         * @type number\n         * @default 0\n         */\n\n        /**\n         * _Read only_. Use `Body.setAngularVelocity` to set. \n         * \n         * See `Body.getAngularVelocity` for details.\n         * \n         *\n         * @readOnly\n         * @property angularVelocity\n         * @type number\n         * @default 0\n         */\n\n        /**\n         * _Read only_. Use `Body.setStatic` to set. \n         * \n         * A flag that indicates whether a body is considered static. A static body can never change position or angle and is completely fixed.\n         *\n         * @readOnly\n         * @property isStatic\n         * @type boolean\n         * @default false\n         */\n\n        /**\n         * A flag that indicates whether a body is a sensor. Sensor triggers collision events, but doesn't react with colliding body physically.\n         *\n         * @property isSensor\n         * @type boolean\n         * @default false\n         */\n\n        /**\n         * _Read only_. Use `Sleeping.set` to set. \n         * \n         * A flag that indicates whether the body is considered sleeping. A sleeping body acts similar to a static body, except it is only temporary and can be awoken.\n         *\n         * @readOnly\n         * @property isSleeping\n         * @type boolean\n         * @default false\n         */\n\n        /**\n         * _Read only_. Calculated during engine update only when sleeping is enabled.\n         * \n         * A `Number` that loosely measures the amount of movement a body currently has.\n         *\n         * Derived from `body.speed^2 + body.angularSpeed^2`. See `Sleeping.update`.\n         * \n         * @readOnly\n         * @property motion\n         * @type number\n         * @default 0\n         */\n\n        /**\n         * A `Number` that defines the length of time during which this body must have near-zero velocity before it is set as sleeping by the `Matter.Sleeping` module (if sleeping is enabled by the engine).\n         * \n         * @property sleepThreshold\n         * @type number\n         * @default 60\n         */\n\n        /**\n         * _Read only_. Use `Body.setDensity` to set. \n         * \n         * A `Number` that defines the density of the body (mass per unit area).\n         * \n         * Mass will also be updated when set.\n         *\n         * @readOnly\n         * @property density\n         * @type number\n         * @default 0.001\n         */\n\n        /**\n         * _Read only_. Use `Body.setMass` to set. \n         * \n         * A `Number` that defines the mass of the body.\n         * \n         * Density will also be updated when set.\n         * \n         * @readOnly\n         * @property mass\n         * @type number\n         */\n\n        /**\n         * _Read only_. Use `Body.setMass` to set. \n         * \n         * A `Number` that defines the inverse mass of the body (`1 / mass`).\n         *\n         * @readOnly\n         * @property inverseMass\n         * @type number\n         */\n\n        /**\n         * _Read only_. Automatically calculated when vertices, mass or density are set or set through `Body.setInertia`.\n         * \n         * A `Number` that defines the moment of inertia of the body. This is the second moment of area in two dimensions.\n         * \n         * Can be manually set to `Infinity` to prevent rotation of the body. See `Body.setInertia`.\n         * \n         * @readOnly\n         * @property inertia\n         * @type number\n         */\n\n        /**\n         * _Read only_. Automatically calculated when vertices, mass or density are set or calculated by `Body.setInertia`.\n         * \n         * A `Number` that defines the inverse moment of inertia of the body (`1 / inertia`).\n         * \n         * @readOnly\n         * @property inverseInertia\n         * @type number\n         */\n\n        /**\n         * A `Number` that defines the restitution (elasticity) of the body. The value is always positive and is in the range `(0, 1)`.\n         * A value of `0` means collisions may be perfectly inelastic and no bouncing may occur. \n         * A value of `0.8` means the body may bounce back with approximately 80% of its kinetic energy.\n         * Note that collision response is based on _pairs_ of bodies, and that `restitution` values are _combined_ with the following formula:\n         *\n         * `Math.max(bodyA.restitution, bodyB.restitution)`\n         *\n         * @property restitution\n         * @type number\n         * @default 0\n         */\n\n        /**\n         * A `Number` that defines the friction of the body. The value is always positive and is in the range `(0, 1)`.\n         * A value of `0` means that the body may slide indefinitely.\n         * A value of `1` means the body may come to a stop almost instantly after a force is applied.\n         *\n         * The effects of the value may be non-linear. \n         * High values may be unstable depending on the body.\n         * The engine uses a Coulomb friction model including static and kinetic friction.\n         * Note that collision response is based on _pairs_ of bodies, and that `friction` values are _combined_ with the following formula:\n         *\n         * `Math.min(bodyA.friction, bodyB.friction)`\n         *\n         * @property friction\n         * @type number\n         * @default 0.1\n         */\n\n        /**\n         * A `Number` that defines the static friction of the body (in the Coulomb friction model). \n         * A value of `0` means the body will never 'stick' when it is nearly stationary and only dynamic `friction` is used.\n         * The higher the value (e.g. `10`), the more force it will take to initially get the body moving when nearly stationary.\n         * This value is multiplied with the `friction` property to make it easier to change `friction` and maintain an appropriate amount of static friction.\n         *\n         * @property frictionStatic\n         * @type number\n         * @default 0.5\n         */\n\n        /**\n         * A `Number` that defines the air friction of the body (air resistance). \n         * A value of `0` means the body will never slow as it moves through space.\n         * The higher the value, the faster a body slows when moving through space.\n         * The effects of the value are non-linear. \n         *\n         * @property frictionAir\n         * @type number\n         * @default 0.01\n         */\n\n        /**\n         * An `Object` that specifies the collision filtering properties of this body.\n         *\n         * Collisions between two bodies will obey the following rules:\n         * - If the two bodies have the same non-zero value of `collisionFilter.group`,\n         *   they will always collide if the value is positive, and they will never collide\n         *   if the value is negative.\n         * - If the two bodies have different values of `collisionFilter.group` or if one\n         *   (or both) of the bodies has a value of 0, then the category/mask rules apply as follows:\n         *\n         * Each body belongs to a collision category, given by `collisionFilter.category`. This\n         * value is used as a bit field and the category should have only one bit set, meaning that\n         * the value of this property is a power of two in the range [1, 2^31]. Thus, there are 32\n         * different collision categories available.\n         *\n         * Each body also defines a collision bitmask, given by `collisionFilter.mask` which specifies\n         * the categories it collides with (the value is the bitwise AND value of all these categories).\n         *\n         * Using the category/mask rules, two bodies `A` and `B` collide if each includes the other's\n         * category in its mask, i.e. `(categoryA & maskB) !== 0` and `(categoryB & maskA) !== 0`\n         * are both true.\n         *\n         * @property collisionFilter\n         * @type object\n         */\n\n        /**\n         * An Integer `Number`, that specifies the collision group this body belongs to.\n         * See `body.collisionFilter` for more information.\n         *\n         * @property collisionFilter.group\n         * @type object\n         * @default 0\n         */\n\n        /**\n         * A bit field that specifies the collision category this body belongs to.\n         * The category value should have only one bit set, for example `0x0001`.\n         * This means there are up to 32 unique collision categories available.\n         * See `body.collisionFilter` for more information.\n         *\n         * @property collisionFilter.category\n         * @type object\n         * @default 1\n         */\n\n        /**\n         * A bit mask that specifies the collision categories this body may collide with.\n         * See `body.collisionFilter` for more information.\n         *\n         * @property collisionFilter.mask\n         * @type object\n         * @default -1\n         */\n\n        /**\n         * A `Number` that specifies a thin boundary around the body where it is allowed to slightly sink into other bodies.\n         * \n         * This is required for proper collision response, including friction and restitution effects.\n         * \n         * The default should generally suffice in most cases. You may need to decrease this value for very small bodies that are nearing the default value in scale.\n         *\n         * @property slop\n         * @type number\n         * @default 0.05\n         */\n\n        /**\n         * A `Number` that specifies per-body time scaling.\n         *\n         * @property timeScale\n         * @type number\n         * @default 1\n         */\n\n        /**\n         * _Read only_. Updated during engine update.\n         * \n         * A `Number` that records the last delta time value used to update this body.\n         * Used to calculate speed and velocity.\n         *\n         * @readOnly\n         * @property deltaTime\n         * @type number\n         * @default 1000 / 60\n         */\n\n        /**\n         * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.\n         *\n         * @property render\n         * @type object\n         */\n\n        /**\n         * A flag that indicates if the body should be rendered.\n         *\n         * @property render.visible\n         * @type boolean\n         * @default true\n         */\n\n        /**\n         * Sets the opacity to use when rendering.\n         *\n         * @property render.opacity\n         * @type number\n         * @default 1\n        */\n\n        /**\n         * An `Object` that defines the sprite properties to use when rendering, if any.\n         *\n         * @property render.sprite\n         * @type object\n         */\n\n        /**\n         * An `String` that defines the path to the image to use as the sprite texture, if any.\n         *\n         * @property render.sprite.texture\n         * @type string\n         */\n\n        /**\n         * A `Number` that defines the scaling in the x-axis for the sprite, if any.\n         *\n         * @property render.sprite.xScale\n         * @type number\n         * @default 1\n         */\n\n        /**\n         * A `Number` that defines the scaling in the y-axis for the sprite, if any.\n         *\n         * @property render.sprite.yScale\n         * @type number\n         * @default 1\n         */\n\n        /**\n          * A `Number` that defines the offset in the x-axis for the sprite (normalised by texture width).\n          *\n          * @property render.sprite.xOffset\n          * @type number\n          * @default 0\n          */\n\n        /**\n          * A `Number` that defines the offset in the y-axis for the sprite (normalised by texture height).\n          *\n          * @property render.sprite.yOffset\n          * @type number\n          * @default 0\n          */\n\n        /**\n         * A `Number` that defines the line width to use when rendering the body outline (if a sprite is not defined).\n         * A value of `0` means no outline will be rendered.\n         *\n         * @property render.lineWidth\n         * @type number\n         * @default 0\n         */\n\n        /**\n         * A `String` that defines the fill style to use when rendering the body (if a sprite is not defined).\n         * It is the same as when using a canvas, so it accepts CSS style property values.\n         *\n         * @property render.fillStyle\n         * @type string\n         * @default a random colour\n         */\n\n        /**\n         * A `String` that defines the stroke style to use when rendering the body outline (if a sprite is not defined).\n         * It is the same as when using a canvas, so it accepts CSS style property values.\n         *\n         * @property render.strokeStyle\n         * @type string\n         * @default a random colour\n         */\n\n        /**\n         * _Read only_. Calculated automatically when vertices are set.\n         * \n         * An array of unique axis vectors (edge normals) used for collision detection.\n         * These are automatically calculated when vertices are set.\n         * They are constantly updated by `Body.update` during the simulation.\n         *\n         * @readOnly\n         * @property axes\n         * @type vector[]\n         */\n\n        /**\n         * _Read only_. Calculated automatically when vertices are set.\n         * \n         * A `Number` that measures the area of the body's convex hull.\n         * \n         * @readOnly\n         * @property area\n         * @type string\n         * @default \n         */\n\n        /**\n         * A `Bounds` object that defines the AABB region for the body.\n         * It is automatically calculated when vertices are set and constantly updated by `Body.update` during simulation.\n         * \n         * @property bounds\n         * @type bounds\n         */\n      })();\n\n      /***/\n    }, /* 5 */\n    /***/function (module, exports, __nested_webpack_require_106958__) {\n      /**\n      * The `Matter.Events` module contains methods to fire and listen to events on other objects.\n      *\n      * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n      *\n      * @class Events\n      */\n\n      var Events = {};\n      module.exports = Events;\n      var Common = __nested_webpack_require_106958__(0);\n      (function () {\n        /**\n         * Subscribes a callback function to the given object's `eventName`.\n         * @method on\n         * @param {} object\n         * @param {string} eventNames\n         * @param {function} callback\n         */\n        Events.on = function (object, eventNames, callback) {\n          var names = eventNames.split(' '),\n            name;\n          for (var i = 0; i < names.length; i++) {\n            name = names[i];\n            object.events = object.events || {};\n            object.events[name] = object.events[name] || [];\n            object.events[name].push(callback);\n          }\n          return callback;\n        };\n\n        /**\n         * Removes the given event callback. If no callback, clears all callbacks in `eventNames`. If no `eventNames`, clears all events.\n         * @method off\n         * @param {} object\n         * @param {string} eventNames\n         * @param {function} callback\n         */\n        Events.off = function (object, eventNames, callback) {\n          if (!eventNames) {\n            object.events = {};\n            return;\n          }\n\n          // handle Events.off(object, callback)\n          if (typeof eventNames === 'function') {\n            callback = eventNames;\n            eventNames = Common.keys(object.events).join(' ');\n          }\n          var names = eventNames.split(' ');\n          for (var i = 0; i < names.length; i++) {\n            var callbacks = object.events[names[i]],\n              newCallbacks = [];\n            if (callback && callbacks) {\n              for (var j = 0; j < callbacks.length; j++) {\n                if (callbacks[j] !== callback) newCallbacks.push(callbacks[j]);\n              }\n            }\n            object.events[names[i]] = newCallbacks;\n          }\n        };\n\n        /**\n         * Fires all the callbacks subscribed to the given object's `eventName`, in the order they subscribed, if any.\n         * @method trigger\n         * @param {} object\n         * @param {string} eventNames\n         * @param {} event\n         */\n        Events.trigger = function (object, eventNames, event) {\n          var names, name, callbacks, eventClone;\n          var events = object.events;\n          if (events && Common.keys(events).length > 0) {\n            if (!event) event = {};\n            names = eventNames.split(' ');\n            for (var i = 0; i < names.length; i++) {\n              name = names[i];\n              callbacks = events[name];\n              if (callbacks) {\n                eventClone = Common.clone(event, false);\n                eventClone.name = name;\n                eventClone.source = object;\n                for (var j = 0; j < callbacks.length; j++) {\n                  callbacks[j].apply(object, [eventClone]);\n                }\n              }\n            }\n          }\n        };\n      })();\n\n      /***/\n    }, /* 6 */\n    /***/function (module, exports, __nested_webpack_require_110237__) {\n      /**\n      * A composite is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite` objects.\n      *\n      * They are a container that can represent complex objects made of multiple parts, even if they are not physically connected.\n      * A composite could contain anything from a single body all the way up to a whole world.\n      * \n      * When making any changes to composites, use the included functions rather than changing their properties directly.\n      *\n      * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n      *\n      * @class Composite\n      */\n\n      var Composite = {};\n      module.exports = Composite;\n      var Events = __nested_webpack_require_110237__(5);\n      var Common = __nested_webpack_require_110237__(0);\n      var Bounds = __nested_webpack_require_110237__(1);\n      var Body = __nested_webpack_require_110237__(4);\n      (function () {\n        /**\n         * Creates a new composite. The options parameter is an object that specifies any properties you wish to override the defaults.\n         * See the properites section below for detailed information on what you can pass via the `options` object.\n         * @method create\n         * @param {} [options]\n         * @return {composite} A new composite\n         */\n        Composite.create = function (options) {\n          return Common.extend({\n            id: Common.nextId(),\n            type: 'composite',\n            parent: null,\n            isModified: false,\n            bodies: [],\n            constraints: [],\n            composites: [],\n            label: 'Composite',\n            plugin: {},\n            cache: {\n              allBodies: null,\n              allConstraints: null,\n              allComposites: null\n            }\n          }, options);\n        };\n\n        /**\n         * Sets the composite's `isModified` flag. \n         * If `updateParents` is true, all parents will be set (default: false).\n         * If `updateChildren` is true, all children will be set (default: false).\n         * @private\n         * @method setModified\n         * @param {composite} composite\n         * @param {boolean} isModified\n         * @param {boolean} [updateParents=false]\n         * @param {boolean} [updateChildren=false]\n         */\n        Composite.setModified = function (composite, isModified, updateParents, updateChildren) {\n          composite.isModified = isModified;\n          if (isModified && composite.cache) {\n            composite.cache.allBodies = null;\n            composite.cache.allConstraints = null;\n            composite.cache.allComposites = null;\n          }\n          if (updateParents && composite.parent) {\n            Composite.setModified(composite.parent, isModified, updateParents, updateChildren);\n          }\n          if (updateChildren) {\n            for (var i = 0; i < composite.composites.length; i++) {\n              var childComposite = composite.composites[i];\n              Composite.setModified(childComposite, isModified, updateParents, updateChildren);\n            }\n          }\n        };\n\n        /**\n         * Generic single or multi-add function. Adds a single or an array of body(s), constraint(s) or composite(s) to the given composite.\n         * Triggers `beforeAdd` and `afterAdd` events on the `composite`.\n         * @method add\n         * @param {composite} composite\n         * @param {object|array} object A single or an array of body(s), constraint(s) or composite(s)\n         * @return {composite} The original composite with the objects added\n         */\n        Composite.add = function (composite, object) {\n          var objects = [].concat(object);\n          Events.trigger(composite, 'beforeAdd', {\n            object: object\n          });\n          for (var i = 0; i < objects.length; i++) {\n            var obj = objects[i];\n            switch (obj.type) {\n              case 'body':\n                // skip adding compound parts\n                if (obj.parent !== obj) {\n                  Common.warn('Composite.add: skipped adding a compound body part (you must add its parent instead)');\n                  break;\n                }\n                Composite.addBody(composite, obj);\n                break;\n              case 'constraint':\n                Composite.addConstraint(composite, obj);\n                break;\n              case 'composite':\n                Composite.addComposite(composite, obj);\n                break;\n              case 'mouseConstraint':\n                Composite.addConstraint(composite, obj.constraint);\n                break;\n            }\n          }\n          Events.trigger(composite, 'afterAdd', {\n            object: object\n          });\n          return composite;\n        };\n\n        /**\n         * Generic remove function. Removes one or many body(s), constraint(s) or a composite(s) to the given composite.\n         * Optionally searching its children recursively.\n         * Triggers `beforeRemove` and `afterRemove` events on the `composite`.\n         * @method remove\n         * @param {composite} composite\n         * @param {object|array} object\n         * @param {boolean} [deep=false]\n         * @return {composite} The original composite with the objects removed\n         */\n        Composite.remove = function (composite, object, deep) {\n          var objects = [].concat(object);\n          Events.trigger(composite, 'beforeRemove', {\n            object: object\n          });\n          for (var i = 0; i < objects.length; i++) {\n            var obj = objects[i];\n            switch (obj.type) {\n              case 'body':\n                Composite.removeBody(composite, obj, deep);\n                break;\n              case 'constraint':\n                Composite.removeConstraint(composite, obj, deep);\n                break;\n              case 'composite':\n                Composite.removeComposite(composite, obj, deep);\n                break;\n              case 'mouseConstraint':\n                Composite.removeConstraint(composite, obj.constraint);\n                break;\n            }\n          }\n          Events.trigger(composite, 'afterRemove', {\n            object: object\n          });\n          return composite;\n        };\n\n        /**\n         * Adds a composite to the given composite.\n         * @private\n         * @method addComposite\n         * @param {composite} compositeA\n         * @param {composite} compositeB\n         * @return {composite} The original compositeA with the objects from compositeB added\n         */\n        Composite.addComposite = function (compositeA, compositeB) {\n          compositeA.composites.push(compositeB);\n          compositeB.parent = compositeA;\n          Composite.setModified(compositeA, true, true, false);\n          return compositeA;\n        };\n\n        /**\n         * Removes a composite from the given composite, and optionally searching its children recursively.\n         * @private\n         * @method removeComposite\n         * @param {composite} compositeA\n         * @param {composite} compositeB\n         * @param {boolean} [deep=false]\n         * @return {composite} The original compositeA with the composite removed\n         */\n        Composite.removeComposite = function (compositeA, compositeB, deep) {\n          var position = Common.indexOf(compositeA.composites, compositeB);\n          if (position !== -1) {\n            Composite.removeCompositeAt(compositeA, position);\n          }\n          if (deep) {\n            for (var i = 0; i < compositeA.composites.length; i++) {\n              Composite.removeComposite(compositeA.composites[i], compositeB, true);\n            }\n          }\n          return compositeA;\n        };\n\n        /**\n         * Removes a composite from the given composite.\n         * @private\n         * @method removeCompositeAt\n         * @param {composite} composite\n         * @param {number} position\n         * @return {composite} The original composite with the composite removed\n         */\n        Composite.removeCompositeAt = function (composite, position) {\n          composite.composites.splice(position, 1);\n          Composite.setModified(composite, true, true, false);\n          return composite;\n        };\n\n        /**\n         * Adds a body to the given composite.\n         * @private\n         * @method addBody\n         * @param {composite} composite\n         * @param {body} body\n         * @return {composite} The original composite with the body added\n         */\n        Composite.addBody = function (composite, body) {\n          composite.bodies.push(body);\n          Composite.setModified(composite, true, true, false);\n          return composite;\n        };\n\n        /**\n         * Removes a body from the given composite, and optionally searching its children recursively.\n         * @private\n         * @method removeBody\n         * @param {composite} composite\n         * @param {body} body\n         * @param {boolean} [deep=false]\n         * @return {composite} The original composite with the body removed\n         */\n        Composite.removeBody = function (composite, body, deep) {\n          var position = Common.indexOf(composite.bodies, body);\n          if (position !== -1) {\n            Composite.removeBodyAt(composite, position);\n          }\n          if (deep) {\n            for (var i = 0; i < composite.composites.length; i++) {\n              Composite.removeBody(composite.composites[i], body, true);\n            }\n          }\n          return composite;\n        };\n\n        /**\n         * Removes a body from the given composite.\n         * @private\n         * @method removeBodyAt\n         * @param {composite} composite\n         * @param {number} position\n         * @return {composite} The original composite with the body removed\n         */\n        Composite.removeBodyAt = function (composite, position) {\n          composite.bodies.splice(position, 1);\n          Composite.setModified(composite, true, true, false);\n          return composite;\n        };\n\n        /**\n         * Adds a constraint to the given composite.\n         * @private\n         * @method addConstraint\n         * @param {composite} composite\n         * @param {constraint} constraint\n         * @return {composite} The original composite with the constraint added\n         */\n        Composite.addConstraint = function (composite, constraint) {\n          composite.constraints.push(constraint);\n          Composite.setModified(composite, true, true, false);\n          return composite;\n        };\n\n        /**\n         * Removes a constraint from the given composite, and optionally searching its children recursively.\n         * @private\n         * @method removeConstraint\n         * @param {composite} composite\n         * @param {constraint} constraint\n         * @param {boolean} [deep=false]\n         * @return {composite} The original composite with the constraint removed\n         */\n        Composite.removeConstraint = function (composite, constraint, deep) {\n          var position = Common.indexOf(composite.constraints, constraint);\n          if (position !== -1) {\n            Composite.removeConstraintAt(composite, position);\n          }\n          if (deep) {\n            for (var i = 0; i < composite.composites.length; i++) {\n              Composite.removeConstraint(composite.composites[i], constraint, true);\n            }\n          }\n          return composite;\n        };\n\n        /**\n         * Removes a body from the given composite.\n         * @private\n         * @method removeConstraintAt\n         * @param {composite} composite\n         * @param {number} position\n         * @return {composite} The original composite with the constraint removed\n         */\n        Composite.removeConstraintAt = function (composite, position) {\n          composite.constraints.splice(position, 1);\n          Composite.setModified(composite, true, true, false);\n          return composite;\n        };\n\n        /**\n         * Removes all bodies, constraints and composites from the given composite.\n         * Optionally clearing its children recursively.\n         * @method clear\n         * @param {composite} composite\n         * @param {boolean} keepStatic\n         * @param {boolean} [deep=false]\n         */\n        Composite.clear = function (composite, keepStatic, deep) {\n          if (deep) {\n            for (var i = 0; i < composite.composites.length; i++) {\n              Composite.clear(composite.composites[i], keepStatic, true);\n            }\n          }\n          if (keepStatic) {\n            composite.bodies = composite.bodies.filter(function (body) {\n              return body.isStatic;\n            });\n          } else {\n            composite.bodies.length = 0;\n          }\n          composite.constraints.length = 0;\n          composite.composites.length = 0;\n          Composite.setModified(composite, true, true, false);\n          return composite;\n        };\n\n        /**\n         * Returns all bodies in the given composite, including all bodies in its children, recursively.\n         * @method allBodies\n         * @param {composite} composite\n         * @return {body[]} All the bodies\n         */\n        Composite.allBodies = function (composite) {\n          if (composite.cache && composite.cache.allBodies) {\n            return composite.cache.allBodies;\n          }\n          var bodies = [].concat(composite.bodies);\n          for (var i = 0; i < composite.composites.length; i++) bodies = bodies.concat(Composite.allBodies(composite.composites[i]));\n          if (composite.cache) {\n            composite.cache.allBodies = bodies;\n          }\n          return bodies;\n        };\n\n        /**\n         * Returns all constraints in the given composite, including all constraints in its children, recursively.\n         * @method allConstraints\n         * @param {composite} composite\n         * @return {constraint[]} All the constraints\n         */\n        Composite.allConstraints = function (composite) {\n          if (composite.cache && composite.cache.allConstraints) {\n            return composite.cache.allConstraints;\n          }\n          var constraints = [].concat(composite.constraints);\n          for (var i = 0; i < composite.composites.length; i++) constraints = constraints.concat(Composite.allConstraints(composite.composites[i]));\n          if (composite.cache) {\n            composite.cache.allConstraints = constraints;\n          }\n          return constraints;\n        };\n\n        /**\n         * Returns all composites in the given composite, including all composites in its children, recursively.\n         * @method allComposites\n         * @param {composite} composite\n         * @return {composite[]} All the composites\n         */\n        Composite.allComposites = function (composite) {\n          if (composite.cache && composite.cache.allComposites) {\n            return composite.cache.allComposites;\n          }\n          var composites = [].concat(composite.composites);\n          for (var i = 0; i < composite.composites.length; i++) composites = composites.concat(Composite.allComposites(composite.composites[i]));\n          if (composite.cache) {\n            composite.cache.allComposites = composites;\n          }\n          return composites;\n        };\n\n        /**\n         * Searches the composite recursively for an object matching the type and id supplied, null if not found.\n         * @method get\n         * @param {composite} composite\n         * @param {number} id\n         * @param {string} type\n         * @return {object} The requested object, if found\n         */\n        Composite.get = function (composite, id, type) {\n          var objects, object;\n          switch (type) {\n            case 'body':\n              objects = Composite.allBodies(composite);\n              break;\n            case 'constraint':\n              objects = Composite.allConstraints(composite);\n              break;\n            case 'composite':\n              objects = Composite.allComposites(composite).concat(composite);\n              break;\n          }\n          if (!objects) return null;\n          object = objects.filter(function (object) {\n            return object.id.toString() === id.toString();\n          });\n          return object.length === 0 ? null : object[0];\n        };\n\n        /**\n         * Moves the given object(s) from compositeA to compositeB (equal to a remove followed by an add).\n         * @method move\n         * @param {compositeA} compositeA\n         * @param {object[]} objects\n         * @param {compositeB} compositeB\n         * @return {composite} Returns compositeA\n         */\n        Composite.move = function (compositeA, objects, compositeB) {\n          Composite.remove(compositeA, objects);\n          Composite.add(compositeB, objects);\n          return compositeA;\n        };\n\n        /**\n         * Assigns new ids for all objects in the composite, recursively.\n         * @method rebase\n         * @param {composite} composite\n         * @return {composite} Returns composite\n         */\n        Composite.rebase = function (composite) {\n          var objects = Composite.allBodies(composite).concat(Composite.allConstraints(composite)).concat(Composite.allComposites(composite));\n          for (var i = 0; i < objects.length; i++) {\n            objects[i].id = Common.nextId();\n          }\n          return composite;\n        };\n\n        /**\n         * Translates all children in the composite by a given vector relative to their current positions, \n         * without imparting any velocity.\n         * @method translate\n         * @param {composite} composite\n         * @param {vector} translation\n         * @param {bool} [recursive=true]\n         */\n        Composite.translate = function (composite, translation, recursive) {\n          var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n          for (var i = 0; i < bodies.length; i++) {\n            Body.translate(bodies[i], translation);\n          }\n          return composite;\n        };\n\n        /**\n         * Rotates all children in the composite by a given angle about the given point, without imparting any angular velocity.\n         * @method rotate\n         * @param {composite} composite\n         * @param {number} rotation\n         * @param {vector} point\n         * @param {bool} [recursive=true]\n         */\n        Composite.rotate = function (composite, rotation, point, recursive) {\n          var cos = Math.cos(rotation),\n            sin = Math.sin(rotation),\n            bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n          for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n              dx = body.position.x - point.x,\n              dy = body.position.y - point.y;\n            Body.setPosition(body, {\n              x: point.x + (dx * cos - dy * sin),\n              y: point.y + (dx * sin + dy * cos)\n            });\n            Body.rotate(body, rotation);\n          }\n          return composite;\n        };\n\n        /**\n         * Scales all children in the composite, including updating physical properties (mass, area, axes, inertia), from a world-space point.\n         * @method scale\n         * @param {composite} composite\n         * @param {number} scaleX\n         * @param {number} scaleY\n         * @param {vector} point\n         * @param {bool} [recursive=true]\n         */\n        Composite.scale = function (composite, scaleX, scaleY, point, recursive) {\n          var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n          for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n              dx = body.position.x - point.x,\n              dy = body.position.y - point.y;\n            Body.setPosition(body, {\n              x: point.x + dx * scaleX,\n              y: point.y + dy * scaleY\n            });\n            Body.scale(body, scaleX, scaleY);\n          }\n          return composite;\n        };\n\n        /**\n         * Returns the union of the bounds of all of the composite's bodies.\n         * @method bounds\n         * @param {composite} composite The composite.\n         * @returns {bounds} The composite bounds.\n         */\n        Composite.bounds = function (composite) {\n          var bodies = Composite.allBodies(composite),\n            vertices = [];\n          for (var i = 0; i < bodies.length; i += 1) {\n            var body = bodies[i];\n            vertices.push(body.bounds.min, body.bounds.max);\n          }\n          return Bounds.create(vertices);\n        };\n\n        /*\n        *\n        *  Events Documentation\n        *\n        */\n\n        /**\n        * Fired when a call to `Composite.add` is made, before objects have been added.\n        *\n        * @event beforeAdd\n        * @param {} event An event object\n        * @param {} event.object The object(s) to be added (may be a single body, constraint, composite or a mixed array of these)\n        * @param {} event.source The source object of the event\n        * @param {} event.name The name of the event\n        */\n\n        /**\n        * Fired when a call to `Composite.add` is made, after objects have been added.\n        *\n        * @event afterAdd\n        * @param {} event An event object\n        * @param {} event.object The object(s) that have been added (may be a single body, constraint, composite or a mixed array of these)\n        * @param {} event.source The source object of the event\n        * @param {} event.name The name of the event\n        */\n\n        /**\n        * Fired when a call to `Composite.remove` is made, before objects have been removed.\n        *\n        * @event beforeRemove\n        * @param {} event An event object\n        * @param {} event.object The object(s) to be removed (may be a single body, constraint, composite or a mixed array of these)\n        * @param {} event.source The source object of the event\n        * @param {} event.name The name of the event\n        */\n\n        /**\n        * Fired when a call to `Composite.remove` is made, after objects have been removed.\n        *\n        * @event afterRemove\n        * @param {} event An event object\n        * @param {} event.object The object(s) that have been removed (may be a single body, constraint, composite or a mixed array of these)\n        * @param {} event.source The source object of the event\n        * @param {} event.name The name of the event\n        */\n\n        /*\n        *\n        *  Properties Documentation\n        *\n        */\n\n        /**\n         * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.\n         *\n         * @property id\n         * @type number\n         */\n\n        /**\n         * A `String` denoting the type of object.\n         *\n         * @property type\n         * @type string\n         * @default \"composite\"\n         * @readOnly\n         */\n\n        /**\n         * An arbitrary `String` name to help the user identify and manage composites.\n         *\n         * @property label\n         * @type string\n         * @default \"Composite\"\n         */\n\n        /**\n         * A flag that specifies whether the composite has been modified during the current step.\n         * This is automatically managed when bodies, constraints or composites are added or removed.\n         *\n         * @property isModified\n         * @type boolean\n         * @default false\n         */\n\n        /**\n         * The `Composite` that is the parent of this composite. It is automatically managed by the `Matter.Composite` methods.\n         *\n         * @property parent\n         * @type composite\n         * @default null\n         */\n\n        /**\n         * An array of `Body` that are _direct_ children of this composite.\n         * To add or remove bodies you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\n         * If you wish to recursively find all descendants, you should use the `Composite.allBodies` method.\n         *\n         * @property bodies\n         * @type body[]\n         * @default []\n         */\n\n        /**\n         * An array of `Constraint` that are _direct_ children of this composite.\n         * To add or remove constraints you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\n         * If you wish to recursively find all descendants, you should use the `Composite.allConstraints` method.\n         *\n         * @property constraints\n         * @type constraint[]\n         * @default []\n         */\n\n        /**\n         * An array of `Composite` that are _direct_ children of this composite.\n         * To add or remove composites you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\n         * If you wish to recursively find all descendants, you should use the `Composite.allComposites` method.\n         *\n         * @property composites\n         * @type composite[]\n         * @default []\n         */\n\n        /**\n         * An object reserved for storing plugin-specific properties.\n         *\n         * @property plugin\n         * @type {}\n         */\n\n        /**\n         * An object used for storing cached results for performance reasons.\n         * This is used internally only and is automatically managed.\n         *\n         * @private\n         * @property cache\n         * @type {}\n         */\n      })();\n\n      /***/\n    }, /* 7 */\n    /***/function (module, exports, __nested_webpack_require_135687__) {\n      /**\n      * The `Matter.Sleeping` module contains methods to manage the sleeping state of bodies.\n      *\n      * @class Sleeping\n      */\n\n      var Sleeping = {};\n      module.exports = Sleeping;\n      var Body = __nested_webpack_require_135687__(4);\n      var Events = __nested_webpack_require_135687__(5);\n      var Common = __nested_webpack_require_135687__(0);\n      (function () {\n        Sleeping._motionWakeThreshold = 0.18;\n        Sleeping._motionSleepThreshold = 0.08;\n        Sleeping._minBias = 0.9;\n\n        /**\n         * Puts bodies to sleep or wakes them up depending on their motion.\n         * @method update\n         * @param {body[]} bodies\n         * @param {number} delta\n         */\n        Sleeping.update = function (bodies, delta) {\n          var timeScale = delta / Common._baseDelta,\n            motionSleepThreshold = Sleeping._motionSleepThreshold;\n\n          // update bodies sleeping status\n          for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n              speed = Body.getSpeed(body),\n              angularSpeed = Body.getAngularSpeed(body),\n              motion = speed * speed + angularSpeed * angularSpeed;\n\n            // wake up bodies if they have a force applied\n            if (body.force.x !== 0 || body.force.y !== 0) {\n              Sleeping.set(body, false);\n              continue;\n            }\n            var minMotion = Math.min(body.motion, motion),\n              maxMotion = Math.max(body.motion, motion);\n\n            // biased average motion estimation between frames\n            body.motion = Sleeping._minBias * minMotion + (1 - Sleeping._minBias) * maxMotion;\n            if (body.sleepThreshold > 0 && body.motion < motionSleepThreshold) {\n              body.sleepCounter += 1;\n              if (body.sleepCounter >= body.sleepThreshold / timeScale) {\n                Sleeping.set(body, true);\n              }\n            } else if (body.sleepCounter > 0) {\n              body.sleepCounter -= 1;\n            }\n          }\n        };\n\n        /**\n         * Given a set of colliding pairs, wakes the sleeping bodies involved.\n         * @method afterCollisions\n         * @param {pair[]} pairs\n         */\n        Sleeping.afterCollisions = function (pairs) {\n          var motionSleepThreshold = Sleeping._motionSleepThreshold;\n\n          // wake up bodies involved in collisions\n          for (var i = 0; i < pairs.length; i++) {\n            var pair = pairs[i];\n\n            // don't wake inactive pairs\n            if (!pair.isActive) continue;\n            var collision = pair.collision,\n              bodyA = collision.bodyA.parent,\n              bodyB = collision.bodyB.parent;\n\n            // don't wake if at least one body is static\n            if (bodyA.isSleeping && bodyB.isSleeping || bodyA.isStatic || bodyB.isStatic) continue;\n            if (bodyA.isSleeping || bodyB.isSleeping) {\n              var sleepingBody = bodyA.isSleeping && !bodyA.isStatic ? bodyA : bodyB,\n                movingBody = sleepingBody === bodyA ? bodyB : bodyA;\n              if (!sleepingBody.isStatic && movingBody.motion > motionSleepThreshold) {\n                Sleeping.set(sleepingBody, false);\n              }\n            }\n          }\n        };\n\n        /**\n         * Set a body as sleeping or awake.\n         * @method set\n         * @param {body} body\n         * @param {boolean} isSleeping\n         */\n        Sleeping.set = function (body, isSleeping) {\n          var wasSleeping = body.isSleeping;\n          if (isSleeping) {\n            body.isSleeping = true;\n            body.sleepCounter = body.sleepThreshold;\n            body.positionImpulse.x = 0;\n            body.positionImpulse.y = 0;\n            body.positionPrev.x = body.position.x;\n            body.positionPrev.y = body.position.y;\n            body.anglePrev = body.angle;\n            body.speed = 0;\n            body.angularSpeed = 0;\n            body.motion = 0;\n            if (!wasSleeping) {\n              Events.trigger(body, 'sleepStart');\n            }\n          } else {\n            body.isSleeping = false;\n            body.sleepCounter = 0;\n            if (wasSleeping) {\n              Events.trigger(body, 'sleepEnd');\n            }\n          }\n        };\n      })();\n\n      /***/\n    }, /* 8 */\n    /***/function (module, exports, __nested_webpack_require_139983__) {\n      /**\n      * The `Matter.Collision` module contains methods for detecting collisions between a given pair of bodies.\n      *\n      * For efficient detection between a list of bodies, see `Matter.Detector` and `Matter.Query`.\n      *\n      * See `Matter.Engine` for collision events.\n      *\n      * @class Collision\n      */\n\n      var Collision = {};\n      module.exports = Collision;\n      var Vertices = __nested_webpack_require_139983__(3);\n      var Pair = __nested_webpack_require_139983__(9);\n      (function () {\n        var _supports = [];\n        var _overlapAB = {\n          overlap: 0,\n          axis: null\n        };\n        var _overlapBA = {\n          overlap: 0,\n          axis: null\n        };\n\n        /**\n         * Creates a new collision record.\n         * @method create\n         * @param {body} bodyA The first body part represented by the collision record\n         * @param {body} bodyB The second body part represented by the collision record\n         * @return {collision} A new collision record\n         */\n        Collision.create = function (bodyA, bodyB) {\n          return {\n            pair: null,\n            collided: false,\n            bodyA: bodyA,\n            bodyB: bodyB,\n            parentA: bodyA.parent,\n            parentB: bodyB.parent,\n            depth: 0,\n            normal: {\n              x: 0,\n              y: 0\n            },\n            tangent: {\n              x: 0,\n              y: 0\n            },\n            penetration: {\n              x: 0,\n              y: 0\n            },\n            supports: []\n          };\n        };\n\n        /**\n         * Detect collision between two bodies.\n         * @method collides\n         * @param {body} bodyA\n         * @param {body} bodyB\n         * @param {pairs} [pairs] Optionally reuse collision records from existing pairs.\n         * @return {collision|null} A collision record if detected, otherwise null\n         */\n        Collision.collides = function (bodyA, bodyB, pairs) {\n          Collision._overlapAxes(_overlapAB, bodyA.vertices, bodyB.vertices, bodyA.axes);\n          if (_overlapAB.overlap <= 0) {\n            return null;\n          }\n          Collision._overlapAxes(_overlapBA, bodyB.vertices, bodyA.vertices, bodyB.axes);\n          if (_overlapBA.overlap <= 0) {\n            return null;\n          }\n\n          // reuse collision records for gc efficiency\n          var pair = pairs && pairs.table[Pair.id(bodyA, bodyB)],\n            collision;\n          if (!pair) {\n            collision = Collision.create(bodyA, bodyB);\n            collision.collided = true;\n            collision.bodyA = bodyA.id < bodyB.id ? bodyA : bodyB;\n            collision.bodyB = bodyA.id < bodyB.id ? bodyB : bodyA;\n            collision.parentA = collision.bodyA.parent;\n            collision.parentB = collision.bodyB.parent;\n          } else {\n            collision = pair.collision;\n          }\n          bodyA = collision.bodyA;\n          bodyB = collision.bodyB;\n          var minOverlap;\n          if (_overlapAB.overlap < _overlapBA.overlap) {\n            minOverlap = _overlapAB;\n          } else {\n            minOverlap = _overlapBA;\n          }\n          var normal = collision.normal,\n            supports = collision.supports,\n            minAxis = minOverlap.axis,\n            minAxisX = minAxis.x,\n            minAxisY = minAxis.y;\n\n          // ensure normal is facing away from bodyA\n          if (minAxisX * (bodyB.position.x - bodyA.position.x) + minAxisY * (bodyB.position.y - bodyA.position.y) < 0) {\n            normal.x = minAxisX;\n            normal.y = minAxisY;\n          } else {\n            normal.x = -minAxisX;\n            normal.y = -minAxisY;\n          }\n          collision.tangent.x = -normal.y;\n          collision.tangent.y = normal.x;\n          collision.depth = minOverlap.overlap;\n          collision.penetration.x = normal.x * collision.depth;\n          collision.penetration.y = normal.y * collision.depth;\n\n          // find support points, there is always either exactly one or two\n          var supportsB = Collision._findSupports(bodyA, bodyB, normal, 1),\n            supportCount = 0;\n\n          // find the supports from bodyB that are inside bodyA\n          if (Vertices.contains(bodyA.vertices, supportsB[0])) {\n            supports[supportCount++] = supportsB[0];\n          }\n          if (Vertices.contains(bodyA.vertices, supportsB[1])) {\n            supports[supportCount++] = supportsB[1];\n          }\n\n          // find the supports from bodyA that are inside bodyB\n          if (supportCount < 2) {\n            var supportsA = Collision._findSupports(bodyB, bodyA, normal, -1);\n            if (Vertices.contains(bodyB.vertices, supportsA[0])) {\n              supports[supportCount++] = supportsA[0];\n            }\n            if (supportCount < 2 && Vertices.contains(bodyB.vertices, supportsA[1])) {\n              supports[supportCount++] = supportsA[1];\n            }\n          }\n\n          // account for the edge case of overlapping but no vertex containment\n          if (supportCount === 0) {\n            supports[supportCount++] = supportsB[0];\n          }\n\n          // update supports array size\n          supports.length = supportCount;\n          return collision;\n        };\n\n        /**\n         * Find the overlap between two sets of vertices.\n         * @method _overlapAxes\n         * @private\n         * @param {object} result\n         * @param {vertices} verticesA\n         * @param {vertices} verticesB\n         * @param {axes} axes\n         */\n        Collision._overlapAxes = function (result, verticesA, verticesB, axes) {\n          var verticesALength = verticesA.length,\n            verticesBLength = verticesB.length,\n            verticesAX = verticesA[0].x,\n            verticesAY = verticesA[0].y,\n            verticesBX = verticesB[0].x,\n            verticesBY = verticesB[0].y,\n            axesLength = axes.length,\n            overlapMin = Number.MAX_VALUE,\n            overlapAxisNumber = 0,\n            overlap,\n            overlapAB,\n            overlapBA,\n            dot,\n            i,\n            j;\n          for (i = 0; i < axesLength; i++) {\n            var axis = axes[i],\n              axisX = axis.x,\n              axisY = axis.y,\n              minA = verticesAX * axisX + verticesAY * axisY,\n              minB = verticesBX * axisX + verticesBY * axisY,\n              maxA = minA,\n              maxB = minB;\n            for (j = 1; j < verticesALength; j += 1) {\n              dot = verticesA[j].x * axisX + verticesA[j].y * axisY;\n              if (dot > maxA) {\n                maxA = dot;\n              } else if (dot < minA) {\n                minA = dot;\n              }\n            }\n            for (j = 1; j < verticesBLength; j += 1) {\n              dot = verticesB[j].x * axisX + verticesB[j].y * axisY;\n              if (dot > maxB) {\n                maxB = dot;\n              } else if (dot < minB) {\n                minB = dot;\n              }\n            }\n            overlapAB = maxA - minB;\n            overlapBA = maxB - minA;\n            overlap = overlapAB < overlapBA ? overlapAB : overlapBA;\n            if (overlap < overlapMin) {\n              overlapMin = overlap;\n              overlapAxisNumber = i;\n              if (overlap <= 0) {\n                // can not be intersecting\n                break;\n              }\n            }\n          }\n          result.axis = axes[overlapAxisNumber];\n          result.overlap = overlapMin;\n        };\n\n        /**\n         * Projects vertices on an axis and returns an interval.\n         * @method _projectToAxis\n         * @private\n         * @param {} projection\n         * @param {} vertices\n         * @param {} axis\n         */\n        Collision._projectToAxis = function (projection, vertices, axis) {\n          var min = vertices[0].x * axis.x + vertices[0].y * axis.y,\n            max = min;\n          for (var i = 1; i < vertices.length; i += 1) {\n            var dot = vertices[i].x * axis.x + vertices[i].y * axis.y;\n            if (dot > max) {\n              max = dot;\n            } else if (dot < min) {\n              min = dot;\n            }\n          }\n          projection.min = min;\n          projection.max = max;\n        };\n\n        /**\n         * Finds supporting vertices given two bodies along a given direction using hill-climbing.\n         * @method _findSupports\n         * @private\n         * @param {body} bodyA\n         * @param {body} bodyB\n         * @param {vector} normal\n         * @param {number} direction\n         * @return [vector]\n         */\n        Collision._findSupports = function (bodyA, bodyB, normal, direction) {\n          var vertices = bodyB.vertices,\n            verticesLength = vertices.length,\n            bodyAPositionX = bodyA.position.x,\n            bodyAPositionY = bodyA.position.y,\n            normalX = normal.x * direction,\n            normalY = normal.y * direction,\n            nearestDistance = Number.MAX_VALUE,\n            vertexA,\n            vertexB,\n            vertexC,\n            distance,\n            j;\n\n          // find deepest vertex relative to the axis\n          for (j = 0; j < verticesLength; j += 1) {\n            vertexB = vertices[j];\n            distance = normalX * (bodyAPositionX - vertexB.x) + normalY * (bodyAPositionY - vertexB.y);\n\n            // convex hill-climbing\n            if (distance < nearestDistance) {\n              nearestDistance = distance;\n              vertexA = vertexB;\n            }\n          }\n\n          // measure next vertex\n          vertexC = vertices[(verticesLength + vertexA.index - 1) % verticesLength];\n          nearestDistance = normalX * (bodyAPositionX - vertexC.x) + normalY * (bodyAPositionY - vertexC.y);\n\n          // compare with previous vertex\n          vertexB = vertices[(vertexA.index + 1) % verticesLength];\n          if (normalX * (bodyAPositionX - vertexB.x) + normalY * (bodyAPositionY - vertexB.y) < nearestDistance) {\n            _supports[0] = vertexA;\n            _supports[1] = vertexB;\n            return _supports;\n          }\n          _supports[0] = vertexA;\n          _supports[1] = vertexC;\n          return _supports;\n        };\n\n        /*\n        *\n        *  Properties Documentation\n        *\n        */\n\n        /**\n         * A reference to the pair using this collision record, if there is one.\n         *\n         * @property pair\n         * @type {pair|null}\n         * @default null\n         */\n\n        /**\n         * A flag that indicates if the bodies were colliding when the collision was last updated.\n         * \n         * @property collided\n         * @type boolean\n         * @default false\n         */\n\n        /**\n         * The first body part represented by the collision (see also `collision.parentA`).\n         * \n         * @property bodyA\n         * @type body\n         */\n\n        /**\n         * The second body part represented by the collision (see also `collision.parentB`).\n         * \n         * @property bodyB\n         * @type body\n         */\n\n        /**\n         * The first body represented by the collision (i.e. `collision.bodyA.parent`).\n         * \n         * @property parentA\n         * @type body\n         */\n\n        /**\n         * The second body represented by the collision (i.e. `collision.bodyB.parent`).\n         * \n         * @property parentB\n         * @type body\n         */\n\n        /**\n         * A `Number` that represents the minimum separating distance between the bodies along the collision normal.\n         *\n         * @readOnly\n         * @property depth\n         * @type number\n         * @default 0\n         */\n\n        /**\n         * A normalised `Vector` that represents the direction between the bodies that provides the minimum separating distance.\n         *\n         * @property normal\n         * @type vector\n         * @default { x: 0, y: 0 }\n         */\n\n        /**\n         * A normalised `Vector` that is the tangent direction to the collision normal.\n         *\n         * @property tangent\n         * @type vector\n         * @default { x: 0, y: 0 }\n         */\n\n        /**\n         * A `Vector` that represents the direction and depth of the collision.\n         *\n         * @property penetration\n         * @type vector\n         * @default { x: 0, y: 0 }\n         */\n\n        /**\n         * An array of body vertices that represent the support points in the collision.\n         * These are the deepest vertices (along the collision normal) of each body that are contained by the other body's vertices.\n         *\n         * @property supports\n         * @type vector[]\n         * @default []\n         */\n      })();\n\n      /***/\n    }, /* 9 */\n    /***/function (module, exports, __nested_webpack_require_152668__) {\n      /**\n      * The `Matter.Pair` module contains methods for creating and manipulating collision pairs.\n      *\n      * @class Pair\n      */\n\n      var Pair = {};\n      module.exports = Pair;\n      var Contact = __nested_webpack_require_152668__(16);\n      (function () {\n        /**\n         * Creates a pair.\n         * @method create\n         * @param {collision} collision\n         * @param {number} timestamp\n         * @return {pair} A new pair\n         */\n        Pair.create = function (collision, timestamp) {\n          var bodyA = collision.bodyA,\n            bodyB = collision.bodyB;\n          var pair = {\n            id: Pair.id(bodyA, bodyB),\n            bodyA: bodyA,\n            bodyB: bodyB,\n            collision: collision,\n            contacts: [],\n            activeContacts: [],\n            separation: 0,\n            isActive: true,\n            confirmedActive: true,\n            isSensor: bodyA.isSensor || bodyB.isSensor,\n            timeCreated: timestamp,\n            timeUpdated: timestamp,\n            inverseMass: 0,\n            friction: 0,\n            frictionStatic: 0,\n            restitution: 0,\n            slop: 0\n          };\n          Pair.update(pair, collision, timestamp);\n          return pair;\n        };\n\n        /**\n         * Updates a pair given a collision.\n         * @method update\n         * @param {pair} pair\n         * @param {collision} collision\n         * @param {number} timestamp\n         */\n        Pair.update = function (pair, collision, timestamp) {\n          var contacts = pair.contacts,\n            supports = collision.supports,\n            activeContacts = pair.activeContacts,\n            parentA = collision.parentA,\n            parentB = collision.parentB,\n            parentAVerticesLength = parentA.vertices.length;\n          pair.isActive = true;\n          pair.timeUpdated = timestamp;\n          pair.collision = collision;\n          pair.separation = collision.depth;\n          pair.inverseMass = parentA.inverseMass + parentB.inverseMass;\n          pair.friction = parentA.friction < parentB.friction ? parentA.friction : parentB.friction;\n          pair.frictionStatic = parentA.frictionStatic > parentB.frictionStatic ? parentA.frictionStatic : parentB.frictionStatic;\n          pair.restitution = parentA.restitution > parentB.restitution ? parentA.restitution : parentB.restitution;\n          pair.slop = parentA.slop > parentB.slop ? parentA.slop : parentB.slop;\n          collision.pair = pair;\n          activeContacts.length = 0;\n          for (var i = 0; i < supports.length; i++) {\n            var support = supports[i],\n              contactId = support.body === parentA ? support.index : parentAVerticesLength + support.index,\n              contact = contacts[contactId];\n            if (contact) {\n              activeContacts.push(contact);\n            } else {\n              activeContacts.push(contacts[contactId] = Contact.create(support));\n            }\n          }\n        };\n\n        /**\n         * Set a pair as active or inactive.\n         * @method setActive\n         * @param {pair} pair\n         * @param {bool} isActive\n         * @param {number} timestamp\n         */\n        Pair.setActive = function (pair, isActive, timestamp) {\n          if (isActive) {\n            pair.isActive = true;\n            pair.timeUpdated = timestamp;\n          } else {\n            pair.isActive = false;\n            pair.activeContacts.length = 0;\n          }\n        };\n\n        /**\n         * Get the id for the given pair.\n         * @method id\n         * @param {body} bodyA\n         * @param {body} bodyB\n         * @return {string} Unique pairId\n         */\n        Pair.id = function (bodyA, bodyB) {\n          if (bodyA.id < bodyB.id) {\n            return 'A' + bodyA.id + 'B' + bodyB.id;\n          } else {\n            return 'A' + bodyB.id + 'B' + bodyA.id;\n          }\n        };\n      })();\n\n      /***/\n    }, /* 10 */\n    /***/function (module, exports, __nested_webpack_require_156637__) {\n      /**\n      * The `Matter.Constraint` module contains methods for creating and manipulating constraints.\n      * Constraints are used for specifying that a fixed distance must be maintained between two bodies (or a body and a fixed world-space position).\n      * The stiffness of constraints can be modified to create springs or elastic.\n      *\n      * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n      *\n      * @class Constraint\n      */\n\n      var Constraint = {};\n      module.exports = Constraint;\n      var Vertices = __nested_webpack_require_156637__(3);\n      var Vector = __nested_webpack_require_156637__(2);\n      var Sleeping = __nested_webpack_require_156637__(7);\n      var Bounds = __nested_webpack_require_156637__(1);\n      var Axes = __nested_webpack_require_156637__(11);\n      var Common = __nested_webpack_require_156637__(0);\n      (function () {\n        Constraint._warming = 0.4;\n        Constraint._torqueDampen = 1;\n        Constraint._minLength = 0.000001;\n\n        /**\n         * Creates a new constraint.\n         * All properties have default values, and many are pre-calculated automatically based on other properties.\n         * To simulate a revolute constraint (or pin joint) set `length: 0` and a high `stiffness` value (e.g. `0.7` or above).\n         * If the constraint is unstable, try lowering the `stiffness` value and / or increasing `engine.constraintIterations`.\n         * For compound bodies, constraints must be applied to the parent body (not one of its parts).\n         * See the properties section below for detailed information on what you can pass via the `options` object.\n         * @method create\n         * @param {} options\n         * @return {constraint} constraint\n         */\n        Constraint.create = function (options) {\n          var constraint = options;\n\n          // if bodies defined but no points, use body centre\n          if (constraint.bodyA && !constraint.pointA) constraint.pointA = {\n            x: 0,\n            y: 0\n          };\n          if (constraint.bodyB && !constraint.pointB) constraint.pointB = {\n            x: 0,\n            y: 0\n          };\n\n          // calculate static length using initial world space points\n          var initialPointA = constraint.bodyA ? Vector.add(constraint.bodyA.position, constraint.pointA) : constraint.pointA,\n            initialPointB = constraint.bodyB ? Vector.add(constraint.bodyB.position, constraint.pointB) : constraint.pointB,\n            length = Vector.magnitude(Vector.sub(initialPointA, initialPointB));\n          constraint.length = typeof constraint.length !== 'undefined' ? constraint.length : length;\n\n          // option defaults\n          constraint.id = constraint.id || Common.nextId();\n          constraint.label = constraint.label || 'Constraint';\n          constraint.type = 'constraint';\n          constraint.stiffness = constraint.stiffness || (constraint.length > 0 ? 1 : 0.7);\n          constraint.damping = constraint.damping || 0;\n          constraint.angularStiffness = constraint.angularStiffness || 0;\n          constraint.angleA = constraint.bodyA ? constraint.bodyA.angle : constraint.angleA;\n          constraint.angleB = constraint.bodyB ? constraint.bodyB.angle : constraint.angleB;\n          constraint.plugin = {};\n\n          // render\n          var render = {\n            visible: true,\n            lineWidth: 2,\n            strokeStyle: '#ffffff',\n            type: 'line',\n            anchors: true\n          };\n          if (constraint.length === 0 && constraint.stiffness > 0.1) {\n            render.type = 'pin';\n            render.anchors = false;\n          } else if (constraint.stiffness < 0.9) {\n            render.type = 'spring';\n          }\n          constraint.render = Common.extend(render, constraint.render);\n          return constraint;\n        };\n\n        /**\n         * Prepares for solving by constraint warming.\n         * @private\n         * @method preSolveAll\n         * @param {body[]} bodies\n         */\n        Constraint.preSolveAll = function (bodies) {\n          for (var i = 0; i < bodies.length; i += 1) {\n            var body = bodies[i],\n              impulse = body.constraintImpulse;\n            if (body.isStatic || impulse.x === 0 && impulse.y === 0 && impulse.angle === 0) {\n              continue;\n            }\n            body.position.x += impulse.x;\n            body.position.y += impulse.y;\n            body.angle += impulse.angle;\n          }\n        };\n\n        /**\n         * Solves all constraints in a list of collisions.\n         * @private\n         * @method solveAll\n         * @param {constraint[]} constraints\n         * @param {number} delta\n         */\n        Constraint.solveAll = function (constraints, delta) {\n          var timeScale = Common.clamp(delta / Common._baseDelta, 0, 1);\n\n          // Solve fixed constraints first.\n          for (var i = 0; i < constraints.length; i += 1) {\n            var constraint = constraints[i],\n              fixedA = !constraint.bodyA || constraint.bodyA && constraint.bodyA.isStatic,\n              fixedB = !constraint.bodyB || constraint.bodyB && constraint.bodyB.isStatic;\n            if (fixedA || fixedB) {\n              Constraint.solve(constraints[i], timeScale);\n            }\n          }\n\n          // Solve free constraints last.\n          for (i = 0; i < constraints.length; i += 1) {\n            constraint = constraints[i];\n            fixedA = !constraint.bodyA || constraint.bodyA && constraint.bodyA.isStatic;\n            fixedB = !constraint.bodyB || constraint.bodyB && constraint.bodyB.isStatic;\n            if (!fixedA && !fixedB) {\n              Constraint.solve(constraints[i], timeScale);\n            }\n          }\n        };\n\n        /**\n         * Solves a distance constraint with Gauss-Siedel method.\n         * @private\n         * @method solve\n         * @param {constraint} constraint\n         * @param {number} timeScale\n         */\n        Constraint.solve = function (constraint, timeScale) {\n          var bodyA = constraint.bodyA,\n            bodyB = constraint.bodyB,\n            pointA = constraint.pointA,\n            pointB = constraint.pointB;\n          if (!bodyA && !bodyB) return;\n\n          // update reference angle\n          if (bodyA && !bodyA.isStatic) {\n            Vector.rotate(pointA, bodyA.angle - constraint.angleA, pointA);\n            constraint.angleA = bodyA.angle;\n          }\n\n          // update reference angle\n          if (bodyB && !bodyB.isStatic) {\n            Vector.rotate(pointB, bodyB.angle - constraint.angleB, pointB);\n            constraint.angleB = bodyB.angle;\n          }\n          var pointAWorld = pointA,\n            pointBWorld = pointB;\n          if (bodyA) pointAWorld = Vector.add(bodyA.position, pointA);\n          if (bodyB) pointBWorld = Vector.add(bodyB.position, pointB);\n          if (!pointAWorld || !pointBWorld) return;\n          var delta = Vector.sub(pointAWorld, pointBWorld),\n            currentLength = Vector.magnitude(delta);\n\n          // prevent singularity\n          if (currentLength < Constraint._minLength) {\n            currentLength = Constraint._minLength;\n          }\n\n          // solve distance constraint with Gauss-Siedel method\n          var difference = (currentLength - constraint.length) / currentLength,\n            isRigid = constraint.stiffness >= 1 || constraint.length === 0,\n            stiffness = isRigid ? constraint.stiffness * timeScale : constraint.stiffness * timeScale * timeScale,\n            damping = constraint.damping * timeScale,\n            force = Vector.mult(delta, difference * stiffness),\n            massTotal = (bodyA ? bodyA.inverseMass : 0) + (bodyB ? bodyB.inverseMass : 0),\n            inertiaTotal = (bodyA ? bodyA.inverseInertia : 0) + (bodyB ? bodyB.inverseInertia : 0),\n            resistanceTotal = massTotal + inertiaTotal,\n            torque,\n            share,\n            normal,\n            normalVelocity,\n            relativeVelocity;\n          if (damping > 0) {\n            var zero = Vector.create();\n            normal = Vector.div(delta, currentLength);\n            relativeVelocity = Vector.sub(bodyB && Vector.sub(bodyB.position, bodyB.positionPrev) || zero, bodyA && Vector.sub(bodyA.position, bodyA.positionPrev) || zero);\n            normalVelocity = Vector.dot(normal, relativeVelocity);\n          }\n          if (bodyA && !bodyA.isStatic) {\n            share = bodyA.inverseMass / massTotal;\n\n            // keep track of applied impulses for post solving\n            bodyA.constraintImpulse.x -= force.x * share;\n            bodyA.constraintImpulse.y -= force.y * share;\n\n            // apply forces\n            bodyA.position.x -= force.x * share;\n            bodyA.position.y -= force.y * share;\n\n            // apply damping\n            if (damping > 0) {\n              bodyA.positionPrev.x -= damping * normal.x * normalVelocity * share;\n              bodyA.positionPrev.y -= damping * normal.y * normalVelocity * share;\n            }\n\n            // apply torque\n            torque = Vector.cross(pointA, force) / resistanceTotal * Constraint._torqueDampen * bodyA.inverseInertia * (1 - constraint.angularStiffness);\n            bodyA.constraintImpulse.angle -= torque;\n            bodyA.angle -= torque;\n          }\n          if (bodyB && !bodyB.isStatic) {\n            share = bodyB.inverseMass / massTotal;\n\n            // keep track of applied impulses for post solving\n            bodyB.constraintImpulse.x += force.x * share;\n            bodyB.constraintImpulse.y += force.y * share;\n\n            // apply forces\n            bodyB.position.x += force.x * share;\n            bodyB.position.y += force.y * share;\n\n            // apply damping\n            if (damping > 0) {\n              bodyB.positionPrev.x += damping * normal.x * normalVelocity * share;\n              bodyB.positionPrev.y += damping * normal.y * normalVelocity * share;\n            }\n\n            // apply torque\n            torque = Vector.cross(pointB, force) / resistanceTotal * Constraint._torqueDampen * bodyB.inverseInertia * (1 - constraint.angularStiffness);\n            bodyB.constraintImpulse.angle += torque;\n            bodyB.angle += torque;\n          }\n        };\n\n        /**\n         * Performs body updates required after solving constraints.\n         * @private\n         * @method postSolveAll\n         * @param {body[]} bodies\n         */\n        Constraint.postSolveAll = function (bodies) {\n          for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n              impulse = body.constraintImpulse;\n            if (body.isStatic || impulse.x === 0 && impulse.y === 0 && impulse.angle === 0) {\n              continue;\n            }\n            Sleeping.set(body, false);\n\n            // update geometry and reset\n            for (var j = 0; j < body.parts.length; j++) {\n              var part = body.parts[j];\n              Vertices.translate(part.vertices, impulse);\n              if (j > 0) {\n                part.position.x += impulse.x;\n                part.position.y += impulse.y;\n              }\n              if (impulse.angle !== 0) {\n                Vertices.rotate(part.vertices, impulse.angle, body.position);\n                Axes.rotate(part.axes, impulse.angle);\n                if (j > 0) {\n                  Vector.rotateAbout(part.position, impulse.angle, body.position, part.position);\n                }\n              }\n              Bounds.update(part.bounds, part.vertices, body.velocity);\n            }\n\n            // dampen the cached impulse for warming next step\n            impulse.angle *= Constraint._warming;\n            impulse.x *= Constraint._warming;\n            impulse.y *= Constraint._warming;\n          }\n        };\n\n        /**\n         * Returns the world-space position of `constraint.pointA`, accounting for `constraint.bodyA`.\n         * @method pointAWorld\n         * @param {constraint} constraint\n         * @returns {vector} the world-space position\n         */\n        Constraint.pointAWorld = function (constraint) {\n          return {\n            x: (constraint.bodyA ? constraint.bodyA.position.x : 0) + (constraint.pointA ? constraint.pointA.x : 0),\n            y: (constraint.bodyA ? constraint.bodyA.position.y : 0) + (constraint.pointA ? constraint.pointA.y : 0)\n          };\n        };\n\n        /**\n         * Returns the world-space position of `constraint.pointB`, accounting for `constraint.bodyB`.\n         * @method pointBWorld\n         * @param {constraint} constraint\n         * @returns {vector} the world-space position\n         */\n        Constraint.pointBWorld = function (constraint) {\n          return {\n            x: (constraint.bodyB ? constraint.bodyB.position.x : 0) + (constraint.pointB ? constraint.pointB.x : 0),\n            y: (constraint.bodyB ? constraint.bodyB.position.y : 0) + (constraint.pointB ? constraint.pointB.y : 0)\n          };\n        };\n\n        /*\n        *\n        *  Properties Documentation\n        *\n        */\n\n        /**\n         * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.\n         *\n         * @property id\n         * @type number\n         */\n\n        /**\n         * A `String` denoting the type of object.\n         *\n         * @property type\n         * @type string\n         * @default \"constraint\"\n         * @readOnly\n         */\n\n        /**\n         * An arbitrary `String` name to help the user identify and manage bodies.\n         *\n         * @property label\n         * @type string\n         * @default \"Constraint\"\n         */\n\n        /**\n         * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.\n         *\n         * @property render\n         * @type object\n         */\n\n        /**\n         * A flag that indicates if the constraint should be rendered.\n         *\n         * @property render.visible\n         * @type boolean\n         * @default true\n         */\n\n        /**\n         * A `Number` that defines the line width to use when rendering the constraint outline.\n         * A value of `0` means no outline will be rendered.\n         *\n         * @property render.lineWidth\n         * @type number\n         * @default 2\n         */\n\n        /**\n         * A `String` that defines the stroke style to use when rendering the constraint outline.\n         * It is the same as when using a canvas, so it accepts CSS style property values.\n         *\n         * @property render.strokeStyle\n         * @type string\n         * @default a random colour\n         */\n\n        /**\n         * A `String` that defines the constraint rendering type. \n         * The possible values are 'line', 'pin', 'spring'.\n         * An appropriate render type will be automatically chosen unless one is given in options.\n         *\n         * @property render.type\n         * @type string\n         * @default 'line'\n         */\n\n        /**\n         * A `Boolean` that defines if the constraint's anchor points should be rendered.\n         *\n         * @property render.anchors\n         * @type boolean\n         * @default true\n         */\n\n        /**\n         * The first possible `Body` that this constraint is attached to.\n         *\n         * @property bodyA\n         * @type body\n         * @default null\n         */\n\n        /**\n         * The second possible `Body` that this constraint is attached to.\n         *\n         * @property bodyB\n         * @type body\n         * @default null\n         */\n\n        /**\n         * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyA` if defined, otherwise a world-space position.\n         *\n         * @property pointA\n         * @type vector\n         * @default { x: 0, y: 0 }\n         */\n\n        /**\n         * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyB` if defined, otherwise a world-space position.\n         *\n         * @property pointB\n         * @type vector\n         * @default { x: 0, y: 0 }\n         */\n\n        /**\n         * A `Number` that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`.\n         * A value of `1` means the constraint should be very stiff.\n         * A value of `0.2` means the constraint acts like a soft spring.\n         *\n         * @property stiffness\n         * @type number\n         * @default 1\n         */\n\n        /**\n         * A `Number` that specifies the damping of the constraint, \n         * i.e. the amount of resistance applied to each body based on their velocities to limit the amount of oscillation.\n         * Damping will only be apparent when the constraint also has a very low `stiffness`.\n         * A value of `0.1` means the constraint will apply heavy damping, resulting in little to no oscillation.\n         * A value of `0` means the constraint will apply no damping.\n         *\n         * @property damping\n         * @type number\n         * @default 0\n         */\n\n        /**\n         * A `Number` that specifies the target resting length of the constraint. \n         * It is calculated automatically in `Constraint.create` from initial positions of the `constraint.bodyA` and `constraint.bodyB`.\n         *\n         * @property length\n         * @type number\n         */\n\n        /**\n         * An object reserved for storing plugin-specific properties.\n         *\n         * @property plugin\n         * @type {}\n         */\n      })();\n\n      /***/\n    }, /* 11 */\n    /***/function (module, exports, __nested_webpack_require_174167__) {\n      /**\n      * The `Matter.Axes` module contains methods for creating and manipulating sets of axes.\n      *\n      * @class Axes\n      */\n\n      var Axes = {};\n      module.exports = Axes;\n      var Vector = __nested_webpack_require_174167__(2);\n      var Common = __nested_webpack_require_174167__(0);\n      (function () {\n        /**\n         * Creates a new set of axes from the given vertices.\n         * @method fromVertices\n         * @param {vertices} vertices\n         * @return {axes} A new axes from the given vertices\n         */\n        Axes.fromVertices = function (vertices) {\n          var axes = {};\n\n          // find the unique axes, using edge normal gradients\n          for (var i = 0; i < vertices.length; i++) {\n            var j = (i + 1) % vertices.length,\n              normal = Vector.normalise({\n                x: vertices[j].y - vertices[i].y,\n                y: vertices[i].x - vertices[j].x\n              }),\n              gradient = normal.y === 0 ? Infinity : normal.x / normal.y;\n\n            // limit precision\n            gradient = gradient.toFixed(3).toString();\n            axes[gradient] = normal;\n          }\n          return Common.values(axes);\n        };\n\n        /**\n         * Rotates a set of axes by the given angle.\n         * @method rotate\n         * @param {axes} axes\n         * @param {number} angle\n         */\n        Axes.rotate = function (axes, angle) {\n          if (angle === 0) return;\n          var cos = Math.cos(angle),\n            sin = Math.sin(angle);\n          for (var i = 0; i < axes.length; i++) {\n            var axis = axes[i],\n              xx;\n            xx = axis.x * cos - axis.y * sin;\n            axis.y = axis.x * sin + axis.y * cos;\n            axis.x = xx;\n          }\n        };\n      })();\n\n      /***/\n    }, /* 12 */\n    /***/function (module, exports, __nested_webpack_require_176006__) {\n      /**\n      * The `Matter.Bodies` module contains factory methods for creating rigid body models \n      * with commonly used body configurations (such as rectangles, circles and other polygons).\n      *\n      * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n      *\n      * @class Bodies\n      */\n\n      // TODO: true circle bodies\n\n      var Bodies = {};\n      module.exports = Bodies;\n      var Vertices = __nested_webpack_require_176006__(3);\n      var Common = __nested_webpack_require_176006__(0);\n      var Body = __nested_webpack_require_176006__(4);\n      var Bounds = __nested_webpack_require_176006__(1);\n      var Vector = __nested_webpack_require_176006__(2);\n      (function () {\n        /**\n         * Creates a new rigid body model with a rectangle hull. \n         * The options parameter is an object that specifies any properties you wish to override the defaults.\n         * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n         * @method rectangle\n         * @param {number} x\n         * @param {number} y\n         * @param {number} width\n         * @param {number} height\n         * @param {object} [options]\n         * @return {body} A new rectangle body\n         */\n        Bodies.rectangle = function (x, y, width, height, options) {\n          options = options || {};\n          var rectangle = {\n            label: 'Rectangle Body',\n            position: {\n              x: x,\n              y: y\n            },\n            vertices: Vertices.fromPath('L 0 0 L ' + width + ' 0 L ' + width + ' ' + height + ' L 0 ' + height)\n          };\n          if (options.chamfer) {\n            var chamfer = options.chamfer;\n            rectangle.vertices = Vertices.chamfer(rectangle.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n            delete options.chamfer;\n          }\n          return Body.create(Common.extend({}, rectangle, options));\n        };\n\n        /**\n         * Creates a new rigid body model with a trapezoid hull. \n         * The options parameter is an object that specifies any properties you wish to override the defaults.\n         * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n         * @method trapezoid\n         * @param {number} x\n         * @param {number} y\n         * @param {number} width\n         * @param {number} height\n         * @param {number} slope\n         * @param {object} [options]\n         * @return {body} A new trapezoid body\n         */\n        Bodies.trapezoid = function (x, y, width, height, slope, options) {\n          options = options || {};\n          slope *= 0.5;\n          var roof = (1 - slope * 2) * width;\n          var x1 = width * slope,\n            x2 = x1 + roof,\n            x3 = x2 + x1,\n            verticesPath;\n          if (slope < 0.5) {\n            verticesPath = 'L 0 0 L ' + x1 + ' ' + -height + ' L ' + x2 + ' ' + -height + ' L ' + x3 + ' 0';\n          } else {\n            verticesPath = 'L 0 0 L ' + x2 + ' ' + -height + ' L ' + x3 + ' 0';\n          }\n          var trapezoid = {\n            label: 'Trapezoid Body',\n            position: {\n              x: x,\n              y: y\n            },\n            vertices: Vertices.fromPath(verticesPath)\n          };\n          if (options.chamfer) {\n            var chamfer = options.chamfer;\n            trapezoid.vertices = Vertices.chamfer(trapezoid.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n            delete options.chamfer;\n          }\n          return Body.create(Common.extend({}, trapezoid, options));\n        };\n\n        /**\n         * Creates a new rigid body model with a circle hull. \n         * The options parameter is an object that specifies any properties you wish to override the defaults.\n         * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n         * @method circle\n         * @param {number} x\n         * @param {number} y\n         * @param {number} radius\n         * @param {object} [options]\n         * @param {number} [maxSides]\n         * @return {body} A new circle body\n         */\n        Bodies.circle = function (x, y, radius, options, maxSides) {\n          options = options || {};\n          var circle = {\n            label: 'Circle Body',\n            circleRadius: radius\n          };\n\n          // approximate circles with polygons until true circles implemented in SAT\n          maxSides = maxSides || 25;\n          var sides = Math.ceil(Math.max(10, Math.min(maxSides, radius)));\n\n          // optimisation: always use even number of sides (half the number of unique axes)\n          if (sides % 2 === 1) sides += 1;\n          return Bodies.polygon(x, y, sides, radius, Common.extend({}, circle, options));\n        };\n\n        /**\n         * Creates a new rigid body model with a regular polygon hull with the given number of sides. \n         * The options parameter is an object that specifies any properties you wish to override the defaults.\n         * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n         * @method polygon\n         * @param {number} x\n         * @param {number} y\n         * @param {number} sides\n         * @param {number} radius\n         * @param {object} [options]\n         * @return {body} A new regular polygon body\n         */\n        Bodies.polygon = function (x, y, sides, radius, options) {\n          options = options || {};\n          if (sides < 3) return Bodies.circle(x, y, radius, options);\n          var theta = 2 * Math.PI / sides,\n            path = '',\n            offset = theta * 0.5;\n          for (var i = 0; i < sides; i += 1) {\n            var angle = offset + i * theta,\n              xx = Math.cos(angle) * radius,\n              yy = Math.sin(angle) * radius;\n            path += 'L ' + xx.toFixed(3) + ' ' + yy.toFixed(3) + ' ';\n          }\n          var polygon = {\n            label: 'Polygon Body',\n            position: {\n              x: x,\n              y: y\n            },\n            vertices: Vertices.fromPath(path)\n          };\n          if (options.chamfer) {\n            var chamfer = options.chamfer;\n            polygon.vertices = Vertices.chamfer(polygon.vertices, chamfer.radius, chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n            delete options.chamfer;\n          }\n          return Body.create(Common.extend({}, polygon, options));\n        };\n\n        /**\n         * Utility to create a compound body based on set(s) of vertices.\n         * \n         * _Note:_ To optionally enable automatic concave vertices decomposition the [poly-decomp](https://github.com/schteppe/poly-decomp.js) \n         * package must be first installed and provided see `Common.setDecomp`, otherwise the convex hull of each vertex set will be used.\n         * \n         * The resulting vertices are reorientated about their centre of mass,\n         * and offset such that `body.position` corresponds to this point.\n         * \n         * The resulting offset may be found if needed by subtracting `body.bounds` from the original input bounds.\n         * To later move the centre of mass see `Body.setCentre`.\n         * \n         * Note that automatic conconcave decomposition results are not always optimal. \n         * For best results, simplify the input vertices as much as possible first.\n         * By default this function applies some addtional simplification to help.\n         * \n         * Some outputs may also require further manual processing afterwards to be robust.\n         * In particular some parts may need to be overlapped to avoid collision gaps.\n         * Thin parts and sharp points should be avoided or removed where possible.\n         *\n         * The options parameter object specifies any `Matter.Body` properties you wish to override the defaults.\n         * \n         * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n         * @method fromVertices\n         * @param {number} x\n         * @param {number} y\n         * @param {array} vertexSets One or more arrays of vertex points e.g. `[[{ x: 0, y: 0 }...], ...]`.\n         * @param {object} [options] The body options.\n         * @param {bool} [flagInternal=false] Optionally marks internal edges with `isInternal`.\n         * @param {number} [removeCollinear=0.01] Threshold when simplifying vertices along the same edge.\n         * @param {number} [minimumArea=10] Threshold when removing small parts.\n         * @param {number} [removeDuplicatePoints=0.01] Threshold when simplifying nearby vertices.\n         * @return {body}\n         */\n        Bodies.fromVertices = function (x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea, removeDuplicatePoints) {\n          var decomp = Common.getDecomp(),\n            canDecomp,\n            body,\n            parts,\n            isConvex,\n            isConcave,\n            vertices,\n            i,\n            j,\n            k,\n            v,\n            z;\n\n          // check decomp is as expected\n          canDecomp = Boolean(decomp && decomp.quickDecomp);\n          options = options || {};\n          parts = [];\n          flagInternal = typeof flagInternal !== 'undefined' ? flagInternal : false;\n          removeCollinear = typeof removeCollinear !== 'undefined' ? removeCollinear : 0.01;\n          minimumArea = typeof minimumArea !== 'undefined' ? minimumArea : 10;\n          removeDuplicatePoints = typeof removeDuplicatePoints !== 'undefined' ? removeDuplicatePoints : 0.01;\n\n          // ensure vertexSets is an array of arrays\n          if (!Common.isArray(vertexSets[0])) {\n            vertexSets = [vertexSets];\n          }\n          for (v = 0; v < vertexSets.length; v += 1) {\n            vertices = vertexSets[v];\n            isConvex = Vertices.isConvex(vertices);\n            isConcave = !isConvex;\n            if (isConcave && !canDecomp) {\n              Common.warnOnce('Bodies.fromVertices: Install the \\'poly-decomp\\' library and use Common.setDecomp or provide \\'decomp\\' as a global to decompose concave vertices.');\n            }\n            if (isConvex || !canDecomp) {\n              if (isConvex) {\n                vertices = Vertices.clockwiseSort(vertices);\n              } else {\n                // fallback to convex hull when decomposition is not possible\n                vertices = Vertices.hull(vertices);\n              }\n              parts.push({\n                position: {\n                  x: x,\n                  y: y\n                },\n                vertices: vertices\n              });\n            } else {\n              // initialise a decomposition\n              var concave = vertices.map(function (vertex) {\n                return [vertex.x, vertex.y];\n              });\n\n              // vertices are concave and simple, we can decompose into parts\n              decomp.makeCCW(concave);\n              if (removeCollinear !== false) decomp.removeCollinearPoints(concave, removeCollinear);\n              if (removeDuplicatePoints !== false && decomp.removeDuplicatePoints) decomp.removeDuplicatePoints(concave, removeDuplicatePoints);\n\n              // use the quick decomposition algorithm (Bayazit)\n              var decomposed = decomp.quickDecomp(concave);\n\n              // for each decomposed chunk\n              for (i = 0; i < decomposed.length; i++) {\n                var chunk = decomposed[i];\n\n                // convert vertices into the correct structure\n                var chunkVertices = chunk.map(function (vertices) {\n                  return {\n                    x: vertices[0],\n                    y: vertices[1]\n                  };\n                });\n\n                // skip small chunks\n                if (minimumArea > 0 && Vertices.area(chunkVertices) < minimumArea) continue;\n\n                // create a compound part\n                parts.push({\n                  position: Vertices.centre(chunkVertices),\n                  vertices: chunkVertices\n                });\n              }\n            }\n          }\n\n          // create body parts\n          for (i = 0; i < parts.length; i++) {\n            parts[i] = Body.create(Common.extend(parts[i], options));\n          }\n\n          // flag internal edges (coincident part edges)\n          if (flagInternal) {\n            var coincident_max_dist = 5;\n            for (i = 0; i < parts.length; i++) {\n              var partA = parts[i];\n              for (j = i + 1; j < parts.length; j++) {\n                var partB = parts[j];\n                if (Bounds.overlaps(partA.bounds, partB.bounds)) {\n                  var pav = partA.vertices,\n                    pbv = partB.vertices;\n\n                  // iterate vertices of both parts\n                  for (k = 0; k < partA.vertices.length; k++) {\n                    for (z = 0; z < partB.vertices.length; z++) {\n                      // find distances between the vertices\n                      var da = Vector.magnitudeSquared(Vector.sub(pav[(k + 1) % pav.length], pbv[z])),\n                        db = Vector.magnitudeSquared(Vector.sub(pav[k], pbv[(z + 1) % pbv.length]));\n\n                      // if both vertices are very close, consider the edge concident (internal)\n                      if (da < coincident_max_dist && db < coincident_max_dist) {\n                        pav[k].isInternal = true;\n                        pbv[z].isInternal = true;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n          if (parts.length > 1) {\n            // create the parent body to be returned, that contains generated compound parts\n            body = Body.create(Common.extend({\n              parts: parts.slice(0)\n            }, options));\n\n            // offset such that body.position is at the centre off mass\n            Body.setPosition(body, {\n              x: x,\n              y: y\n            });\n            return body;\n          } else {\n            return parts[0];\n          }\n        };\n      })();\n\n      /***/\n    }, /* 13 */\n    /***/function (module, exports, __nested_webpack_require_190325__) {\n      /**\n      * The `Matter.Detector` module contains methods for efficiently detecting collisions between a list of bodies using a broadphase algorithm.\n      *\n      * @class Detector\n      */\n\n      var Detector = {};\n      module.exports = Detector;\n      var Common = __nested_webpack_require_190325__(0);\n      var Collision = __nested_webpack_require_190325__(8);\n      (function () {\n        /**\n         * Creates a new collision detector.\n         * @method create\n         * @param {} options\n         * @return {detector} A new collision detector\n         */\n        Detector.create = function (options) {\n          var defaults = {\n            bodies: [],\n            pairs: null\n          };\n          return Common.extend(defaults, options);\n        };\n\n        /**\n         * Sets the list of bodies in the detector.\n         * @method setBodies\n         * @param {detector} detector\n         * @param {body[]} bodies\n         */\n        Detector.setBodies = function (detector, bodies) {\n          detector.bodies = bodies.slice(0);\n        };\n\n        /**\n         * Clears the detector including its list of bodies.\n         * @method clear\n         * @param {detector} detector\n         */\n        Detector.clear = function (detector) {\n          detector.bodies = [];\n        };\n\n        /**\n         * Efficiently finds all collisions among all the bodies in `detector.bodies` using a broadphase algorithm.\n         * \n         * _Note:_ The specific ordering of collisions returned is not guaranteed between releases and may change for performance reasons.\n         * If a specific ordering is required then apply a sort to the resulting array.\n         * @method collisions\n         * @param {detector} detector\n         * @return {collision[]} collisions\n         */\n        Detector.collisions = function (detector) {\n          var collisions = [],\n            pairs = detector.pairs,\n            bodies = detector.bodies,\n            bodiesLength = bodies.length,\n            canCollide = Detector.canCollide,\n            collides = Collision.collides,\n            i,\n            j;\n          bodies.sort(Detector._compareBoundsX);\n          for (i = 0; i < bodiesLength; i++) {\n            var bodyA = bodies[i],\n              boundsA = bodyA.bounds,\n              boundXMax = bodyA.bounds.max.x,\n              boundYMax = bodyA.bounds.max.y,\n              boundYMin = bodyA.bounds.min.y,\n              bodyAStatic = bodyA.isStatic || bodyA.isSleeping,\n              partsALength = bodyA.parts.length,\n              partsASingle = partsALength === 1;\n            for (j = i + 1; j < bodiesLength; j++) {\n              var bodyB = bodies[j],\n                boundsB = bodyB.bounds;\n              if (boundsB.min.x > boundXMax) {\n                break;\n              }\n              if (boundYMax < boundsB.min.y || boundYMin > boundsB.max.y) {\n                continue;\n              }\n              if (bodyAStatic && (bodyB.isStatic || bodyB.isSleeping)) {\n                continue;\n              }\n              if (!canCollide(bodyA.collisionFilter, bodyB.collisionFilter)) {\n                continue;\n              }\n              var partsBLength = bodyB.parts.length;\n              if (partsASingle && partsBLength === 1) {\n                var collision = collides(bodyA, bodyB, pairs);\n                if (collision) {\n                  collisions.push(collision);\n                }\n              } else {\n                var partsAStart = partsALength > 1 ? 1 : 0,\n                  partsBStart = partsBLength > 1 ? 1 : 0;\n                for (var k = partsAStart; k < partsALength; k++) {\n                  var partA = bodyA.parts[k],\n                    boundsA = partA.bounds;\n                  for (var z = partsBStart; z < partsBLength; z++) {\n                    var partB = bodyB.parts[z],\n                      boundsB = partB.bounds;\n                    if (boundsA.min.x > boundsB.max.x || boundsA.max.x < boundsB.min.x || boundsA.max.y < boundsB.min.y || boundsA.min.y > boundsB.max.y) {\n                      continue;\n                    }\n                    var collision = collides(partA, partB, pairs);\n                    if (collision) {\n                      collisions.push(collision);\n                    }\n                  }\n                }\n              }\n            }\n          }\n          return collisions;\n        };\n\n        /**\n         * Returns `true` if both supplied collision filters will allow a collision to occur.\n         * See `body.collisionFilter` for more information.\n         * @method canCollide\n         * @param {} filterA\n         * @param {} filterB\n         * @return {bool} `true` if collision can occur\n         */\n        Detector.canCollide = function (filterA, filterB) {\n          if (filterA.group === filterB.group && filterA.group !== 0) return filterA.group > 0;\n          return (filterA.mask & filterB.category) !== 0 && (filterB.mask & filterA.category) !== 0;\n        };\n\n        /**\n         * The comparison function used in the broadphase algorithm.\n         * Returns the signed delta of the bodies bounds on the x-axis.\n         * @private\n         * @method _sortCompare\n         * @param {body} bodyA\n         * @param {body} bodyB\n         * @return {number} The signed delta used for sorting\n         */\n        Detector._compareBoundsX = function (bodyA, bodyB) {\n          return bodyA.bounds.min.x - bodyB.bounds.min.x;\n        };\n\n        /*\n        *\n        *  Properties Documentation\n        *\n        */\n\n        /**\n         * The array of `Matter.Body` between which the detector finds collisions.\n         * \n         * _Note:_ The order of bodies in this array _is not fixed_ and will be continually managed by the detector.\n         * @property bodies\n         * @type body[]\n         * @default []\n         */\n\n        /**\n         * Optional. A `Matter.Pairs` object from which previous collision objects may be reused. Intended for internal `Matter.Engine` usage.\n         * @property pairs\n         * @type {pairs|null}\n         * @default null\n         */\n      })();\n\n      /***/\n    }, /* 14 */\n    /***/function (module, exports, __nested_webpack_require_196488__) {\n      /**\n      * The `Matter.Mouse` module contains methods for creating and manipulating mouse inputs.\n      *\n      * @class Mouse\n      */\n\n      var Mouse = {};\n      module.exports = Mouse;\n      var Common = __nested_webpack_require_196488__(0);\n      (function () {\n        /**\n         * Creates a mouse input.\n         * @method create\n         * @param {HTMLElement} element\n         * @return {mouse} A new mouse\n         */\n        Mouse.create = function (element) {\n          var mouse = {};\n          if (!element) {\n            Common.log('Mouse.create: element was undefined, defaulting to document.body', 'warn');\n          }\n          mouse.element = element || document.body;\n          mouse.absolute = {\n            x: 0,\n            y: 0\n          };\n          mouse.position = {\n            x: 0,\n            y: 0\n          };\n          mouse.mousedownPosition = {\n            x: 0,\n            y: 0\n          };\n          mouse.mouseupPosition = {\n            x: 0,\n            y: 0\n          };\n          mouse.offset = {\n            x: 0,\n            y: 0\n          };\n          mouse.scale = {\n            x: 1,\n            y: 1\n          };\n          mouse.wheelDelta = 0;\n          mouse.button = -1;\n          mouse.pixelRatio = parseInt(mouse.element.getAttribute('data-pixel-ratio'), 10) || 1;\n          mouse.sourceEvents = {\n            mousemove: null,\n            mousedown: null,\n            mouseup: null,\n            mousewheel: null\n          };\n          mouse.mousemove = function (event) {\n            var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),\n              touches = event.changedTouches;\n            if (touches) {\n              mouse.button = 0;\n              event.preventDefault();\n            }\n            mouse.absolute.x = position.x;\n            mouse.absolute.y = position.y;\n            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n            mouse.sourceEvents.mousemove = event;\n          };\n          mouse.mousedown = function (event) {\n            var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),\n              touches = event.changedTouches;\n            if (touches) {\n              mouse.button = 0;\n              event.preventDefault();\n            } else {\n              mouse.button = event.button;\n            }\n            mouse.absolute.x = position.x;\n            mouse.absolute.y = position.y;\n            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n            mouse.mousedownPosition.x = mouse.position.x;\n            mouse.mousedownPosition.y = mouse.position.y;\n            mouse.sourceEvents.mousedown = event;\n          };\n          mouse.mouseup = function (event) {\n            var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),\n              touches = event.changedTouches;\n            if (touches) {\n              event.preventDefault();\n            }\n            mouse.button = -1;\n            mouse.absolute.x = position.x;\n            mouse.absolute.y = position.y;\n            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n            mouse.mouseupPosition.x = mouse.position.x;\n            mouse.mouseupPosition.y = mouse.position.y;\n            mouse.sourceEvents.mouseup = event;\n          };\n          mouse.mousewheel = function (event) {\n            mouse.wheelDelta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail));\n            event.preventDefault();\n          };\n          Mouse.setElement(mouse, mouse.element);\n          return mouse;\n        };\n\n        /**\n         * Sets the element the mouse is bound to (and relative to).\n         * @method setElement\n         * @param {mouse} mouse\n         * @param {HTMLElement} element\n         */\n        Mouse.setElement = function (mouse, element) {\n          mouse.element = element;\n          element.addEventListener('mousemove', mouse.mousemove);\n          element.addEventListener('mousedown', mouse.mousedown);\n          element.addEventListener('mouseup', mouse.mouseup);\n          element.addEventListener('mousewheel', mouse.mousewheel);\n          element.addEventListener('DOMMouseScroll', mouse.mousewheel);\n          element.addEventListener('touchmove', mouse.mousemove);\n          element.addEventListener('touchstart', mouse.mousedown);\n          element.addEventListener('touchend', mouse.mouseup);\n        };\n\n        /**\n         * Clears all captured source events.\n         * @method clearSourceEvents\n         * @param {mouse} mouse\n         */\n        Mouse.clearSourceEvents = function (mouse) {\n          mouse.sourceEvents.mousemove = null;\n          mouse.sourceEvents.mousedown = null;\n          mouse.sourceEvents.mouseup = null;\n          mouse.sourceEvents.mousewheel = null;\n          mouse.wheelDelta = 0;\n        };\n\n        /**\n         * Sets the mouse position offset.\n         * @method setOffset\n         * @param {mouse} mouse\n         * @param {vector} offset\n         */\n        Mouse.setOffset = function (mouse, offset) {\n          mouse.offset.x = offset.x;\n          mouse.offset.y = offset.y;\n          mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n          mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n        };\n\n        /**\n         * Sets the mouse position scale.\n         * @method setScale\n         * @param {mouse} mouse\n         * @param {vector} scale\n         */\n        Mouse.setScale = function (mouse, scale) {\n          mouse.scale.x = scale.x;\n          mouse.scale.y = scale.y;\n          mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n          mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n        };\n\n        /**\n         * Gets the mouse position relative to an element given a screen pixel ratio.\n         * @method _getRelativeMousePosition\n         * @private\n         * @param {} event\n         * @param {} element\n         * @param {number} pixelRatio\n         * @return {}\n         */\n        Mouse._getRelativeMousePosition = function (event, element, pixelRatio) {\n          var elementBounds = element.getBoundingClientRect(),\n            rootNode = document.documentElement || document.body.parentNode || document.body,\n            scrollX = window.pageXOffset !== undefined ? window.pageXOffset : rootNode.scrollLeft,\n            scrollY = window.pageYOffset !== undefined ? window.pageYOffset : rootNode.scrollTop,\n            touches = event.changedTouches,\n            x,\n            y;\n          if (touches) {\n            x = touches[0].pageX - elementBounds.left - scrollX;\n            y = touches[0].pageY - elementBounds.top - scrollY;\n          } else {\n            x = event.pageX - elementBounds.left - scrollX;\n            y = event.pageY - elementBounds.top - scrollY;\n          }\n          return {\n            x: x / (element.clientWidth / (element.width || element.clientWidth) * pixelRatio),\n            y: y / (element.clientHeight / (element.height || element.clientHeight) * pixelRatio)\n          };\n        };\n      })();\n\n      /***/\n    }, /* 15 */\n    /***/function (module, exports, __nested_webpack_require_203980__) {\n      /**\n      * The `Matter.Plugin` module contains functions for registering and installing plugins on modules.\n      *\n      * @class Plugin\n      */\n\n      var Plugin = {};\n      module.exports = Plugin;\n      var Common = __nested_webpack_require_203980__(0);\n      (function () {\n        Plugin._registry = {};\n\n        /**\n         * Registers a plugin object so it can be resolved later by name.\n         * @method register\n         * @param plugin {} The plugin to register.\n         * @return {object} The plugin.\n         */\n        Plugin.register = function (plugin) {\n          if (!Plugin.isPlugin(plugin)) {\n            Common.warn('Plugin.register:', Plugin.toString(plugin), 'does not implement all required fields.');\n          }\n          if (plugin.name in Plugin._registry) {\n            var registered = Plugin._registry[plugin.name],\n              pluginVersion = Plugin.versionParse(plugin.version).number,\n              registeredVersion = Plugin.versionParse(registered.version).number;\n            if (pluginVersion > registeredVersion) {\n              Common.warn('Plugin.register:', Plugin.toString(registered), 'was upgraded to', Plugin.toString(plugin));\n              Plugin._registry[plugin.name] = plugin;\n            } else if (pluginVersion < registeredVersion) {\n              Common.warn('Plugin.register:', Plugin.toString(registered), 'can not be downgraded to', Plugin.toString(plugin));\n            } else if (plugin !== registered) {\n              Common.warn('Plugin.register:', Plugin.toString(plugin), 'is already registered to different plugin object');\n            }\n          } else {\n            Plugin._registry[plugin.name] = plugin;\n          }\n          return plugin;\n        };\n\n        /**\n         * Resolves a dependency to a plugin object from the registry if it exists. \n         * The `dependency` may contain a version, but only the name matters when resolving.\n         * @method resolve\n         * @param dependency {string} The dependency.\n         * @return {object} The plugin if resolved, otherwise `undefined`.\n         */\n        Plugin.resolve = function (dependency) {\n          return Plugin._registry[Plugin.dependencyParse(dependency).name];\n        };\n\n        /**\n         * Returns a pretty printed plugin name and version.\n         * @method toString\n         * @param plugin {} The plugin.\n         * @return {string} Pretty printed plugin name and version.\n         */\n        Plugin.toString = function (plugin) {\n          return typeof plugin === 'string' ? plugin : (plugin.name || 'anonymous') + '@' + (plugin.version || plugin.range || '0.0.0');\n        };\n\n        /**\n         * Returns `true` if the object meets the minimum standard to be considered a plugin.\n         * This means it must define the following properties:\n         * - `name`\n         * - `version`\n         * - `install`\n         * @method isPlugin\n         * @param obj {} The obj to test.\n         * @return {boolean} `true` if the object can be considered a plugin otherwise `false`.\n         */\n        Plugin.isPlugin = function (obj) {\n          return obj && obj.name && obj.version && obj.install;\n        };\n\n        /**\n         * Returns `true` if a plugin with the given `name` been installed on `module`.\n         * @method isUsed\n         * @param module {} The module.\n         * @param name {string} The plugin name.\n         * @return {boolean} `true` if a plugin with the given `name` been installed on `module`, otherwise `false`.\n         */\n        Plugin.isUsed = function (module, name) {\n          return module.used.indexOf(name) > -1;\n        };\n\n        /**\n         * Returns `true` if `plugin.for` is applicable to `module` by comparing against `module.name` and `module.version`.\n         * If `plugin.for` is not specified then it is assumed to be applicable.\n         * The value of `plugin.for` is a string of the format `'module-name'` or `'module-name@version'`.\n         * @method isFor\n         * @param plugin {} The plugin.\n         * @param module {} The module.\n         * @return {boolean} `true` if `plugin.for` is applicable to `module`, otherwise `false`.\n         */\n        Plugin.isFor = function (plugin, module) {\n          var parsed = plugin.for && Plugin.dependencyParse(plugin.for);\n          return !plugin.for || module.name === parsed.name && Plugin.versionSatisfies(module.version, parsed.range);\n        };\n\n        /**\n         * Installs the plugins by calling `plugin.install` on each plugin specified in `plugins` if passed, otherwise `module.uses`.\n         * For installing plugins on `Matter` see the convenience function `Matter.use`.\n         * Plugins may be specified either by their name or a reference to the plugin object.\n         * Plugins themselves may specify further dependencies, but each plugin is installed only once.\n         * Order is important, a topological sort is performed to find the best resulting order of installation.\n         * This sorting attempts to satisfy every dependency's requested ordering, but may not be exact in all cases.\n         * This function logs the resulting status of each dependency in the console, along with any warnings.\n         * - A green tick ✅ indicates a dependency was resolved and installed.\n         * - An orange diamond 🔶 indicates a dependency was resolved but a warning was thrown for it or one if its dependencies.\n         * - A red cross ❌ indicates a dependency could not be resolved.\n         * Avoid calling this function multiple times on the same module unless you intend to manually control installation order.\n         * @method use\n         * @param module {} The module install plugins on.\n         * @param [plugins=module.uses] {} The plugins to install on module (optional, defaults to `module.uses`).\n         */\n        Plugin.use = function (module, plugins) {\n          module.uses = (module.uses || []).concat(plugins || []);\n          if (module.uses.length === 0) {\n            Common.warn('Plugin.use:', Plugin.toString(module), 'does not specify any dependencies to install.');\n            return;\n          }\n          var dependencies = Plugin.dependencies(module),\n            sortedDependencies = Common.topologicalSort(dependencies),\n            status = [];\n          for (var i = 0; i < sortedDependencies.length; i += 1) {\n            if (sortedDependencies[i] === module.name) {\n              continue;\n            }\n            var plugin = Plugin.resolve(sortedDependencies[i]);\n            if (!plugin) {\n              status.push('❌ ' + sortedDependencies[i]);\n              continue;\n            }\n            if (Plugin.isUsed(module, plugin.name)) {\n              continue;\n            }\n            if (!Plugin.isFor(plugin, module)) {\n              Common.warn('Plugin.use:', Plugin.toString(plugin), 'is for', plugin.for, 'but installed on', Plugin.toString(module) + '.');\n              plugin._warned = true;\n            }\n            if (plugin.install) {\n              plugin.install(module);\n            } else {\n              Common.warn('Plugin.use:', Plugin.toString(plugin), 'does not specify an install function.');\n              plugin._warned = true;\n            }\n            if (plugin._warned) {\n              status.push('🔶 ' + Plugin.toString(plugin));\n              delete plugin._warned;\n            } else {\n              status.push('✅ ' + Plugin.toString(plugin));\n            }\n            module.used.push(plugin.name);\n          }\n          if (status.length > 0) {\n            Common.info(status.join('  '));\n          }\n        };\n\n        /**\n         * Recursively finds all of a module's dependencies and returns a flat dependency graph.\n         * @method dependencies\n         * @param module {} The module.\n         * @return {object} A dependency graph.\n         */\n        Plugin.dependencies = function (module, tracked) {\n          var parsedBase = Plugin.dependencyParse(module),\n            name = parsedBase.name;\n          tracked = tracked || {};\n          if (name in tracked) {\n            return;\n          }\n          module = Plugin.resolve(module) || module;\n          tracked[name] = Common.map(module.uses || [], function (dependency) {\n            if (Plugin.isPlugin(dependency)) {\n              Plugin.register(dependency);\n            }\n            var parsed = Plugin.dependencyParse(dependency),\n              resolved = Plugin.resolve(dependency);\n            if (resolved && !Plugin.versionSatisfies(resolved.version, parsed.range)) {\n              Common.warn('Plugin.dependencies:', Plugin.toString(resolved), 'does not satisfy', Plugin.toString(parsed), 'used by', Plugin.toString(parsedBase) + '.');\n              resolved._warned = true;\n              module._warned = true;\n            } else if (!resolved) {\n              Common.warn('Plugin.dependencies:', Plugin.toString(dependency), 'used by', Plugin.toString(parsedBase), 'could not be resolved.');\n              module._warned = true;\n            }\n            return parsed.name;\n          });\n          for (var i = 0; i < tracked[name].length; i += 1) {\n            Plugin.dependencies(tracked[name][i], tracked);\n          }\n          return tracked;\n        };\n\n        /**\n         * Parses a dependency string into its components.\n         * The `dependency` is a string of the format `'module-name'` or `'module-name@version'`.\n         * See documentation for `Plugin.versionParse` for a description of the format.\n         * This function can also handle dependencies that are already resolved (e.g. a module object).\n         * @method dependencyParse\n         * @param dependency {string} The dependency of the format `'module-name'` or `'module-name@version'`.\n         * @return {object} The dependency parsed into its components.\n         */\n        Plugin.dependencyParse = function (dependency) {\n          if (Common.isString(dependency)) {\n            var pattern = /^[\\w-]+(@(\\*|[\\^~]?\\d+\\.\\d+\\.\\d+(-[0-9A-Za-z-+]+)?))?$/;\n            if (!pattern.test(dependency)) {\n              Common.warn('Plugin.dependencyParse:', dependency, 'is not a valid dependency string.');\n            }\n            return {\n              name: dependency.split('@')[0],\n              range: dependency.split('@')[1] || '*'\n            };\n          }\n          return {\n            name: dependency.name,\n            range: dependency.range || dependency.version\n          };\n        };\n\n        /**\n         * Parses a version string into its components.  \n         * Versions are strictly of the format `x.y.z` (as in [semver](http://semver.org/)).\n         * Versions may optionally have a prerelease tag in the format `x.y.z-alpha`.\n         * Ranges are a strict subset of [npm ranges](https://docs.npmjs.com/misc/semver#advanced-range-syntax).\n         * Only the following range types are supported:\n         * - Tilde ranges e.g. `~1.2.3`\n         * - Caret ranges e.g. `^1.2.3`\n         * - Greater than ranges e.g. `>1.2.3`\n         * - Greater than or equal ranges e.g. `>=1.2.3`\n         * - Exact version e.g. `1.2.3`\n         * - Any version `*`\n         * @method versionParse\n         * @param range {string} The version string.\n         * @return {object} The version range parsed into its components.\n         */\n        Plugin.versionParse = function (range) {\n          var pattern = /^(\\*)|(\\^|~|>=|>)?\\s*((\\d+)\\.(\\d+)\\.(\\d+))(-[0-9A-Za-z-+]+)?$/;\n          if (!pattern.test(range)) {\n            Common.warn('Plugin.versionParse:', range, 'is not a valid version or range.');\n          }\n          var parts = pattern.exec(range);\n          var major = Number(parts[4]);\n          var minor = Number(parts[5]);\n          var patch = Number(parts[6]);\n          return {\n            isRange: Boolean(parts[1] || parts[2]),\n            version: parts[3],\n            range: range,\n            operator: parts[1] || parts[2] || '',\n            major: major,\n            minor: minor,\n            patch: patch,\n            parts: [major, minor, patch],\n            prerelease: parts[7],\n            number: major * 1e8 + minor * 1e4 + patch\n          };\n        };\n\n        /**\n         * Returns `true` if `version` satisfies the given `range`.\n         * See documentation for `Plugin.versionParse` for a description of the format.\n         * If a version or range is not specified, then any version (`*`) is assumed to satisfy.\n         * @method versionSatisfies\n         * @param version {string} The version string.\n         * @param range {string} The range string.\n         * @return {boolean} `true` if `version` satisfies `range`, otherwise `false`.\n         */\n        Plugin.versionSatisfies = function (version, range) {\n          range = range || '*';\n          var r = Plugin.versionParse(range),\n            v = Plugin.versionParse(version);\n          if (r.isRange) {\n            if (r.operator === '*' || version === '*') {\n              return true;\n            }\n            if (r.operator === '>') {\n              return v.number > r.number;\n            }\n            if (r.operator === '>=') {\n              return v.number >= r.number;\n            }\n            if (r.operator === '~') {\n              return v.major === r.major && v.minor === r.minor && v.patch >= r.patch;\n            }\n            if (r.operator === '^') {\n              if (r.major > 0) {\n                return v.major === r.major && v.number >= r.number;\n              }\n              if (r.minor > 0) {\n                return v.minor === r.minor && v.patch >= r.patch;\n              }\n              return v.patch === r.patch;\n            }\n          }\n          return version === range || version === '*';\n        };\n      })();\n\n      /***/\n    }, /* 16 */\n    /***/function (module, exports) {\n      /**\n      * The `Matter.Contact` module contains methods for creating and manipulating collision contacts.\n      *\n      * @class Contact\n      */\n\n      var Contact = {};\n      module.exports = Contact;\n      (function () {\n        /**\n         * Creates a new contact.\n         * @method create\n         * @param {vertex} vertex\n         * @return {contact} A new contact\n         */\n        Contact.create = function (vertex) {\n          return {\n            vertex: vertex,\n            normalImpulse: 0,\n            tangentImpulse: 0\n          };\n        };\n      })();\n\n      /***/\n    }, /* 17 */\n    /***/function (module, exports, __nested_webpack_require_218412__) {\n      /**\n      * The `Matter.Engine` module contains methods for creating and manipulating engines.\n      * An engine is a controller that manages updating the simulation of the world.\n      * See `Matter.Runner` for an optional game loop utility.\n      *\n      * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n      *\n      * @class Engine\n      */\n\n      var Engine = {};\n      module.exports = Engine;\n      var Sleeping = __nested_webpack_require_218412__(7);\n      var Resolver = __nested_webpack_require_218412__(18);\n      var Detector = __nested_webpack_require_218412__(13);\n      var Pairs = __nested_webpack_require_218412__(19);\n      var Events = __nested_webpack_require_218412__(5);\n      var Composite = __nested_webpack_require_218412__(6);\n      var Constraint = __nested_webpack_require_218412__(10);\n      var Common = __nested_webpack_require_218412__(0);\n      var Body = __nested_webpack_require_218412__(4);\n      (function () {\n        /**\n         * Creates a new engine. The options parameter is an object that specifies any properties you wish to override the defaults.\n         * All properties have default values, and many are pre-calculated automatically based on other properties.\n         * See the properties section below for detailed information on what you can pass via the `options` object.\n         * @method create\n         * @param {object} [options]\n         * @return {engine} engine\n         */\n        Engine.create = function (options) {\n          options = options || {};\n          var defaults = {\n            positionIterations: 6,\n            velocityIterations: 4,\n            constraintIterations: 2,\n            enableSleeping: false,\n            events: [],\n            plugin: {},\n            gravity: {\n              x: 0,\n              y: 1,\n              scale: 0.001\n            },\n            timing: {\n              timestamp: 0,\n              timeScale: 1,\n              lastDelta: 0,\n              lastElapsed: 0\n            }\n          };\n          var engine = Common.extend(defaults, options);\n          engine.world = options.world || Composite.create({\n            label: 'World'\n          });\n          engine.pairs = options.pairs || Pairs.create();\n          engine.detector = options.detector || Detector.create();\n\n          // for temporary back compatibility only\n          engine.grid = {\n            buckets: []\n          };\n          engine.world.gravity = engine.gravity;\n          engine.broadphase = engine.grid;\n          engine.metrics = {};\n          return engine;\n        };\n\n        /**\n         * Moves the simulation forward in time by `delta` milliseconds.\n         * Triggers `beforeUpdate` and `afterUpdate` events.\n         * Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.\n         * @method update\n         * @param {engine} engine\n         * @param {number} [delta=16.666]\n         */\n        Engine.update = function (engine, delta) {\n          var startTime = Common.now();\n          var world = engine.world,\n            detector = engine.detector,\n            pairs = engine.pairs,\n            timing = engine.timing,\n            timestamp = timing.timestamp,\n            i;\n          delta = typeof delta !== 'undefined' ? delta : Common._baseDelta;\n          delta *= timing.timeScale;\n\n          // increment timestamp\n          timing.timestamp += delta;\n          timing.lastDelta = delta;\n\n          // create an event object\n          var event = {\n            timestamp: timing.timestamp,\n            delta: delta\n          };\n          Events.trigger(engine, 'beforeUpdate', event);\n\n          // get all bodies and all constraints in the world\n          var allBodies = Composite.allBodies(world),\n            allConstraints = Composite.allConstraints(world);\n\n          // if the world has changed\n          if (world.isModified) {\n            // update the detector bodies\n            Detector.setBodies(detector, allBodies);\n\n            // reset all composite modified flags\n            Composite.setModified(world, false, false, true);\n          }\n\n          // update sleeping if enabled\n          if (engine.enableSleeping) Sleeping.update(allBodies, delta);\n\n          // apply gravity to all bodies\n          Engine._bodiesApplyGravity(allBodies, engine.gravity);\n\n          // update all body position and rotation by integration\n          if (delta > 0) {\n            Engine._bodiesUpdate(allBodies, delta);\n          }\n\n          // update all constraints (first pass)\n          Constraint.preSolveAll(allBodies);\n          for (i = 0; i < engine.constraintIterations; i++) {\n            Constraint.solveAll(allConstraints, delta);\n          }\n          Constraint.postSolveAll(allBodies);\n\n          // find all collisions\n          detector.pairs = engine.pairs;\n          var collisions = Detector.collisions(detector);\n\n          // update collision pairs\n          Pairs.update(pairs, collisions, timestamp);\n\n          // wake up bodies involved in collisions\n          if (engine.enableSleeping) Sleeping.afterCollisions(pairs.list);\n\n          // trigger collision events\n          if (pairs.collisionStart.length > 0) Events.trigger(engine, 'collisionStart', {\n            pairs: pairs.collisionStart\n          });\n\n          // iteratively resolve position between collisions\n          var positionDamping = Common.clamp(20 / engine.positionIterations, 0, 1);\n          Resolver.preSolvePosition(pairs.list);\n          for (i = 0; i < engine.positionIterations; i++) {\n            Resolver.solvePosition(pairs.list, delta, positionDamping);\n          }\n          Resolver.postSolvePosition(allBodies);\n\n          // update all constraints (second pass)\n          Constraint.preSolveAll(allBodies);\n          for (i = 0; i < engine.constraintIterations; i++) {\n            Constraint.solveAll(allConstraints, delta);\n          }\n          Constraint.postSolveAll(allBodies);\n\n          // iteratively resolve velocity between collisions\n          Resolver.preSolveVelocity(pairs.list);\n          for (i = 0; i < engine.velocityIterations; i++) {\n            Resolver.solveVelocity(pairs.list, delta);\n          }\n\n          // update body speed and velocity properties\n          Engine._bodiesUpdateVelocities(allBodies);\n\n          // trigger collision events\n          if (pairs.collisionActive.length > 0) Events.trigger(engine, 'collisionActive', {\n            pairs: pairs.collisionActive\n          });\n          if (pairs.collisionEnd.length > 0) Events.trigger(engine, 'collisionEnd', {\n            pairs: pairs.collisionEnd\n          });\n\n          // clear force buffers\n          Engine._bodiesClearForces(allBodies);\n          Events.trigger(engine, 'afterUpdate', event);\n\n          // log the time elapsed computing this update\n          engine.timing.lastElapsed = Common.now() - startTime;\n          return engine;\n        };\n\n        /**\n         * Merges two engines by keeping the configuration of `engineA` but replacing the world with the one from `engineB`.\n         * @method merge\n         * @param {engine} engineA\n         * @param {engine} engineB\n         */\n        Engine.merge = function (engineA, engineB) {\n          Common.extend(engineA, engineB);\n          if (engineB.world) {\n            engineA.world = engineB.world;\n            Engine.clear(engineA);\n            var bodies = Composite.allBodies(engineA.world);\n            for (var i = 0; i < bodies.length; i++) {\n              var body = bodies[i];\n              Sleeping.set(body, false);\n              body.id = Common.nextId();\n            }\n          }\n        };\n\n        /**\n         * Clears the engine pairs and detector.\n         * @method clear\n         * @param {engine} engine\n         */\n        Engine.clear = function (engine) {\n          Pairs.clear(engine.pairs);\n          Detector.clear(engine.detector);\n        };\n\n        /**\n         * Zeroes the `body.force` and `body.torque` force buffers.\n         * @method _bodiesClearForces\n         * @private\n         * @param {body[]} bodies\n         */\n        Engine._bodiesClearForces = function (bodies) {\n          var bodiesLength = bodies.length;\n          for (var i = 0; i < bodiesLength; i++) {\n            var body = bodies[i];\n\n            // reset force buffers\n            body.force.x = 0;\n            body.force.y = 0;\n            body.torque = 0;\n          }\n        };\n\n        /**\n         * Applies gravitational acceleration to all `bodies`.\n         * This models a [uniform gravitational field](https://en.wikipedia.org/wiki/Gravity_of_Earth), similar to near the surface of a planet.\n         * \n         * @method _bodiesApplyGravity\n         * @private\n         * @param {body[]} bodies\n         * @param {vector} gravity\n         */\n        Engine._bodiesApplyGravity = function (bodies, gravity) {\n          var gravityScale = typeof gravity.scale !== 'undefined' ? gravity.scale : 0.001,\n            bodiesLength = bodies.length;\n          if (gravity.x === 0 && gravity.y === 0 || gravityScale === 0) {\n            return;\n          }\n          for (var i = 0; i < bodiesLength; i++) {\n            var body = bodies[i];\n            if (body.isStatic || body.isSleeping) continue;\n\n            // add the resultant force of gravity\n            body.force.y += body.mass * gravity.y * gravityScale;\n            body.force.x += body.mass * gravity.x * gravityScale;\n          }\n        };\n\n        /**\n         * Applies `Body.update` to all given `bodies`.\n         * @method _bodiesUpdate\n         * @private\n         * @param {body[]} bodies\n         * @param {number} delta The amount of time elapsed between updates\n         */\n        Engine._bodiesUpdate = function (bodies, delta) {\n          var bodiesLength = bodies.length;\n          for (var i = 0; i < bodiesLength; i++) {\n            var body = bodies[i];\n            if (body.isStatic || body.isSleeping) continue;\n            Body.update(body, delta);\n          }\n        };\n\n        /**\n         * Applies `Body.updateVelocities` to all given `bodies`.\n         * @method _bodiesUpdateVelocities\n         * @private\n         * @param {body[]} bodies\n         */\n        Engine._bodiesUpdateVelocities = function (bodies) {\n          var bodiesLength = bodies.length;\n          for (var i = 0; i < bodiesLength; i++) {\n            Body.updateVelocities(bodies[i]);\n          }\n        };\n\n        /**\n         * A deprecated alias for `Runner.run`, use `Matter.Runner.run(engine)` instead and see `Matter.Runner` for more information.\n         * @deprecated use Matter.Runner.run(engine) instead\n         * @method run\n         * @param {engine} engine\n         */\n\n        /**\n        * Fired just before an update\n        *\n        * @event beforeUpdate\n        * @param {object} event An event object\n        * @param {number} event.timestamp The engine.timing.timestamp of the event\n        * @param {number} event.delta The delta time in milliseconds value used in the update\n        * @param {engine} event.source The source object of the event\n        * @param {string} event.name The name of the event\n        */\n\n        /**\n        * Fired after engine update and all collision events\n        *\n        * @event afterUpdate\n        * @param {object} event An event object\n        * @param {number} event.timestamp The engine.timing.timestamp of the event\n        * @param {number} event.delta The delta time in milliseconds value used in the update\n        * @param {engine} event.source The source object of the event\n        * @param {string} event.name The name of the event\n        */\n\n        /**\n        * Fired after engine update, provides a list of all pairs that have started to collide in the current tick (if any)\n        *\n        * @event collisionStart\n        * @param {object} event An event object\n        * @param {pair[]} event.pairs List of affected pairs\n        * @param {number} event.timestamp The engine.timing.timestamp of the event\n        * @param {number} event.delta The delta time in milliseconds value used in the update\n        * @param {engine} event.source The source object of the event\n        * @param {string} event.name The name of the event\n        */\n\n        /**\n        * Fired after engine update, provides a list of all pairs that are colliding in the current tick (if any)\n        *\n        * @event collisionActive\n        * @param {object} event An event object\n        * @param {pair[]} event.pairs List of affected pairs\n        * @param {number} event.timestamp The engine.timing.timestamp of the event\n        * @param {number} event.delta The delta time in milliseconds value used in the update\n        * @param {engine} event.source The source object of the event\n        * @param {string} event.name The name of the event\n        */\n\n        /**\n        * Fired after engine update, provides a list of all pairs that have ended collision in the current tick (if any)\n        *\n        * @event collisionEnd\n        * @param {object} event An event object\n        * @param {pair[]} event.pairs List of affected pairs\n        * @param {number} event.timestamp The engine.timing.timestamp of the event\n        * @param {number} event.delta The delta time in milliseconds value used in the update\n        * @param {engine} event.source The source object of the event\n        * @param {string} event.name The name of the event\n        */\n\n        /*\n        *\n        *  Properties Documentation\n        *\n        */\n\n        /**\n         * An integer `Number` that specifies the number of position iterations to perform each update.\n         * The higher the value, the higher quality the simulation will be at the expense of performance.\n         *\n         * @property positionIterations\n         * @type number\n         * @default 6\n         */\n\n        /**\n         * An integer `Number` that specifies the number of velocity iterations to perform each update.\n         * The higher the value, the higher quality the simulation will be at the expense of performance.\n         *\n         * @property velocityIterations\n         * @type number\n         * @default 4\n         */\n\n        /**\n         * An integer `Number` that specifies the number of constraint iterations to perform each update.\n         * The higher the value, the higher quality the simulation will be at the expense of performance.\n         * The default value of `2` is usually very adequate.\n         *\n         * @property constraintIterations\n         * @type number\n         * @default 2\n         */\n\n        /**\n         * A flag that specifies whether the engine should allow sleeping via the `Matter.Sleeping` module.\n         * Sleeping can improve stability and performance, but often at the expense of accuracy.\n         *\n         * @property enableSleeping\n         * @type boolean\n         * @default false\n         */\n\n        /**\n         * An `Object` containing properties regarding the timing systems of the engine. \n         *\n         * @property timing\n         * @type object\n         */\n\n        /**\n         * A `Number` that specifies the global scaling factor of time for all bodies.\n         * A value of `0` freezes the simulation.\n         * A value of `0.1` gives a slow-motion effect.\n         * A value of `1.2` gives a speed-up effect.\n         *\n         * @property timing.timeScale\n         * @type number\n         * @default 1\n         */\n\n        /**\n         * A `Number` that specifies the current simulation-time in milliseconds starting from `0`. \n         * It is incremented on every `Engine.update` by the given `delta` argument. \n         * \n         * @property timing.timestamp\n         * @type number\n         * @default 0\n         */\n\n        /**\n         * A `Number` that represents the total execution time elapsed during the last `Engine.update` in milliseconds.\n         * It is updated by timing from the start of the last `Engine.update` call until it ends.\n         *\n         * This value will also include the total execution time of all event handlers directly or indirectly triggered by the engine update.\n         * \n         * @property timing.lastElapsed\n         * @type number\n         * @default 0\n         */\n\n        /**\n         * A `Number` that represents the `delta` value used in the last engine update.\n         * \n         * @property timing.lastDelta\n         * @type number\n         * @default 0\n         */\n\n        /**\n         * A `Matter.Detector` instance.\n         *\n         * @property detector\n         * @type detector\n         * @default a Matter.Detector instance\n         */\n\n        /**\n         * A `Matter.Grid` instance.\n         *\n         * @deprecated replaced by `engine.detector`\n         * @property grid\n         * @type grid\n         * @default a Matter.Grid instance\n         */\n\n        /**\n         * Replaced by and now alias for `engine.grid`.\n         *\n         * @deprecated replaced by `engine.detector`\n         * @property broadphase\n         * @type grid\n         * @default a Matter.Grid instance\n         */\n\n        /**\n         * The root `Matter.Composite` instance that will contain all bodies, constraints and other composites to be simulated by this engine.\n         *\n         * @property world\n         * @type composite\n         * @default a Matter.Composite instance\n         */\n\n        /**\n         * An object reserved for storing plugin-specific properties.\n         *\n         * @property plugin\n         * @type {}\n         */\n\n        /**\n         * An optional gravitational acceleration applied to all bodies in `engine.world` on every update.\n         * \n         * This models a [uniform gravitational field](https://en.wikipedia.org/wiki/Gravity_of_Earth), similar to near the surface of a planet. For gravity in other contexts, disable this and apply forces as needed.\n         * \n         * To disable set the `scale` component to `0`.\n         * \n         * This is split into three components for ease of use:  \n         * a normalised direction (`x` and `y`) and magnitude (`scale`).\n         *\n         * @property gravity\n         * @type object\n         */\n\n        /**\n         * The gravitational direction normal `x` component, to be multiplied by `gravity.scale`.\n         * \n         * @property gravity.x\n         * @type object\n         * @default 0\n         */\n\n        /**\n         * The gravitational direction normal `y` component, to be multiplied by `gravity.scale`.\n         *\n         * @property gravity.y\n         * @type object\n         * @default 1\n         */\n\n        /**\n         * The magnitude of the gravitational acceleration.\n         * \n         * @property gravity.scale\n         * @type object\n         * @default 0.001\n         */\n      })();\n\n      /***/\n    }, /* 18 */\n    /***/function (module, exports, __nested_webpack_require_237188__) {\n      /**\n      * The `Matter.Resolver` module contains methods for resolving collision pairs.\n      *\n      * @class Resolver\n      */\n\n      var Resolver = {};\n      module.exports = Resolver;\n      var Vertices = __nested_webpack_require_237188__(3);\n      var Common = __nested_webpack_require_237188__(0);\n      var Bounds = __nested_webpack_require_237188__(1);\n      (function () {\n        Resolver._restingThresh = 2;\n        Resolver._restingThreshTangent = Math.sqrt(6);\n        Resolver._positionDampen = 0.9;\n        Resolver._positionWarming = 0.8;\n        Resolver._frictionNormalMultiplier = 5;\n        Resolver._frictionMaxStatic = Number.MAX_VALUE;\n\n        /**\n         * Prepare pairs for position solving.\n         * @method preSolvePosition\n         * @param {pair[]} pairs\n         */\n        Resolver.preSolvePosition = function (pairs) {\n          var i,\n            pair,\n            activeCount,\n            pairsLength = pairs.length;\n\n          // find total contacts on each body\n          for (i = 0; i < pairsLength; i++) {\n            pair = pairs[i];\n            if (!pair.isActive) continue;\n            activeCount = pair.activeContacts.length;\n            pair.collision.parentA.totalContacts += activeCount;\n            pair.collision.parentB.totalContacts += activeCount;\n          }\n        };\n\n        /**\n         * Find a solution for pair positions.\n         * @method solvePosition\n         * @param {pair[]} pairs\n         * @param {number} delta\n         * @param {number} [damping=1]\n         */\n        Resolver.solvePosition = function (pairs, delta, damping) {\n          var i,\n            pair,\n            collision,\n            bodyA,\n            bodyB,\n            normal,\n            contactShare,\n            positionImpulse,\n            positionDampen = Resolver._positionDampen * (damping || 1),\n            slopDampen = Common.clamp(delta / Common._baseDelta, 0, 1),\n            pairsLength = pairs.length;\n\n          // find impulses required to resolve penetration\n          for (i = 0; i < pairsLength; i++) {\n            pair = pairs[i];\n            if (!pair.isActive || pair.isSensor) continue;\n            collision = pair.collision;\n            bodyA = collision.parentA;\n            bodyB = collision.parentB;\n            normal = collision.normal;\n\n            // get current separation between body edges involved in collision\n            pair.separation = normal.x * (bodyB.positionImpulse.x + collision.penetration.x - bodyA.positionImpulse.x) + normal.y * (bodyB.positionImpulse.y + collision.penetration.y - bodyA.positionImpulse.y);\n          }\n          for (i = 0; i < pairsLength; i++) {\n            pair = pairs[i];\n            if (!pair.isActive || pair.isSensor) continue;\n            collision = pair.collision;\n            bodyA = collision.parentA;\n            bodyB = collision.parentB;\n            normal = collision.normal;\n            positionImpulse = pair.separation - pair.slop * slopDampen;\n            if (bodyA.isStatic || bodyB.isStatic) positionImpulse *= 2;\n            if (!(bodyA.isStatic || bodyA.isSleeping)) {\n              contactShare = positionDampen / bodyA.totalContacts;\n              bodyA.positionImpulse.x += normal.x * positionImpulse * contactShare;\n              bodyA.positionImpulse.y += normal.y * positionImpulse * contactShare;\n            }\n            if (!(bodyB.isStatic || bodyB.isSleeping)) {\n              contactShare = positionDampen / bodyB.totalContacts;\n              bodyB.positionImpulse.x -= normal.x * positionImpulse * contactShare;\n              bodyB.positionImpulse.y -= normal.y * positionImpulse * contactShare;\n            }\n          }\n        };\n\n        /**\n         * Apply position resolution.\n         * @method postSolvePosition\n         * @param {body[]} bodies\n         */\n        Resolver.postSolvePosition = function (bodies) {\n          var positionWarming = Resolver._positionWarming,\n            bodiesLength = bodies.length,\n            verticesTranslate = Vertices.translate,\n            boundsUpdate = Bounds.update;\n          for (var i = 0; i < bodiesLength; i++) {\n            var body = bodies[i],\n              positionImpulse = body.positionImpulse,\n              positionImpulseX = positionImpulse.x,\n              positionImpulseY = positionImpulse.y,\n              velocity = body.velocity;\n\n            // reset contact count\n            body.totalContacts = 0;\n            if (positionImpulseX !== 0 || positionImpulseY !== 0) {\n              // update body geometry\n              for (var j = 0; j < body.parts.length; j++) {\n                var part = body.parts[j];\n                verticesTranslate(part.vertices, positionImpulse);\n                boundsUpdate(part.bounds, part.vertices, velocity);\n                part.position.x += positionImpulseX;\n                part.position.y += positionImpulseY;\n              }\n\n              // move the body without changing velocity\n              body.positionPrev.x += positionImpulseX;\n              body.positionPrev.y += positionImpulseY;\n              if (positionImpulseX * velocity.x + positionImpulseY * velocity.y < 0) {\n                // reset cached impulse if the body has velocity along it\n                positionImpulse.x = 0;\n                positionImpulse.y = 0;\n              } else {\n                // warm the next iteration\n                positionImpulse.x *= positionWarming;\n                positionImpulse.y *= positionWarming;\n              }\n            }\n          }\n        };\n\n        /**\n         * Prepare pairs for velocity solving.\n         * @method preSolveVelocity\n         * @param {pair[]} pairs\n         */\n        Resolver.preSolveVelocity = function (pairs) {\n          var pairsLength = pairs.length,\n            i,\n            j;\n          for (i = 0; i < pairsLength; i++) {\n            var pair = pairs[i];\n            if (!pair.isActive || pair.isSensor) continue;\n            var contacts = pair.activeContacts,\n              contactsLength = contacts.length,\n              collision = pair.collision,\n              bodyA = collision.parentA,\n              bodyB = collision.parentB,\n              normal = collision.normal,\n              tangent = collision.tangent;\n\n            // resolve each contact\n            for (j = 0; j < contactsLength; j++) {\n              var contact = contacts[j],\n                contactVertex = contact.vertex,\n                normalImpulse = contact.normalImpulse,\n                tangentImpulse = contact.tangentImpulse;\n              if (normalImpulse !== 0 || tangentImpulse !== 0) {\n                // total impulse from contact\n                var impulseX = normal.x * normalImpulse + tangent.x * tangentImpulse,\n                  impulseY = normal.y * normalImpulse + tangent.y * tangentImpulse;\n\n                // apply impulse from contact\n                if (!(bodyA.isStatic || bodyA.isSleeping)) {\n                  bodyA.positionPrev.x += impulseX * bodyA.inverseMass;\n                  bodyA.positionPrev.y += impulseY * bodyA.inverseMass;\n                  bodyA.anglePrev += bodyA.inverseInertia * ((contactVertex.x - bodyA.position.x) * impulseY - (contactVertex.y - bodyA.position.y) * impulseX);\n                }\n                if (!(bodyB.isStatic || bodyB.isSleeping)) {\n                  bodyB.positionPrev.x -= impulseX * bodyB.inverseMass;\n                  bodyB.positionPrev.y -= impulseY * bodyB.inverseMass;\n                  bodyB.anglePrev -= bodyB.inverseInertia * ((contactVertex.x - bodyB.position.x) * impulseY - (contactVertex.y - bodyB.position.y) * impulseX);\n                }\n              }\n            }\n          }\n        };\n\n        /**\n         * Find a solution for pair velocities.\n         * @method solveVelocity\n         * @param {pair[]} pairs\n         * @param {number} delta\n         */\n        Resolver.solveVelocity = function (pairs, delta) {\n          var timeScale = delta / Common._baseDelta,\n            timeScaleSquared = timeScale * timeScale,\n            timeScaleCubed = timeScaleSquared * timeScale,\n            restingThresh = -Resolver._restingThresh * timeScale,\n            restingThreshTangent = Resolver._restingThreshTangent,\n            frictionNormalMultiplier = Resolver._frictionNormalMultiplier * timeScale,\n            frictionMaxStatic = Resolver._frictionMaxStatic,\n            pairsLength = pairs.length,\n            tangentImpulse,\n            maxFriction,\n            i,\n            j;\n          for (i = 0; i < pairsLength; i++) {\n            var pair = pairs[i];\n            if (!pair.isActive || pair.isSensor) continue;\n            var collision = pair.collision,\n              bodyA = collision.parentA,\n              bodyB = collision.parentB,\n              bodyAVelocity = bodyA.velocity,\n              bodyBVelocity = bodyB.velocity,\n              normalX = collision.normal.x,\n              normalY = collision.normal.y,\n              tangentX = collision.tangent.x,\n              tangentY = collision.tangent.y,\n              contacts = pair.activeContacts,\n              contactsLength = contacts.length,\n              contactShare = 1 / contactsLength,\n              inverseMassTotal = bodyA.inverseMass + bodyB.inverseMass,\n              friction = pair.friction * pair.frictionStatic * frictionNormalMultiplier;\n\n            // update body velocities\n            bodyAVelocity.x = bodyA.position.x - bodyA.positionPrev.x;\n            bodyAVelocity.y = bodyA.position.y - bodyA.positionPrev.y;\n            bodyBVelocity.x = bodyB.position.x - bodyB.positionPrev.x;\n            bodyBVelocity.y = bodyB.position.y - bodyB.positionPrev.y;\n            bodyA.angularVelocity = bodyA.angle - bodyA.anglePrev;\n            bodyB.angularVelocity = bodyB.angle - bodyB.anglePrev;\n\n            // resolve each contact\n            for (j = 0; j < contactsLength; j++) {\n              var contact = contacts[j],\n                contactVertex = contact.vertex;\n              var offsetAX = contactVertex.x - bodyA.position.x,\n                offsetAY = contactVertex.y - bodyA.position.y,\n                offsetBX = contactVertex.x - bodyB.position.x,\n                offsetBY = contactVertex.y - bodyB.position.y;\n              var velocityPointAX = bodyAVelocity.x - offsetAY * bodyA.angularVelocity,\n                velocityPointAY = bodyAVelocity.y + offsetAX * bodyA.angularVelocity,\n                velocityPointBX = bodyBVelocity.x - offsetBY * bodyB.angularVelocity,\n                velocityPointBY = bodyBVelocity.y + offsetBX * bodyB.angularVelocity;\n              var relativeVelocityX = velocityPointAX - velocityPointBX,\n                relativeVelocityY = velocityPointAY - velocityPointBY;\n              var normalVelocity = normalX * relativeVelocityX + normalY * relativeVelocityY,\n                tangentVelocity = tangentX * relativeVelocityX + tangentY * relativeVelocityY;\n\n              // coulomb friction\n              var normalOverlap = pair.separation + normalVelocity;\n              var normalForce = Math.min(normalOverlap, 1);\n              normalForce = normalOverlap < 0 ? 0 : normalForce;\n              var frictionLimit = normalForce * friction;\n              if (tangentVelocity < -frictionLimit || tangentVelocity > frictionLimit) {\n                maxFriction = tangentVelocity > 0 ? tangentVelocity : -tangentVelocity;\n                tangentImpulse = pair.friction * (tangentVelocity > 0 ? 1 : -1) * timeScaleCubed;\n                if (tangentImpulse < -maxFriction) {\n                  tangentImpulse = -maxFriction;\n                } else if (tangentImpulse > maxFriction) {\n                  tangentImpulse = maxFriction;\n                }\n              } else {\n                tangentImpulse = tangentVelocity;\n                maxFriction = frictionMaxStatic;\n              }\n\n              // account for mass, inertia and contact offset\n              var oAcN = offsetAX * normalY - offsetAY * normalX,\n                oBcN = offsetBX * normalY - offsetBY * normalX,\n                share = contactShare / (inverseMassTotal + bodyA.inverseInertia * oAcN * oAcN + bodyB.inverseInertia * oBcN * oBcN);\n\n              // raw impulses\n              var normalImpulse = (1 + pair.restitution) * normalVelocity * share;\n              tangentImpulse *= share;\n\n              // handle high velocity and resting collisions separately\n              if (normalVelocity < restingThresh) {\n                // high normal velocity so clear cached contact normal impulse\n                contact.normalImpulse = 0;\n              } else {\n                // solve resting collision constraints using Erin Catto's method (GDC08)\n                // impulse constraint tends to 0\n                var contactNormalImpulse = contact.normalImpulse;\n                contact.normalImpulse += normalImpulse;\n                if (contact.normalImpulse > 0) contact.normalImpulse = 0;\n                normalImpulse = contact.normalImpulse - contactNormalImpulse;\n              }\n\n              // handle high velocity and resting collisions separately\n              if (tangentVelocity < -restingThreshTangent || tangentVelocity > restingThreshTangent) {\n                // high tangent velocity so clear cached contact tangent impulse\n                contact.tangentImpulse = 0;\n              } else {\n                // solve resting collision constraints using Erin Catto's method (GDC08)\n                // tangent impulse tends to -tangentSpeed or +tangentSpeed\n                var contactTangentImpulse = contact.tangentImpulse;\n                contact.tangentImpulse += tangentImpulse;\n                if (contact.tangentImpulse < -maxFriction) contact.tangentImpulse = -maxFriction;\n                if (contact.tangentImpulse > maxFriction) contact.tangentImpulse = maxFriction;\n                tangentImpulse = contact.tangentImpulse - contactTangentImpulse;\n              }\n\n              // total impulse from contact\n              var impulseX = normalX * normalImpulse + tangentX * tangentImpulse,\n                impulseY = normalY * normalImpulse + tangentY * tangentImpulse;\n\n              // apply impulse from contact\n              if (!(bodyA.isStatic || bodyA.isSleeping)) {\n                bodyA.positionPrev.x += impulseX * bodyA.inverseMass;\n                bodyA.positionPrev.y += impulseY * bodyA.inverseMass;\n                bodyA.anglePrev += (offsetAX * impulseY - offsetAY * impulseX) * bodyA.inverseInertia;\n              }\n              if (!(bodyB.isStatic || bodyB.isSleeping)) {\n                bodyB.positionPrev.x -= impulseX * bodyB.inverseMass;\n                bodyB.positionPrev.y -= impulseY * bodyB.inverseMass;\n                bodyB.anglePrev -= (offsetBX * impulseY - offsetBY * impulseX) * bodyB.inverseInertia;\n              }\n            }\n          }\n        };\n      })();\n\n      /***/\n    }, /* 19 */\n    /***/function (module, exports, __nested_webpack_require_252065__) {\n      /**\n      * The `Matter.Pairs` module contains methods for creating and manipulating collision pair sets.\n      *\n      * @class Pairs\n      */\n\n      var Pairs = {};\n      module.exports = Pairs;\n      var Pair = __nested_webpack_require_252065__(9);\n      var Common = __nested_webpack_require_252065__(0);\n      (function () {\n        /**\n         * Creates a new pairs structure.\n         * @method create\n         * @param {object} options\n         * @return {pairs} A new pairs structure\n         */\n        Pairs.create = function (options) {\n          return Common.extend({\n            table: {},\n            list: [],\n            collisionStart: [],\n            collisionActive: [],\n            collisionEnd: []\n          }, options);\n        };\n\n        /**\n         * Updates pairs given a list of collisions.\n         * @method update\n         * @param {object} pairs\n         * @param {collision[]} collisions\n         * @param {number} timestamp\n         */\n        Pairs.update = function (pairs, collisions, timestamp) {\n          var pairsList = pairs.list,\n            pairsListLength = pairsList.length,\n            pairsTable = pairs.table,\n            collisionsLength = collisions.length,\n            collisionStart = pairs.collisionStart,\n            collisionEnd = pairs.collisionEnd,\n            collisionActive = pairs.collisionActive,\n            collision,\n            pairIndex,\n            pair,\n            i;\n\n          // clear collision state arrays, but maintain old reference\n          collisionStart.length = 0;\n          collisionEnd.length = 0;\n          collisionActive.length = 0;\n          for (i = 0; i < pairsListLength; i++) {\n            pairsList[i].confirmedActive = false;\n          }\n          for (i = 0; i < collisionsLength; i++) {\n            collision = collisions[i];\n            pair = collision.pair;\n            if (pair) {\n              // pair already exists (but may or may not be active)\n              if (pair.isActive) {\n                // pair exists and is active\n                collisionActive.push(pair);\n              } else {\n                // pair exists but was inactive, so a collision has just started again\n                collisionStart.push(pair);\n              }\n\n              // update the pair\n              Pair.update(pair, collision, timestamp);\n              pair.confirmedActive = true;\n            } else {\n              // pair did not exist, create a new pair\n              pair = Pair.create(collision, timestamp);\n              pairsTable[pair.id] = pair;\n\n              // push the new pair\n              collisionStart.push(pair);\n              pairsList.push(pair);\n            }\n          }\n\n          // find pairs that are no longer active\n          var removePairIndex = [];\n          pairsListLength = pairsList.length;\n          for (i = 0; i < pairsListLength; i++) {\n            pair = pairsList[i];\n            if (!pair.confirmedActive) {\n              Pair.setActive(pair, false, timestamp);\n              collisionEnd.push(pair);\n              if (!pair.collision.bodyA.isSleeping && !pair.collision.bodyB.isSleeping) {\n                removePairIndex.push(i);\n              }\n            }\n          }\n\n          // remove inactive pairs\n          for (i = 0; i < removePairIndex.length; i++) {\n            pairIndex = removePairIndex[i] - i;\n            pair = pairsList[pairIndex];\n            pairsList.splice(pairIndex, 1);\n            delete pairsTable[pair.id];\n          }\n        };\n\n        /**\n         * Clears the given pairs structure.\n         * @method clear\n         * @param {pairs} pairs\n         * @return {pairs} pairs\n         */\n        Pairs.clear = function (pairs) {\n          pairs.table = {};\n          pairs.list.length = 0;\n          pairs.collisionStart.length = 0;\n          pairs.collisionActive.length = 0;\n          pairs.collisionEnd.length = 0;\n          return pairs;\n        };\n      })();\n\n      /***/\n    }, /* 20 */\n    /***/function (module, exports, __nested_webpack_require_256070__) {\n      var Matter = module.exports = __nested_webpack_require_256070__(21);\n      Matter.Axes = __nested_webpack_require_256070__(11);\n      Matter.Bodies = __nested_webpack_require_256070__(12);\n      Matter.Body = __nested_webpack_require_256070__(4);\n      Matter.Bounds = __nested_webpack_require_256070__(1);\n      Matter.Collision = __nested_webpack_require_256070__(8);\n      Matter.Common = __nested_webpack_require_256070__(0);\n      Matter.Composite = __nested_webpack_require_256070__(6);\n      Matter.Composites = __nested_webpack_require_256070__(22);\n      Matter.Constraint = __nested_webpack_require_256070__(10);\n      Matter.Contact = __nested_webpack_require_256070__(16);\n      Matter.Detector = __nested_webpack_require_256070__(13);\n      Matter.Engine = __nested_webpack_require_256070__(17);\n      Matter.Events = __nested_webpack_require_256070__(5);\n      Matter.Grid = __nested_webpack_require_256070__(23);\n      Matter.Mouse = __nested_webpack_require_256070__(14);\n      Matter.MouseConstraint = __nested_webpack_require_256070__(24);\n      Matter.Pair = __nested_webpack_require_256070__(9);\n      Matter.Pairs = __nested_webpack_require_256070__(19);\n      Matter.Plugin = __nested_webpack_require_256070__(15);\n      Matter.Query = __nested_webpack_require_256070__(25);\n      Matter.Render = __nested_webpack_require_256070__(26);\n      Matter.Resolver = __nested_webpack_require_256070__(18);\n      Matter.Runner = __nested_webpack_require_256070__(27);\n      Matter.SAT = __nested_webpack_require_256070__(28);\n      Matter.Sleeping = __nested_webpack_require_256070__(7);\n      Matter.Svg = __nested_webpack_require_256070__(29);\n      Matter.Vector = __nested_webpack_require_256070__(2);\n      Matter.Vertices = __nested_webpack_require_256070__(3);\n      Matter.World = __nested_webpack_require_256070__(30);\n\n      // temporary back compatibility\n      Matter.Engine.run = Matter.Runner.run;\n      Matter.Common.deprecated(Matter.Engine, 'run', 'Engine.run ➤ use Matter.Runner.run(engine) instead');\n\n      /***/\n    }, /* 21 */\n    /***/function (module, exports, __nested_webpack_require_257778__) {\n      /**\r\n      * The `Matter` module is the top level namespace. It also includes a function for installing plugins on top of the library.\r\n      *\r\n      * @class Matter\r\n      */\n\n      var Matter = {};\n      module.exports = Matter;\n      var Plugin = __nested_webpack_require_257778__(15);\n      var Common = __nested_webpack_require_257778__(0);\n      (function () {\n        /**\r\n         * The library name.\r\n         * @property name\r\n         * @readOnly\r\n         * @type {String}\r\n         */\n        Matter.name = 'matter-js';\n\n        /**\r\n         * The library version.\r\n         * @property version\r\n         * @readOnly\r\n         * @type {String}\r\n         */\n        Matter.version =  true ? \"0.19.0\" : 0;\n\n        /**\r\n         * A list of plugin dependencies to be installed. These are normally set and installed through `Matter.use`.\r\n         * Alternatively you may set `Matter.uses` manually and install them by calling `Plugin.use(Matter)`.\r\n         * @property uses\r\n         * @type {Array}\r\n         */\n        Matter.uses = [];\n\n        /**\r\n         * The plugins that have been installed through `Matter.Plugin.install`. Read only.\r\n         * @property used\r\n         * @readOnly\r\n         * @type {Array}\r\n         */\n        Matter.used = [];\n\n        /**\r\n         * Installs the given plugins on the `Matter` namespace.\r\n         * This is a short-hand for `Plugin.use`, see it for more information.\r\n         * Call this function once at the start of your code, with all of the plugins you wish to install as arguments.\r\n         * Avoid calling this function multiple times unless you intend to manually control installation order.\r\n         * @method use\r\n         * @param ...plugin {Function} The plugin(s) to install on `base` (multi-argument).\r\n         */\n        Matter.use = function () {\n          Plugin.use(Matter, Array.prototype.slice.call(arguments));\n        };\n\n        /**\r\n         * Chains a function to excute before the original function on the given `path` relative to `Matter`.\r\n         * See also docs for `Common.chain`.\r\n         * @method before\r\n         * @param {string} path The path relative to `Matter`\r\n         * @param {function} func The function to chain before the original\r\n         * @return {function} The chained function that replaced the original\r\n         */\n        Matter.before = function (path, func) {\n          path = path.replace(/^Matter./, '');\n          return Common.chainPathBefore(Matter, path, func);\n        };\n\n        /**\r\n         * Chains a function to excute after the original function on the given `path` relative to `Matter`.\r\n         * See also docs for `Common.chain`.\r\n         * @method after\r\n         * @param {string} path The path relative to `Matter`\r\n         * @param {function} func The function to chain after the original\r\n         * @return {function} The chained function that replaced the original\r\n         */\n        Matter.after = function (path, func) {\n          path = path.replace(/^Matter./, '');\n          return Common.chainPathAfter(Matter, path, func);\n        };\n      })();\n\n      /***/\n    }, /* 22 */\n    /***/function (module, exports, __nested_webpack_require_260961__) {\n      /**\n      * The `Matter.Composites` module contains factory methods for creating composite bodies\n      * with commonly used configurations (such as stacks and chains).\n      *\n      * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n      *\n      * @class Composites\n      */\n\n      var Composites = {};\n      module.exports = Composites;\n      var Composite = __nested_webpack_require_260961__(6);\n      var Constraint = __nested_webpack_require_260961__(10);\n      var Common = __nested_webpack_require_260961__(0);\n      var Body = __nested_webpack_require_260961__(4);\n      var Bodies = __nested_webpack_require_260961__(12);\n      var deprecated = Common.deprecated;\n      (function () {\n        /**\n         * Create a new composite containing bodies created in the callback in a grid arrangement.\n         * This function uses the body's bounds to prevent overlaps.\n         * @method stack\n         * @param {number} xx\n         * @param {number} yy\n         * @param {number} columns\n         * @param {number} rows\n         * @param {number} columnGap\n         * @param {number} rowGap\n         * @param {function} callback\n         * @return {composite} A new composite containing objects created in the callback\n         */\n        Composites.stack = function (xx, yy, columns, rows, columnGap, rowGap, callback) {\n          var stack = Composite.create({\n              label: 'Stack'\n            }),\n            x = xx,\n            y = yy,\n            lastBody,\n            i = 0;\n          for (var row = 0; row < rows; row++) {\n            var maxHeight = 0;\n            for (var column = 0; column < columns; column++) {\n              var body = callback(x, y, column, row, lastBody, i);\n              if (body) {\n                var bodyHeight = body.bounds.max.y - body.bounds.min.y,\n                  bodyWidth = body.bounds.max.x - body.bounds.min.x;\n                if (bodyHeight > maxHeight) maxHeight = bodyHeight;\n                Body.translate(body, {\n                  x: bodyWidth * 0.5,\n                  y: bodyHeight * 0.5\n                });\n                x = body.bounds.max.x + columnGap;\n                Composite.addBody(stack, body);\n                lastBody = body;\n                i += 1;\n              } else {\n                x += columnGap;\n              }\n            }\n            y += maxHeight + rowGap;\n            x = xx;\n          }\n          return stack;\n        };\n\n        /**\n         * Chains all bodies in the given composite together using constraints.\n         * @method chain\n         * @param {composite} composite\n         * @param {number} xOffsetA\n         * @param {number} yOffsetA\n         * @param {number} xOffsetB\n         * @param {number} yOffsetB\n         * @param {object} options\n         * @return {composite} A new composite containing objects chained together with constraints\n         */\n        Composites.chain = function (composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {\n          var bodies = composite.bodies;\n          for (var i = 1; i < bodies.length; i++) {\n            var bodyA = bodies[i - 1],\n              bodyB = bodies[i],\n              bodyAHeight = bodyA.bounds.max.y - bodyA.bounds.min.y,\n              bodyAWidth = bodyA.bounds.max.x - bodyA.bounds.min.x,\n              bodyBHeight = bodyB.bounds.max.y - bodyB.bounds.min.y,\n              bodyBWidth = bodyB.bounds.max.x - bodyB.bounds.min.x;\n            var defaults = {\n              bodyA: bodyA,\n              pointA: {\n                x: bodyAWidth * xOffsetA,\n                y: bodyAHeight * yOffsetA\n              },\n              bodyB: bodyB,\n              pointB: {\n                x: bodyBWidth * xOffsetB,\n                y: bodyBHeight * yOffsetB\n              }\n            };\n            var constraint = Common.extend(defaults, options);\n            Composite.addConstraint(composite, Constraint.create(constraint));\n          }\n          composite.label += ' Chain';\n          return composite;\n        };\n\n        /**\n         * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.\n         * @method mesh\n         * @param {composite} composite\n         * @param {number} columns\n         * @param {number} rows\n         * @param {boolean} crossBrace\n         * @param {object} options\n         * @return {composite} The composite containing objects meshed together with constraints\n         */\n        Composites.mesh = function (composite, columns, rows, crossBrace, options) {\n          var bodies = composite.bodies,\n            row,\n            col,\n            bodyA,\n            bodyB,\n            bodyC;\n          for (row = 0; row < rows; row++) {\n            for (col = 1; col < columns; col++) {\n              bodyA = bodies[col - 1 + row * columns];\n              bodyB = bodies[col + row * columns];\n              Composite.addConstraint(composite, Constraint.create(Common.extend({\n                bodyA: bodyA,\n                bodyB: bodyB\n              }, options)));\n            }\n            if (row > 0) {\n              for (col = 0; col < columns; col++) {\n                bodyA = bodies[col + (row - 1) * columns];\n                bodyB = bodies[col + row * columns];\n                Composite.addConstraint(composite, Constraint.create(Common.extend({\n                  bodyA: bodyA,\n                  bodyB: bodyB\n                }, options)));\n                if (crossBrace && col > 0) {\n                  bodyC = bodies[col - 1 + (row - 1) * columns];\n                  Composite.addConstraint(composite, Constraint.create(Common.extend({\n                    bodyA: bodyC,\n                    bodyB: bodyB\n                  }, options)));\n                }\n                if (crossBrace && col < columns - 1) {\n                  bodyC = bodies[col + 1 + (row - 1) * columns];\n                  Composite.addConstraint(composite, Constraint.create(Common.extend({\n                    bodyA: bodyC,\n                    bodyB: bodyB\n                  }, options)));\n                }\n              }\n            }\n          }\n          composite.label += ' Mesh';\n          return composite;\n        };\n\n        /**\n         * Create a new composite containing bodies created in the callback in a pyramid arrangement.\n         * This function uses the body's bounds to prevent overlaps.\n         * @method pyramid\n         * @param {number} xx\n         * @param {number} yy\n         * @param {number} columns\n         * @param {number} rows\n         * @param {number} columnGap\n         * @param {number} rowGap\n         * @param {function} callback\n         * @return {composite} A new composite containing objects created in the callback\n         */\n        Composites.pyramid = function (xx, yy, columns, rows, columnGap, rowGap, callback) {\n          return Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function (x, y, column, row, lastBody, i) {\n            var actualRows = Math.min(rows, Math.ceil(columns / 2)),\n              lastBodyWidth = lastBody ? lastBody.bounds.max.x - lastBody.bounds.min.x : 0;\n            if (row > actualRows) return;\n\n            // reverse row order\n            row = actualRows - row;\n            var start = row,\n              end = columns - 1 - row;\n            if (column < start || column > end) return;\n\n            // retroactively fix the first body's position, since width was unknown\n            if (i === 1) {\n              Body.translate(lastBody, {\n                x: (column + (columns % 2 === 1 ? 1 : -1)) * lastBodyWidth,\n                y: 0\n              });\n            }\n            var xOffset = lastBody ? column * lastBodyWidth : 0;\n            return callback(xx + xOffset + column * columnGap, y, column, row, lastBody, i);\n          });\n        };\n\n        /**\n         * This has now moved to the [newtonsCradle example](https://github.com/liabru/matter-js/blob/master/examples/newtonsCradle.js), follow that instead as this function is deprecated here.\n         * @deprecated moved to newtonsCradle example\n         * @method newtonsCradle\n         * @param {number} xx\n         * @param {number} yy\n         * @param {number} number\n         * @param {number} size\n         * @param {number} length\n         * @return {composite} A new composite newtonsCradle body\n         */\n        Composites.newtonsCradle = function (xx, yy, number, size, length) {\n          var newtonsCradle = Composite.create({\n            label: 'Newtons Cradle'\n          });\n          for (var i = 0; i < number; i++) {\n            var separation = 1.9,\n              circle = Bodies.circle(xx + i * (size * separation), yy + length, size, {\n                inertia: Infinity,\n                restitution: 1,\n                friction: 0,\n                frictionAir: 0.0001,\n                slop: 1\n              }),\n              constraint = Constraint.create({\n                pointA: {\n                  x: xx + i * (size * separation),\n                  y: yy\n                },\n                bodyB: circle\n              });\n            Composite.addBody(newtonsCradle, circle);\n            Composite.addConstraint(newtonsCradle, constraint);\n          }\n          return newtonsCradle;\n        };\n        deprecated(Composites, 'newtonsCradle', 'Composites.newtonsCradle ➤ moved to newtonsCradle example');\n\n        /**\n         * This has now moved to the [car example](https://github.com/liabru/matter-js/blob/master/examples/car.js), follow that instead as this function is deprecated here.\n         * @deprecated moved to car example\n         * @method car\n         * @param {number} xx\n         * @param {number} yy\n         * @param {number} width\n         * @param {number} height\n         * @param {number} wheelSize\n         * @return {composite} A new composite car body\n         */\n        Composites.car = function (xx, yy, width, height, wheelSize) {\n          var group = Body.nextGroup(true),\n            wheelBase = 20,\n            wheelAOffset = -width * 0.5 + wheelBase,\n            wheelBOffset = width * 0.5 - wheelBase,\n            wheelYOffset = 0;\n          var car = Composite.create({\n              label: 'Car'\n            }),\n            body = Bodies.rectangle(xx, yy, width, height, {\n              collisionFilter: {\n                group: group\n              },\n              chamfer: {\n                radius: height * 0.5\n              },\n              density: 0.0002\n            });\n          var wheelA = Bodies.circle(xx + wheelAOffset, yy + wheelYOffset, wheelSize, {\n            collisionFilter: {\n              group: group\n            },\n            friction: 0.8\n          });\n          var wheelB = Bodies.circle(xx + wheelBOffset, yy + wheelYOffset, wheelSize, {\n            collisionFilter: {\n              group: group\n            },\n            friction: 0.8\n          });\n          var axelA = Constraint.create({\n            bodyB: body,\n            pointB: {\n              x: wheelAOffset,\n              y: wheelYOffset\n            },\n            bodyA: wheelA,\n            stiffness: 1,\n            length: 0\n          });\n          var axelB = Constraint.create({\n            bodyB: body,\n            pointB: {\n              x: wheelBOffset,\n              y: wheelYOffset\n            },\n            bodyA: wheelB,\n            stiffness: 1,\n            length: 0\n          });\n          Composite.addBody(car, body);\n          Composite.addBody(car, wheelA);\n          Composite.addBody(car, wheelB);\n          Composite.addConstraint(car, axelA);\n          Composite.addConstraint(car, axelB);\n          return car;\n        };\n        deprecated(Composites, 'car', 'Composites.car ➤ moved to car example');\n\n        /**\n         * This has now moved to the [softBody example](https://github.com/liabru/matter-js/blob/master/examples/softBody.js)\n         * and the [cloth example](https://github.com/liabru/matter-js/blob/master/examples/cloth.js), follow those instead as this function is deprecated here.\n         * @deprecated moved to softBody and cloth examples\n         * @method softBody\n         * @param {number} xx\n         * @param {number} yy\n         * @param {number} columns\n         * @param {number} rows\n         * @param {number} columnGap\n         * @param {number} rowGap\n         * @param {boolean} crossBrace\n         * @param {number} particleRadius\n         * @param {} particleOptions\n         * @param {} constraintOptions\n         * @return {composite} A new composite softBody\n         */\n        Composites.softBody = function (xx, yy, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {\n          particleOptions = Common.extend({\n            inertia: Infinity\n          }, particleOptions);\n          constraintOptions = Common.extend({\n            stiffness: 0.2,\n            render: {\n              type: 'line',\n              anchors: false\n            }\n          }, constraintOptions);\n          var softBody = Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function (x, y) {\n            return Bodies.circle(x, y, particleRadius, particleOptions);\n          });\n          Composites.mesh(softBody, columns, rows, crossBrace, constraintOptions);\n          softBody.label = 'Soft Body';\n          return softBody;\n        };\n        deprecated(Composites, 'softBody', 'Composites.softBody ➤ moved to softBody and cloth examples');\n      })();\n\n      /***/\n    }, /* 23 */\n    /***/function (module, exports, __nested_webpack_require_274441__) {\n      /**\n      * This module has now been replaced by `Matter.Detector`.\n      *\n      * All usage should be migrated to `Matter.Detector` or another alternative.\n      * For back-compatibility purposes this module will remain for a short term and then later removed in a future release.\n      *\n      * The `Matter.Grid` module contains methods for creating and manipulating collision broadphase grid structures.\n      *\n      * @class Grid\n      * @deprecated\n      */\n\n      var Grid = {};\n      module.exports = Grid;\n      var Pair = __nested_webpack_require_274441__(9);\n      var Common = __nested_webpack_require_274441__(0);\n      var deprecated = Common.deprecated;\n      (function () {\n        /**\n         * Creates a new grid.\n         * @deprecated replaced by Matter.Detector\n         * @method create\n         * @param {} options\n         * @return {grid} A new grid\n         */\n        Grid.create = function (options) {\n          var defaults = {\n            buckets: {},\n            pairs: {},\n            pairsList: [],\n            bucketWidth: 48,\n            bucketHeight: 48\n          };\n          return Common.extend(defaults, options);\n        };\n\n        /**\n         * The width of a single grid bucket.\n         *\n         * @property bucketWidth\n         * @type number\n         * @default 48\n         */\n\n        /**\n         * The height of a single grid bucket.\n         *\n         * @property bucketHeight\n         * @type number\n         * @default 48\n         */\n\n        /**\n         * Updates the grid.\n         * @deprecated replaced by Matter.Detector\n         * @method update\n         * @param {grid} grid\n         * @param {body[]} bodies\n         * @param {engine} engine\n         * @param {boolean} forceUpdate\n         */\n        Grid.update = function (grid, bodies, engine, forceUpdate) {\n          var i,\n            col,\n            row,\n            world = engine.world,\n            buckets = grid.buckets,\n            bucket,\n            bucketId,\n            gridChanged = false;\n          for (i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n            if (body.isSleeping && !forceUpdate) continue;\n\n            // temporary back compatibility bounds check\n            if (world.bounds && (body.bounds.max.x < world.bounds.min.x || body.bounds.min.x > world.bounds.max.x || body.bounds.max.y < world.bounds.min.y || body.bounds.min.y > world.bounds.max.y)) continue;\n            var newRegion = Grid._getRegion(grid, body);\n\n            // if the body has changed grid region\n            if (!body.region || newRegion.id !== body.region.id || forceUpdate) {\n              if (!body.region || forceUpdate) body.region = newRegion;\n              var union = Grid._regionUnion(newRegion, body.region);\n\n              // update grid buckets affected by region change\n              // iterate over the union of both regions\n              for (col = union.startCol; col <= union.endCol; col++) {\n                for (row = union.startRow; row <= union.endRow; row++) {\n                  bucketId = Grid._getBucketId(col, row);\n                  bucket = buckets[bucketId];\n                  var isInsideNewRegion = col >= newRegion.startCol && col <= newRegion.endCol && row >= newRegion.startRow && row <= newRegion.endRow;\n                  var isInsideOldRegion = col >= body.region.startCol && col <= body.region.endCol && row >= body.region.startRow && row <= body.region.endRow;\n\n                  // remove from old region buckets\n                  if (!isInsideNewRegion && isInsideOldRegion) {\n                    if (isInsideOldRegion) {\n                      if (bucket) Grid._bucketRemoveBody(grid, bucket, body);\n                    }\n                  }\n\n                  // add to new region buckets\n                  if (body.region === newRegion || isInsideNewRegion && !isInsideOldRegion || forceUpdate) {\n                    if (!bucket) bucket = Grid._createBucket(buckets, bucketId);\n                    Grid._bucketAddBody(grid, bucket, body);\n                  }\n                }\n              }\n\n              // set the new region\n              body.region = newRegion;\n\n              // flag changes so we can update pairs\n              gridChanged = true;\n            }\n          }\n\n          // update pairs list only if pairs changed (i.e. a body changed region)\n          if (gridChanged) grid.pairsList = Grid._createActivePairsList(grid);\n        };\n        deprecated(Grid, 'update', 'Grid.update ➤ replaced by Matter.Detector');\n\n        /**\n         * Clears the grid.\n         * @deprecated replaced by Matter.Detector\n         * @method clear\n         * @param {grid} grid\n         */\n        Grid.clear = function (grid) {\n          grid.buckets = {};\n          grid.pairs = {};\n          grid.pairsList = [];\n        };\n        deprecated(Grid, 'clear', 'Grid.clear ➤ replaced by Matter.Detector');\n\n        /**\n         * Finds the union of two regions.\n         * @method _regionUnion\n         * @deprecated replaced by Matter.Detector\n         * @private\n         * @param {} regionA\n         * @param {} regionB\n         * @return {} region\n         */\n        Grid._regionUnion = function (regionA, regionB) {\n          var startCol = Math.min(regionA.startCol, regionB.startCol),\n            endCol = Math.max(regionA.endCol, regionB.endCol),\n            startRow = Math.min(regionA.startRow, regionB.startRow),\n            endRow = Math.max(regionA.endRow, regionB.endRow);\n          return Grid._createRegion(startCol, endCol, startRow, endRow);\n        };\n\n        /**\n         * Gets the region a given body falls in for a given grid.\n         * @method _getRegion\n         * @deprecated replaced by Matter.Detector\n         * @private\n         * @param {} grid\n         * @param {} body\n         * @return {} region\n         */\n        Grid._getRegion = function (grid, body) {\n          var bounds = body.bounds,\n            startCol = Math.floor(bounds.min.x / grid.bucketWidth),\n            endCol = Math.floor(bounds.max.x / grid.bucketWidth),\n            startRow = Math.floor(bounds.min.y / grid.bucketHeight),\n            endRow = Math.floor(bounds.max.y / grid.bucketHeight);\n          return Grid._createRegion(startCol, endCol, startRow, endRow);\n        };\n\n        /**\n         * Creates a region.\n         * @method _createRegion\n         * @deprecated replaced by Matter.Detector\n         * @private\n         * @param {} startCol\n         * @param {} endCol\n         * @param {} startRow\n         * @param {} endRow\n         * @return {} region\n         */\n        Grid._createRegion = function (startCol, endCol, startRow, endRow) {\n          return {\n            id: startCol + ',' + endCol + ',' + startRow + ',' + endRow,\n            startCol: startCol,\n            endCol: endCol,\n            startRow: startRow,\n            endRow: endRow\n          };\n        };\n\n        /**\n         * Gets the bucket id at the given position.\n         * @method _getBucketId\n         * @deprecated replaced by Matter.Detector\n         * @private\n         * @param {} column\n         * @param {} row\n         * @return {string} bucket id\n         */\n        Grid._getBucketId = function (column, row) {\n          return 'C' + column + 'R' + row;\n        };\n\n        /**\n         * Creates a bucket.\n         * @method _createBucket\n         * @deprecated replaced by Matter.Detector\n         * @private\n         * @param {} buckets\n         * @param {} bucketId\n         * @return {} bucket\n         */\n        Grid._createBucket = function (buckets, bucketId) {\n          var bucket = buckets[bucketId] = [];\n          return bucket;\n        };\n\n        /**\n         * Adds a body to a bucket.\n         * @method _bucketAddBody\n         * @deprecated replaced by Matter.Detector\n         * @private\n         * @param {} grid\n         * @param {} bucket\n         * @param {} body\n         */\n        Grid._bucketAddBody = function (grid, bucket, body) {\n          var gridPairs = grid.pairs,\n            pairId = Pair.id,\n            bucketLength = bucket.length,\n            i;\n\n          // add new pairs\n          for (i = 0; i < bucketLength; i++) {\n            var bodyB = bucket[i];\n            if (body.id === bodyB.id || body.isStatic && bodyB.isStatic) continue;\n\n            // keep track of the number of buckets the pair exists in\n            // important for Grid.update to work\n            var id = pairId(body, bodyB),\n              pair = gridPairs[id];\n            if (pair) {\n              pair[2] += 1;\n            } else {\n              gridPairs[id] = [body, bodyB, 1];\n            }\n          }\n\n          // add to bodies (after pairs, otherwise pairs with self)\n          bucket.push(body);\n        };\n\n        /**\n         * Removes a body from a bucket.\n         * @method _bucketRemoveBody\n         * @deprecated replaced by Matter.Detector\n         * @private\n         * @param {} grid\n         * @param {} bucket\n         * @param {} body\n         */\n        Grid._bucketRemoveBody = function (grid, bucket, body) {\n          var gridPairs = grid.pairs,\n            pairId = Pair.id,\n            i;\n\n          // remove from bucket\n          bucket.splice(Common.indexOf(bucket, body), 1);\n          var bucketLength = bucket.length;\n\n          // update pair counts\n          for (i = 0; i < bucketLength; i++) {\n            // keep track of the number of buckets the pair exists in\n            // important for _createActivePairsList to work\n            var pair = gridPairs[pairId(body, bucket[i])];\n            if (pair) pair[2] -= 1;\n          }\n        };\n\n        /**\n         * Generates a list of the active pairs in the grid.\n         * @method _createActivePairsList\n         * @deprecated replaced by Matter.Detector\n         * @private\n         * @param {} grid\n         * @return [] pairs\n         */\n        Grid._createActivePairsList = function (grid) {\n          var pair,\n            gridPairs = grid.pairs,\n            pairKeys = Common.keys(gridPairs),\n            pairKeysLength = pairKeys.length,\n            pairs = [],\n            k;\n\n          // iterate over grid.pairs\n          for (k = 0; k < pairKeysLength; k++) {\n            pair = gridPairs[pairKeys[k]];\n\n            // if pair exists in at least one bucket\n            // it is a pair that needs further collision testing so push it\n            if (pair[2] > 0) {\n              pairs.push(pair);\n            } else {\n              delete gridPairs[pairKeys[k]];\n            }\n          }\n          return pairs;\n        };\n      })();\n\n      /***/\n    }, /* 24 */\n    /***/function (module, exports, __nested_webpack_require_285078__) {\n      /**\n      * The `Matter.MouseConstraint` module contains methods for creating mouse constraints.\n      * Mouse constraints are used for allowing user interaction, providing the ability to move bodies via the mouse or touch.\n      *\n      * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n      *\n      * @class MouseConstraint\n      */\n\n      var MouseConstraint = {};\n      module.exports = MouseConstraint;\n      var Vertices = __nested_webpack_require_285078__(3);\n      var Sleeping = __nested_webpack_require_285078__(7);\n      var Mouse = __nested_webpack_require_285078__(14);\n      var Events = __nested_webpack_require_285078__(5);\n      var Detector = __nested_webpack_require_285078__(13);\n      var Constraint = __nested_webpack_require_285078__(10);\n      var Composite = __nested_webpack_require_285078__(6);\n      var Common = __nested_webpack_require_285078__(0);\n      var Bounds = __nested_webpack_require_285078__(1);\n      (function () {\n        /**\n         * Creates a new mouse constraint.\n         * All properties have default values, and many are pre-calculated automatically based on other properties.\n         * See the properties section below for detailed information on what you can pass via the `options` object.\n         * @method create\n         * @param {engine} engine\n         * @param {} options\n         * @return {MouseConstraint} A new MouseConstraint\n         */\n        MouseConstraint.create = function (engine, options) {\n          var mouse = (engine ? engine.mouse : null) || (options ? options.mouse : null);\n          if (!mouse) {\n            if (engine && engine.render && engine.render.canvas) {\n              mouse = Mouse.create(engine.render.canvas);\n            } else if (options && options.element) {\n              mouse = Mouse.create(options.element);\n            } else {\n              mouse = Mouse.create();\n              Common.warn('MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected');\n            }\n          }\n          var constraint = Constraint.create({\n            label: 'Mouse Constraint',\n            pointA: mouse.position,\n            pointB: {\n              x: 0,\n              y: 0\n            },\n            length: 0.01,\n            stiffness: 0.1,\n            angularStiffness: 1,\n            render: {\n              strokeStyle: '#90EE90',\n              lineWidth: 3\n            }\n          });\n          var defaults = {\n            type: 'mouseConstraint',\n            mouse: mouse,\n            element: null,\n            body: null,\n            constraint: constraint,\n            collisionFilter: {\n              category: 0x0001,\n              mask: 0xFFFFFFFF,\n              group: 0\n            }\n          };\n          var mouseConstraint = Common.extend(defaults, options);\n          Events.on(engine, 'beforeUpdate', function () {\n            var allBodies = Composite.allBodies(engine.world);\n            MouseConstraint.update(mouseConstraint, allBodies);\n            MouseConstraint._triggerEvents(mouseConstraint);\n          });\n          return mouseConstraint;\n        };\n\n        /**\n         * Updates the given mouse constraint.\n         * @private\n         * @method update\n         * @param {MouseConstraint} mouseConstraint\n         * @param {body[]} bodies\n         */\n        MouseConstraint.update = function (mouseConstraint, bodies) {\n          var mouse = mouseConstraint.mouse,\n            constraint = mouseConstraint.constraint,\n            body = mouseConstraint.body;\n          if (mouse.button === 0) {\n            if (!constraint.bodyB) {\n              for (var i = 0; i < bodies.length; i++) {\n                body = bodies[i];\n                if (Bounds.contains(body.bounds, mouse.position) && Detector.canCollide(body.collisionFilter, mouseConstraint.collisionFilter)) {\n                  for (var j = body.parts.length > 1 ? 1 : 0; j < body.parts.length; j++) {\n                    var part = body.parts[j];\n                    if (Vertices.contains(part.vertices, mouse.position)) {\n                      constraint.pointA = mouse.position;\n                      constraint.bodyB = mouseConstraint.body = body;\n                      constraint.pointB = {\n                        x: mouse.position.x - body.position.x,\n                        y: mouse.position.y - body.position.y\n                      };\n                      constraint.angleB = body.angle;\n                      Sleeping.set(body, false);\n                      Events.trigger(mouseConstraint, 'startdrag', {\n                        mouse: mouse,\n                        body: body\n                      });\n                      break;\n                    }\n                  }\n                }\n              }\n            } else {\n              Sleeping.set(constraint.bodyB, false);\n              constraint.pointA = mouse.position;\n            }\n          } else {\n            constraint.bodyB = mouseConstraint.body = null;\n            constraint.pointB = null;\n            if (body) Events.trigger(mouseConstraint, 'enddrag', {\n              mouse: mouse,\n              body: body\n            });\n          }\n        };\n\n        /**\n         * Triggers mouse constraint events.\n         * @method _triggerEvents\n         * @private\n         * @param {mouse} mouseConstraint\n         */\n        MouseConstraint._triggerEvents = function (mouseConstraint) {\n          var mouse = mouseConstraint.mouse,\n            mouseEvents = mouse.sourceEvents;\n          if (mouseEvents.mousemove) Events.trigger(mouseConstraint, 'mousemove', {\n            mouse: mouse\n          });\n          if (mouseEvents.mousedown) Events.trigger(mouseConstraint, 'mousedown', {\n            mouse: mouse\n          });\n          if (mouseEvents.mouseup) Events.trigger(mouseConstraint, 'mouseup', {\n            mouse: mouse\n          });\n\n          // reset the mouse state ready for the next step\n          Mouse.clearSourceEvents(mouse);\n        };\n\n        /*\n        *\n        *  Events Documentation\n        *\n        */\n\n        /**\n        * Fired when the mouse has moved (or a touch moves) during the last step\n        *\n        * @event mousemove\n        * @param {} event An event object\n        * @param {mouse} event.mouse The engine's mouse instance\n        * @param {} event.source The source object of the event\n        * @param {} event.name The name of the event\n        */\n\n        /**\n        * Fired when the mouse is down (or a touch has started) during the last step\n        *\n        * @event mousedown\n        * @param {} event An event object\n        * @param {mouse} event.mouse The engine's mouse instance\n        * @param {} event.source The source object of the event\n        * @param {} event.name The name of the event\n        */\n\n        /**\n        * Fired when the mouse is up (or a touch has ended) during the last step\n        *\n        * @event mouseup\n        * @param {} event An event object\n        * @param {mouse} event.mouse The engine's mouse instance\n        * @param {} event.source The source object of the event\n        * @param {} event.name The name of the event\n        */\n\n        /**\n        * Fired when the user starts dragging a body\n        *\n        * @event startdrag\n        * @param {} event An event object\n        * @param {mouse} event.mouse The engine's mouse instance\n        * @param {body} event.body The body being dragged\n        * @param {} event.source The source object of the event\n        * @param {} event.name The name of the event\n        */\n\n        /**\n        * Fired when the user ends dragging a body\n        *\n        * @event enddrag\n        * @param {} event An event object\n        * @param {mouse} event.mouse The engine's mouse instance\n        * @param {body} event.body The body that has stopped being dragged\n        * @param {} event.source The source object of the event\n        * @param {} event.name The name of the event\n        */\n\n        /*\n        *\n        *  Properties Documentation\n        *\n        */\n\n        /**\n         * A `String` denoting the type of object.\n         *\n         * @property type\n         * @type string\n         * @default \"constraint\"\n         * @readOnly\n         */\n\n        /**\n         * The `Mouse` instance in use. If not supplied in `MouseConstraint.create`, one will be created.\n         *\n         * @property mouse\n         * @type mouse\n         * @default mouse\n         */\n\n        /**\n         * The `Body` that is currently being moved by the user, or `null` if no body.\n         *\n         * @property body\n         * @type body\n         * @default null\n         */\n\n        /**\n         * The `Constraint` object that is used to move the body during interaction.\n         *\n         * @property constraint\n         * @type constraint\n         */\n\n        /**\n         * An `Object` that specifies the collision filter properties.\n         * The collision filter allows the user to define which types of body this mouse constraint can interact with.\n         * See `body.collisionFilter` for more information.\n         *\n         * @property collisionFilter\n         * @type object\n         */\n      })();\n\n      /***/\n    }, /* 25 */\n    /***/function (module, exports, __nested_webpack_require_294281__) {\n      /**\n      * The `Matter.Query` module contains methods for performing collision queries.\n      *\n      * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n      *\n      * @class Query\n      */\n\n      var Query = {};\n      module.exports = Query;\n      var Vector = __nested_webpack_require_294281__(2);\n      var Collision = __nested_webpack_require_294281__(8);\n      var Bounds = __nested_webpack_require_294281__(1);\n      var Bodies = __nested_webpack_require_294281__(12);\n      var Vertices = __nested_webpack_require_294281__(3);\n      (function () {\n        /**\n         * Returns a list of collisions between `body` and `bodies`.\n         * @method collides\n         * @param {body} body\n         * @param {body[]} bodies\n         * @return {collision[]} Collisions\n         */\n        Query.collides = function (body, bodies) {\n          var collisions = [],\n            bodiesLength = bodies.length,\n            bounds = body.bounds,\n            collides = Collision.collides,\n            overlaps = Bounds.overlaps;\n          for (var i = 0; i < bodiesLength; i++) {\n            var bodyA = bodies[i],\n              partsALength = bodyA.parts.length,\n              partsAStart = partsALength === 1 ? 0 : 1;\n            if (overlaps(bodyA.bounds, bounds)) {\n              for (var j = partsAStart; j < partsALength; j++) {\n                var part = bodyA.parts[j];\n                if (overlaps(part.bounds, bounds)) {\n                  var collision = collides(part, body);\n                  if (collision) {\n                    collisions.push(collision);\n                    break;\n                  }\n                }\n              }\n            }\n          }\n          return collisions;\n        };\n\n        /**\n         * Casts a ray segment against a set of bodies and returns all collisions, ray width is optional. Intersection points are not provided.\n         * @method ray\n         * @param {body[]} bodies\n         * @param {vector} startPoint\n         * @param {vector} endPoint\n         * @param {number} [rayWidth]\n         * @return {collision[]} Collisions\n         */\n        Query.ray = function (bodies, startPoint, endPoint, rayWidth) {\n          rayWidth = rayWidth || 1e-100;\n          var rayAngle = Vector.angle(startPoint, endPoint),\n            rayLength = Vector.magnitude(Vector.sub(startPoint, endPoint)),\n            rayX = (endPoint.x + startPoint.x) * 0.5,\n            rayY = (endPoint.y + startPoint.y) * 0.5,\n            ray = Bodies.rectangle(rayX, rayY, rayLength, rayWidth, {\n              angle: rayAngle\n            }),\n            collisions = Query.collides(ray, bodies);\n          for (var i = 0; i < collisions.length; i += 1) {\n            var collision = collisions[i];\n            collision.body = collision.bodyB = collision.bodyA;\n          }\n          return collisions;\n        };\n\n        /**\n         * Returns all bodies whose bounds are inside (or outside if set) the given set of bounds, from the given set of bodies.\n         * @method region\n         * @param {body[]} bodies\n         * @param {bounds} bounds\n         * @param {bool} [outside=false]\n         * @return {body[]} The bodies matching the query\n         */\n        Query.region = function (bodies, bounds, outside) {\n          var result = [];\n          for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n              overlaps = Bounds.overlaps(body.bounds, bounds);\n            if (overlaps && !outside || !overlaps && outside) result.push(body);\n          }\n          return result;\n        };\n\n        /**\n         * Returns all bodies whose vertices contain the given point, from the given set of bodies.\n         * @method point\n         * @param {body[]} bodies\n         * @param {vector} point\n         * @return {body[]} The bodies matching the query\n         */\n        Query.point = function (bodies, point) {\n          var result = [];\n          for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n            if (Bounds.contains(body.bounds, point)) {\n              for (var j = body.parts.length === 1 ? 0 : 1; j < body.parts.length; j++) {\n                var part = body.parts[j];\n                if (Bounds.contains(part.bounds, point) && Vertices.contains(part.vertices, point)) {\n                  result.push(body);\n                  break;\n                }\n              }\n            }\n          }\n          return result;\n        };\n      })();\n\n      /***/\n    }, /* 26 */\n    /***/function (module, exports, __nested_webpack_require_298800__) {\n      /**\n      * The `Matter.Render` module is a simple canvas based renderer for visualising instances of `Matter.Engine`.\n      * It is intended for development and debugging purposes, but may also be suitable for simple games.\n      * It includes a number of drawing options including wireframe, vector with support for sprites and viewports.\n      *\n      * @class Render\n      */\n\n      var Render = {};\n      module.exports = Render;\n      var Body = __nested_webpack_require_298800__(4);\n      var Common = __nested_webpack_require_298800__(0);\n      var Composite = __nested_webpack_require_298800__(6);\n      var Bounds = __nested_webpack_require_298800__(1);\n      var Events = __nested_webpack_require_298800__(5);\n      var Vector = __nested_webpack_require_298800__(2);\n      var Mouse = __nested_webpack_require_298800__(14);\n      (function () {\n        var _requestAnimationFrame, _cancelAnimationFrame;\n        if (typeof window !== 'undefined') {\n          _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {\n            window.setTimeout(function () {\n              callback(Common.now());\n            }, 1000 / 60);\n          };\n          _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;\n        }\n        Render._goodFps = 30;\n        Render._goodDelta = 1000 / 60;\n\n        /**\n         * Creates a new renderer. The options parameter is an object that specifies any properties you wish to override the defaults.\n         * All properties have default values, and many are pre-calculated automatically based on other properties.\n         * See the properties section below for detailed information on what you can pass via the `options` object.\n         * @method create\n         * @param {object} [options]\n         * @return {render} A new renderer\n         */\n        Render.create = function (options) {\n          var defaults = {\n            engine: null,\n            element: null,\n            canvas: null,\n            mouse: null,\n            frameRequestId: null,\n            timing: {\n              historySize: 60,\n              delta: 0,\n              deltaHistory: [],\n              lastTime: 0,\n              lastTimestamp: 0,\n              lastElapsed: 0,\n              timestampElapsed: 0,\n              timestampElapsedHistory: [],\n              engineDeltaHistory: [],\n              engineElapsedHistory: [],\n              elapsedHistory: []\n            },\n            options: {\n              width: 800,\n              height: 600,\n              pixelRatio: 1,\n              background: '#14151f',\n              wireframeBackground: '#14151f',\n              hasBounds: !!options.bounds,\n              enabled: true,\n              wireframes: true,\n              showSleeping: true,\n              showDebug: false,\n              showStats: false,\n              showPerformance: false,\n              showBounds: false,\n              showVelocity: false,\n              showCollisions: false,\n              showSeparations: false,\n              showAxes: false,\n              showPositions: false,\n              showAngleIndicator: false,\n              showIds: false,\n              showVertexNumbers: false,\n              showConvexHulls: false,\n              showInternalEdges: false,\n              showMousePosition: false\n            }\n          };\n          var render = Common.extend(defaults, options);\n          if (render.canvas) {\n            render.canvas.width = render.options.width || render.canvas.width;\n            render.canvas.height = render.options.height || render.canvas.height;\n          }\n          render.mouse = options.mouse;\n          render.engine = options.engine;\n          render.canvas = render.canvas || _createCanvas(render.options.width, render.options.height);\n          render.context = render.canvas.getContext('2d');\n          render.textures = {};\n          render.bounds = render.bounds || {\n            min: {\n              x: 0,\n              y: 0\n            },\n            max: {\n              x: render.canvas.width,\n              y: render.canvas.height\n            }\n          };\n\n          // for temporary back compatibility only\n          render.controller = Render;\n          render.options.showBroadphase = false;\n          if (render.options.pixelRatio !== 1) {\n            Render.setPixelRatio(render, render.options.pixelRatio);\n          }\n          if (Common.isElement(render.element)) {\n            render.element.appendChild(render.canvas);\n          }\n          return render;\n        };\n\n        /**\n         * Continuously updates the render canvas on the `requestAnimationFrame` event.\n         * @method run\n         * @param {render} render\n         */\n        Render.run = function (render) {\n          (function loop(time) {\n            render.frameRequestId = _requestAnimationFrame(loop);\n            _updateTiming(render, time);\n            Render.world(render, time);\n            if (render.options.showStats || render.options.showDebug) {\n              Render.stats(render, render.context, time);\n            }\n            if (render.options.showPerformance || render.options.showDebug) {\n              Render.performance(render, render.context, time);\n            }\n          })();\n        };\n\n        /**\n         * Ends execution of `Render.run` on the given `render`, by canceling the animation frame request event loop.\n         * @method stop\n         * @param {render} render\n         */\n        Render.stop = function (render) {\n          _cancelAnimationFrame(render.frameRequestId);\n        };\n\n        /**\n         * Sets the pixel ratio of the renderer and updates the canvas.\n         * To automatically detect the correct ratio, pass the string `'auto'` for `pixelRatio`.\n         * @method setPixelRatio\n         * @param {render} render\n         * @param {number} pixelRatio\n         */\n        Render.setPixelRatio = function (render, pixelRatio) {\n          var options = render.options,\n            canvas = render.canvas;\n          if (pixelRatio === 'auto') {\n            pixelRatio = _getPixelRatio(canvas);\n          }\n          options.pixelRatio = pixelRatio;\n          canvas.setAttribute('data-pixel-ratio', pixelRatio);\n          canvas.width = options.width * pixelRatio;\n          canvas.height = options.height * pixelRatio;\n          canvas.style.width = options.width + 'px';\n          canvas.style.height = options.height + 'px';\n        };\n\n        /**\n         * Positions and sizes the viewport around the given object bounds.\n         * Objects must have at least one of the following properties:\n         * - `object.bounds`\n         * - `object.position`\n         * - `object.min` and `object.max`\n         * - `object.x` and `object.y`\n         * @method lookAt\n         * @param {render} render\n         * @param {object[]} objects\n         * @param {vector} [padding]\n         * @param {bool} [center=true]\n         */\n        Render.lookAt = function (render, objects, padding, center) {\n          center = typeof center !== 'undefined' ? center : true;\n          objects = Common.isArray(objects) ? objects : [objects];\n          padding = padding || {\n            x: 0,\n            y: 0\n          };\n\n          // find bounds of all objects\n          var bounds = {\n            min: {\n              x: Infinity,\n              y: Infinity\n            },\n            max: {\n              x: -Infinity,\n              y: -Infinity\n            }\n          };\n          for (var i = 0; i < objects.length; i += 1) {\n            var object = objects[i],\n              min = object.bounds ? object.bounds.min : object.min || object.position || object,\n              max = object.bounds ? object.bounds.max : object.max || object.position || object;\n            if (min && max) {\n              if (min.x < bounds.min.x) bounds.min.x = min.x;\n              if (max.x > bounds.max.x) bounds.max.x = max.x;\n              if (min.y < bounds.min.y) bounds.min.y = min.y;\n              if (max.y > bounds.max.y) bounds.max.y = max.y;\n            }\n          }\n\n          // find ratios\n          var width = bounds.max.x - bounds.min.x + 2 * padding.x,\n            height = bounds.max.y - bounds.min.y + 2 * padding.y,\n            viewHeight = render.canvas.height,\n            viewWidth = render.canvas.width,\n            outerRatio = viewWidth / viewHeight,\n            innerRatio = width / height,\n            scaleX = 1,\n            scaleY = 1;\n\n          // find scale factor\n          if (innerRatio > outerRatio) {\n            scaleY = innerRatio / outerRatio;\n          } else {\n            scaleX = outerRatio / innerRatio;\n          }\n\n          // enable bounds\n          render.options.hasBounds = true;\n\n          // position and size\n          render.bounds.min.x = bounds.min.x;\n          render.bounds.max.x = bounds.min.x + width * scaleX;\n          render.bounds.min.y = bounds.min.y;\n          render.bounds.max.y = bounds.min.y + height * scaleY;\n\n          // center\n          if (center) {\n            render.bounds.min.x += width * 0.5 - width * scaleX * 0.5;\n            render.bounds.max.x += width * 0.5 - width * scaleX * 0.5;\n            render.bounds.min.y += height * 0.5 - height * scaleY * 0.5;\n            render.bounds.max.y += height * 0.5 - height * scaleY * 0.5;\n          }\n\n          // padding\n          render.bounds.min.x -= padding.x;\n          render.bounds.max.x -= padding.x;\n          render.bounds.min.y -= padding.y;\n          render.bounds.max.y -= padding.y;\n\n          // update mouse\n          if (render.mouse) {\n            Mouse.setScale(render.mouse, {\n              x: (render.bounds.max.x - render.bounds.min.x) / render.canvas.width,\n              y: (render.bounds.max.y - render.bounds.min.y) / render.canvas.height\n            });\n            Mouse.setOffset(render.mouse, render.bounds.min);\n          }\n        };\n\n        /**\n         * Applies viewport transforms based on `render.bounds` to a render context.\n         * @method startViewTransform\n         * @param {render} render\n         */\n        Render.startViewTransform = function (render) {\n          var boundsWidth = render.bounds.max.x - render.bounds.min.x,\n            boundsHeight = render.bounds.max.y - render.bounds.min.y,\n            boundsScaleX = boundsWidth / render.options.width,\n            boundsScaleY = boundsHeight / render.options.height;\n          render.context.setTransform(render.options.pixelRatio / boundsScaleX, 0, 0, render.options.pixelRatio / boundsScaleY, 0, 0);\n          render.context.translate(-render.bounds.min.x, -render.bounds.min.y);\n        };\n\n        /**\n         * Resets all transforms on the render context.\n         * @method endViewTransform\n         * @param {render} render\n         */\n        Render.endViewTransform = function (render) {\n          render.context.setTransform(render.options.pixelRatio, 0, 0, render.options.pixelRatio, 0, 0);\n        };\n\n        /**\n         * Renders the given `engine`'s `Matter.World` object.\n         * This is the entry point for all rendering and should be called every time the scene changes.\n         * @method world\n         * @param {render} render\n         */\n        Render.world = function (render, time) {\n          var startTime = Common.now(),\n            engine = render.engine,\n            world = engine.world,\n            canvas = render.canvas,\n            context = render.context,\n            options = render.options,\n            timing = render.timing;\n          var allBodies = Composite.allBodies(world),\n            allConstraints = Composite.allConstraints(world),\n            background = options.wireframes ? options.wireframeBackground : options.background,\n            bodies = [],\n            constraints = [],\n            i;\n          var event = {\n            timestamp: engine.timing.timestamp\n          };\n          Events.trigger(render, 'beforeRender', event);\n\n          // apply background if it has changed\n          if (render.currentBackground !== background) _applyBackground(render, background);\n\n          // clear the canvas with a transparent fill, to allow the canvas background to show\n          context.globalCompositeOperation = 'source-in';\n          context.fillStyle = \"transparent\";\n          context.fillRect(0, 0, canvas.width, canvas.height);\n          context.globalCompositeOperation = 'source-over';\n\n          // handle bounds\n          if (options.hasBounds) {\n            // filter out bodies that are not in view\n            for (i = 0; i < allBodies.length; i++) {\n              var body = allBodies[i];\n              if (Bounds.overlaps(body.bounds, render.bounds)) bodies.push(body);\n            }\n\n            // filter out constraints that are not in view\n            for (i = 0; i < allConstraints.length; i++) {\n              var constraint = allConstraints[i],\n                bodyA = constraint.bodyA,\n                bodyB = constraint.bodyB,\n                pointAWorld = constraint.pointA,\n                pointBWorld = constraint.pointB;\n              if (bodyA) pointAWorld = Vector.add(bodyA.position, constraint.pointA);\n              if (bodyB) pointBWorld = Vector.add(bodyB.position, constraint.pointB);\n              if (!pointAWorld || !pointBWorld) continue;\n              if (Bounds.contains(render.bounds, pointAWorld) || Bounds.contains(render.bounds, pointBWorld)) constraints.push(constraint);\n            }\n\n            // transform the view\n            Render.startViewTransform(render);\n\n            // update mouse\n            if (render.mouse) {\n              Mouse.setScale(render.mouse, {\n                x: (render.bounds.max.x - render.bounds.min.x) / render.options.width,\n                y: (render.bounds.max.y - render.bounds.min.y) / render.options.height\n              });\n              Mouse.setOffset(render.mouse, render.bounds.min);\n            }\n          } else {\n            constraints = allConstraints;\n            bodies = allBodies;\n            if (render.options.pixelRatio !== 1) {\n              render.context.setTransform(render.options.pixelRatio, 0, 0, render.options.pixelRatio, 0, 0);\n            }\n          }\n          if (!options.wireframes || engine.enableSleeping && options.showSleeping) {\n            // fully featured rendering of bodies\n            Render.bodies(render, bodies, context);\n          } else {\n            if (options.showConvexHulls) Render.bodyConvexHulls(render, bodies, context);\n\n            // optimised method for wireframes only\n            Render.bodyWireframes(render, bodies, context);\n          }\n          if (options.showBounds) Render.bodyBounds(render, bodies, context);\n          if (options.showAxes || options.showAngleIndicator) Render.bodyAxes(render, bodies, context);\n          if (options.showPositions) Render.bodyPositions(render, bodies, context);\n          if (options.showVelocity) Render.bodyVelocity(render, bodies, context);\n          if (options.showIds) Render.bodyIds(render, bodies, context);\n          if (options.showSeparations) Render.separations(render, engine.pairs.list, context);\n          if (options.showCollisions) Render.collisions(render, engine.pairs.list, context);\n          if (options.showVertexNumbers) Render.vertexNumbers(render, bodies, context);\n          if (options.showMousePosition) Render.mousePosition(render, render.mouse, context);\n          Render.constraints(constraints, context);\n          if (options.hasBounds) {\n            // revert view transforms\n            Render.endViewTransform(render);\n          }\n          Events.trigger(render, 'afterRender', event);\n\n          // log the time elapsed computing this update\n          timing.lastElapsed = Common.now() - startTime;\n        };\n\n        /**\n         * Renders statistics about the engine and world useful for debugging.\n         * @private\n         * @method stats\n         * @param {render} render\n         * @param {RenderingContext} context\n         * @param {Number} time\n         */\n        Render.stats = function (render, context, time) {\n          var engine = render.engine,\n            world = engine.world,\n            bodies = Composite.allBodies(world),\n            parts = 0,\n            width = 55,\n            height = 44,\n            x = 0,\n            y = 0;\n\n          // count parts\n          for (var i = 0; i < bodies.length; i += 1) {\n            parts += bodies[i].parts.length;\n          }\n\n          // sections\n          var sections = {\n            'Part': parts,\n            'Body': bodies.length,\n            'Cons': Composite.allConstraints(world).length,\n            'Comp': Composite.allComposites(world).length,\n            'Pair': engine.pairs.list.length\n          };\n\n          // background\n          context.fillStyle = '#0e0f19';\n          context.fillRect(x, y, width * 5.5, height);\n          context.font = '12px Arial';\n          context.textBaseline = 'top';\n          context.textAlign = 'right';\n\n          // sections\n          for (var key in sections) {\n            var section = sections[key];\n            // label\n            context.fillStyle = '#aaa';\n            context.fillText(key, x + width, y + 8);\n\n            // value\n            context.fillStyle = '#eee';\n            context.fillText(section, x + width, y + 26);\n            x += width;\n          }\n        };\n\n        /**\n         * Renders engine and render performance information.\n         * @private\n         * @method performance\n         * @param {render} render\n         * @param {RenderingContext} context\n         */\n        Render.performance = function (render, context) {\n          var engine = render.engine,\n            timing = render.timing,\n            deltaHistory = timing.deltaHistory,\n            elapsedHistory = timing.elapsedHistory,\n            timestampElapsedHistory = timing.timestampElapsedHistory,\n            engineDeltaHistory = timing.engineDeltaHistory,\n            engineElapsedHistory = timing.engineElapsedHistory,\n            lastEngineDelta = engine.timing.lastDelta;\n          var deltaMean = _mean(deltaHistory),\n            elapsedMean = _mean(elapsedHistory),\n            engineDeltaMean = _mean(engineDeltaHistory),\n            engineElapsedMean = _mean(engineElapsedHistory),\n            timestampElapsedMean = _mean(timestampElapsedHistory),\n            rateMean = timestampElapsedMean / deltaMean || 0,\n            fps = 1000 / deltaMean || 0;\n          var graphHeight = 4,\n            gap = 12,\n            width = 60,\n            height = 34,\n            x = 10,\n            y = 69;\n\n          // background\n          context.fillStyle = '#0e0f19';\n          context.fillRect(0, 50, gap * 4 + width * 5 + 22, height);\n\n          // show FPS\n          Render.status(context, x, y, width, graphHeight, deltaHistory.length, Math.round(fps) + ' fps', fps / Render._goodFps, function (i) {\n            return deltaHistory[i] / deltaMean - 1;\n          });\n\n          // show engine delta\n          Render.status(context, x + gap + width, y, width, graphHeight, engineDeltaHistory.length, lastEngineDelta.toFixed(2) + ' dt', Render._goodDelta / lastEngineDelta, function (i) {\n            return engineDeltaHistory[i] / engineDeltaMean - 1;\n          });\n\n          // show engine update time\n          Render.status(context, x + (gap + width) * 2, y, width, graphHeight, engineElapsedHistory.length, engineElapsedMean.toFixed(2) + ' ut', 1 - engineElapsedMean / Render._goodFps, function (i) {\n            return engineElapsedHistory[i] / engineElapsedMean - 1;\n          });\n\n          // show render time\n          Render.status(context, x + (gap + width) * 3, y, width, graphHeight, elapsedHistory.length, elapsedMean.toFixed(2) + ' rt', 1 - elapsedMean / Render._goodFps, function (i) {\n            return elapsedHistory[i] / elapsedMean - 1;\n          });\n\n          // show effective speed\n          Render.status(context, x + (gap + width) * 4, y, width, graphHeight, timestampElapsedHistory.length, rateMean.toFixed(2) + ' x', rateMean * rateMean * rateMean, function (i) {\n            return (timestampElapsedHistory[i] / deltaHistory[i] / rateMean || 0) - 1;\n          });\n        };\n\n        /**\n         * Renders a label, indicator and a chart.\n         * @private\n         * @method status\n         * @param {RenderingContext} context\n         * @param {number} x\n         * @param {number} y\n         * @param {number} width\n         * @param {number} height\n         * @param {number} count\n         * @param {string} label\n         * @param {string} indicator\n         * @param {function} plotY\n         */\n        Render.status = function (context, x, y, width, height, count, label, indicator, plotY) {\n          // background\n          context.strokeStyle = '#888';\n          context.fillStyle = '#444';\n          context.lineWidth = 1;\n          context.fillRect(x, y + 7, width, 1);\n\n          // chart\n          context.beginPath();\n          context.moveTo(x, y + 7 - height * Common.clamp(0.4 * plotY(0), -2, 2));\n          for (var i = 0; i < width; i += 1) {\n            context.lineTo(x + i, y + 7 - (i < count ? height * Common.clamp(0.4 * plotY(i), -2, 2) : 0));\n          }\n          context.stroke();\n\n          // indicator\n          context.fillStyle = 'hsl(' + Common.clamp(25 + 95 * indicator, 0, 120) + ',100%,60%)';\n          context.fillRect(x, y - 7, 4, 4);\n\n          // label\n          context.font = '12px Arial';\n          context.textBaseline = 'middle';\n          context.textAlign = 'right';\n          context.fillStyle = '#eee';\n          context.fillText(label, x + width, y - 5);\n        };\n\n        /**\n         * Description\n         * @private\n         * @method constraints\n         * @param {constraint[]} constraints\n         * @param {RenderingContext} context\n         */\n        Render.constraints = function (constraints, context) {\n          var c = context;\n          for (var i = 0; i < constraints.length; i++) {\n            var constraint = constraints[i];\n            if (!constraint.render.visible || !constraint.pointA || !constraint.pointB) continue;\n            var bodyA = constraint.bodyA,\n              bodyB = constraint.bodyB,\n              start,\n              end;\n            if (bodyA) {\n              start = Vector.add(bodyA.position, constraint.pointA);\n            } else {\n              start = constraint.pointA;\n            }\n            if (constraint.render.type === 'pin') {\n              c.beginPath();\n              c.arc(start.x, start.y, 3, 0, 2 * Math.PI);\n              c.closePath();\n            } else {\n              if (bodyB) {\n                end = Vector.add(bodyB.position, constraint.pointB);\n              } else {\n                end = constraint.pointB;\n              }\n              c.beginPath();\n              c.moveTo(start.x, start.y);\n              if (constraint.render.type === 'spring') {\n                var delta = Vector.sub(end, start),\n                  normal = Vector.perp(Vector.normalise(delta)),\n                  coils = Math.ceil(Common.clamp(constraint.length / 5, 12, 20)),\n                  offset;\n                for (var j = 1; j < coils; j += 1) {\n                  offset = j % 2 === 0 ? 1 : -1;\n                  c.lineTo(start.x + delta.x * (j / coils) + normal.x * offset * 4, start.y + delta.y * (j / coils) + normal.y * offset * 4);\n                }\n              }\n              c.lineTo(end.x, end.y);\n            }\n            if (constraint.render.lineWidth) {\n              c.lineWidth = constraint.render.lineWidth;\n              c.strokeStyle = constraint.render.strokeStyle;\n              c.stroke();\n            }\n            if (constraint.render.anchors) {\n              c.fillStyle = constraint.render.strokeStyle;\n              c.beginPath();\n              c.arc(start.x, start.y, 3, 0, 2 * Math.PI);\n              c.arc(end.x, end.y, 3, 0, 2 * Math.PI);\n              c.closePath();\n              c.fill();\n            }\n          }\n        };\n\n        /**\n         * Description\n         * @private\n         * @method bodies\n         * @param {render} render\n         * @param {body[]} bodies\n         * @param {RenderingContext} context\n         */\n        Render.bodies = function (render, bodies, context) {\n          var c = context,\n            engine = render.engine,\n            options = render.options,\n            showInternalEdges = options.showInternalEdges || !options.wireframes,\n            body,\n            part,\n            i,\n            k;\n          for (i = 0; i < bodies.length; i++) {\n            body = bodies[i];\n            if (!body.render.visible) continue;\n\n            // handle compound parts\n            for (k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {\n              part = body.parts[k];\n              if (!part.render.visible) continue;\n              if (options.showSleeping && body.isSleeping) {\n                c.globalAlpha = 0.5 * part.render.opacity;\n              } else if (part.render.opacity !== 1) {\n                c.globalAlpha = part.render.opacity;\n              }\n              if (part.render.sprite && part.render.sprite.texture && !options.wireframes) {\n                // part sprite\n                var sprite = part.render.sprite,\n                  texture = _getTexture(render, sprite.texture);\n                c.translate(part.position.x, part.position.y);\n                c.rotate(part.angle);\n                c.drawImage(texture, texture.width * -sprite.xOffset * sprite.xScale, texture.height * -sprite.yOffset * sprite.yScale, texture.width * sprite.xScale, texture.height * sprite.yScale);\n\n                // revert translation, hopefully faster than save / restore\n                c.rotate(-part.angle);\n                c.translate(-part.position.x, -part.position.y);\n              } else {\n                // part polygon\n                if (part.circleRadius) {\n                  c.beginPath();\n                  c.arc(part.position.x, part.position.y, part.circleRadius, 0, 2 * Math.PI);\n                } else {\n                  c.beginPath();\n                  c.moveTo(part.vertices[0].x, part.vertices[0].y);\n                  for (var j = 1; j < part.vertices.length; j++) {\n                    if (!part.vertices[j - 1].isInternal || showInternalEdges) {\n                      c.lineTo(part.vertices[j].x, part.vertices[j].y);\n                    } else {\n                      c.moveTo(part.vertices[j].x, part.vertices[j].y);\n                    }\n                    if (part.vertices[j].isInternal && !showInternalEdges) {\n                      c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);\n                    }\n                  }\n                  c.lineTo(part.vertices[0].x, part.vertices[0].y);\n                  c.closePath();\n                }\n                if (!options.wireframes) {\n                  c.fillStyle = part.render.fillStyle;\n                  if (part.render.lineWidth) {\n                    c.lineWidth = part.render.lineWidth;\n                    c.strokeStyle = part.render.strokeStyle;\n                    c.stroke();\n                  }\n                  c.fill();\n                } else {\n                  c.lineWidth = 1;\n                  c.strokeStyle = '#bbb';\n                  c.stroke();\n                }\n              }\n              c.globalAlpha = 1;\n            }\n          }\n        };\n\n        /**\n         * Optimised method for drawing body wireframes in one pass\n         * @private\n         * @method bodyWireframes\n         * @param {render} render\n         * @param {body[]} bodies\n         * @param {RenderingContext} context\n         */\n        Render.bodyWireframes = function (render, bodies, context) {\n          var c = context,\n            showInternalEdges = render.options.showInternalEdges,\n            body,\n            part,\n            i,\n            j,\n            k;\n          c.beginPath();\n\n          // render all bodies\n          for (i = 0; i < bodies.length; i++) {\n            body = bodies[i];\n            if (!body.render.visible) continue;\n\n            // handle compound parts\n            for (k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {\n              part = body.parts[k];\n              c.moveTo(part.vertices[0].x, part.vertices[0].y);\n              for (j = 1; j < part.vertices.length; j++) {\n                if (!part.vertices[j - 1].isInternal || showInternalEdges) {\n                  c.lineTo(part.vertices[j].x, part.vertices[j].y);\n                } else {\n                  c.moveTo(part.vertices[j].x, part.vertices[j].y);\n                }\n                if (part.vertices[j].isInternal && !showInternalEdges) {\n                  c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);\n                }\n              }\n              c.lineTo(part.vertices[0].x, part.vertices[0].y);\n            }\n          }\n          c.lineWidth = 1;\n          c.strokeStyle = '#bbb';\n          c.stroke();\n        };\n\n        /**\n         * Optimised method for drawing body convex hull wireframes in one pass\n         * @private\n         * @method bodyConvexHulls\n         * @param {render} render\n         * @param {body[]} bodies\n         * @param {RenderingContext} context\n         */\n        Render.bodyConvexHulls = function (render, bodies, context) {\n          var c = context,\n            body,\n            part,\n            i,\n            j,\n            k;\n          c.beginPath();\n\n          // render convex hulls\n          for (i = 0; i < bodies.length; i++) {\n            body = bodies[i];\n            if (!body.render.visible || body.parts.length === 1) continue;\n            c.moveTo(body.vertices[0].x, body.vertices[0].y);\n            for (j = 1; j < body.vertices.length; j++) {\n              c.lineTo(body.vertices[j].x, body.vertices[j].y);\n            }\n            c.lineTo(body.vertices[0].x, body.vertices[0].y);\n          }\n          c.lineWidth = 1;\n          c.strokeStyle = 'rgba(255,255,255,0.2)';\n          c.stroke();\n        };\n\n        /**\n         * Renders body vertex numbers.\n         * @private\n         * @method vertexNumbers\n         * @param {render} render\n         * @param {body[]} bodies\n         * @param {RenderingContext} context\n         */\n        Render.vertexNumbers = function (render, bodies, context) {\n          var c = context,\n            i,\n            j,\n            k;\n          for (i = 0; i < bodies.length; i++) {\n            var parts = bodies[i].parts;\n            for (k = parts.length > 1 ? 1 : 0; k < parts.length; k++) {\n              var part = parts[k];\n              for (j = 0; j < part.vertices.length; j++) {\n                c.fillStyle = 'rgba(255,255,255,0.2)';\n                c.fillText(i + '_' + j, part.position.x + (part.vertices[j].x - part.position.x) * 0.8, part.position.y + (part.vertices[j].y - part.position.y) * 0.8);\n              }\n            }\n          }\n        };\n\n        /**\n         * Renders mouse position.\n         * @private\n         * @method mousePosition\n         * @param {render} render\n         * @param {mouse} mouse\n         * @param {RenderingContext} context\n         */\n        Render.mousePosition = function (render, mouse, context) {\n          var c = context;\n          c.fillStyle = 'rgba(255,255,255,0.8)';\n          c.fillText(mouse.position.x + '  ' + mouse.position.y, mouse.position.x + 5, mouse.position.y - 5);\n        };\n\n        /**\n         * Draws body bounds\n         * @private\n         * @method bodyBounds\n         * @param {render} render\n         * @param {body[]} bodies\n         * @param {RenderingContext} context\n         */\n        Render.bodyBounds = function (render, bodies, context) {\n          var c = context,\n            engine = render.engine,\n            options = render.options;\n          c.beginPath();\n          for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n            if (body.render.visible) {\n              var parts = bodies[i].parts;\n              for (var j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {\n                var part = parts[j];\n                c.rect(part.bounds.min.x, part.bounds.min.y, part.bounds.max.x - part.bounds.min.x, part.bounds.max.y - part.bounds.min.y);\n              }\n            }\n          }\n          if (options.wireframes) {\n            c.strokeStyle = 'rgba(255,255,255,0.08)';\n          } else {\n            c.strokeStyle = 'rgba(0,0,0,0.1)';\n          }\n          c.lineWidth = 1;\n          c.stroke();\n        };\n\n        /**\n         * Draws body angle indicators and axes\n         * @private\n         * @method bodyAxes\n         * @param {render} render\n         * @param {body[]} bodies\n         * @param {RenderingContext} context\n         */\n        Render.bodyAxes = function (render, bodies, context) {\n          var c = context,\n            engine = render.engine,\n            options = render.options,\n            part,\n            i,\n            j,\n            k;\n          c.beginPath();\n          for (i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n              parts = body.parts;\n            if (!body.render.visible) continue;\n            if (options.showAxes) {\n              // render all axes\n              for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {\n                part = parts[j];\n                for (k = 0; k < part.axes.length; k++) {\n                  var axis = part.axes[k];\n                  c.moveTo(part.position.x, part.position.y);\n                  c.lineTo(part.position.x + axis.x * 20, part.position.y + axis.y * 20);\n                }\n              }\n            } else {\n              for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {\n                part = parts[j];\n                for (k = 0; k < part.axes.length; k++) {\n                  // render a single axis indicator\n                  c.moveTo(part.position.x, part.position.y);\n                  c.lineTo((part.vertices[0].x + part.vertices[part.vertices.length - 1].x) / 2, (part.vertices[0].y + part.vertices[part.vertices.length - 1].y) / 2);\n                }\n              }\n            }\n          }\n          if (options.wireframes) {\n            c.strokeStyle = 'indianred';\n            c.lineWidth = 1;\n          } else {\n            c.strokeStyle = 'rgba(255, 255, 255, 0.4)';\n            c.globalCompositeOperation = 'overlay';\n            c.lineWidth = 2;\n          }\n          c.stroke();\n          c.globalCompositeOperation = 'source-over';\n        };\n\n        /**\n         * Draws body positions\n         * @private\n         * @method bodyPositions\n         * @param {render} render\n         * @param {body[]} bodies\n         * @param {RenderingContext} context\n         */\n        Render.bodyPositions = function (render, bodies, context) {\n          var c = context,\n            engine = render.engine,\n            options = render.options,\n            body,\n            part,\n            i,\n            k;\n          c.beginPath();\n\n          // render current positions\n          for (i = 0; i < bodies.length; i++) {\n            body = bodies[i];\n            if (!body.render.visible) continue;\n\n            // handle compound parts\n            for (k = 0; k < body.parts.length; k++) {\n              part = body.parts[k];\n              c.arc(part.position.x, part.position.y, 3, 0, 2 * Math.PI, false);\n              c.closePath();\n            }\n          }\n          if (options.wireframes) {\n            c.fillStyle = 'indianred';\n          } else {\n            c.fillStyle = 'rgba(0,0,0,0.5)';\n          }\n          c.fill();\n          c.beginPath();\n\n          // render previous positions\n          for (i = 0; i < bodies.length; i++) {\n            body = bodies[i];\n            if (body.render.visible) {\n              c.arc(body.positionPrev.x, body.positionPrev.y, 2, 0, 2 * Math.PI, false);\n              c.closePath();\n            }\n          }\n          c.fillStyle = 'rgba(255,165,0,0.8)';\n          c.fill();\n        };\n\n        /**\n         * Draws body velocity\n         * @private\n         * @method bodyVelocity\n         * @param {render} render\n         * @param {body[]} bodies\n         * @param {RenderingContext} context\n         */\n        Render.bodyVelocity = function (render, bodies, context) {\n          var c = context;\n          c.beginPath();\n          for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n            if (!body.render.visible) continue;\n            var velocity = Body.getVelocity(body);\n            c.moveTo(body.position.x, body.position.y);\n            c.lineTo(body.position.x + velocity.x, body.position.y + velocity.y);\n          }\n          c.lineWidth = 3;\n          c.strokeStyle = 'cornflowerblue';\n          c.stroke();\n        };\n\n        /**\n         * Draws body ids\n         * @private\n         * @method bodyIds\n         * @param {render} render\n         * @param {body[]} bodies\n         * @param {RenderingContext} context\n         */\n        Render.bodyIds = function (render, bodies, context) {\n          var c = context,\n            i,\n            j;\n          for (i = 0; i < bodies.length; i++) {\n            if (!bodies[i].render.visible) continue;\n            var parts = bodies[i].parts;\n            for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {\n              var part = parts[j];\n              c.font = \"12px Arial\";\n              c.fillStyle = 'rgba(255,255,255,0.5)';\n              c.fillText(part.id, part.position.x + 10, part.position.y - 10);\n            }\n          }\n        };\n\n        /**\n         * Description\n         * @private\n         * @method collisions\n         * @param {render} render\n         * @param {pair[]} pairs\n         * @param {RenderingContext} context\n         */\n        Render.collisions = function (render, pairs, context) {\n          var c = context,\n            options = render.options,\n            pair,\n            collision,\n            corrected,\n            bodyA,\n            bodyB,\n            i,\n            j;\n          c.beginPath();\n\n          // render collision positions\n          for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n            if (!pair.isActive) continue;\n            collision = pair.collision;\n            for (j = 0; j < pair.activeContacts.length; j++) {\n              var contact = pair.activeContacts[j],\n                vertex = contact.vertex;\n              c.rect(vertex.x - 1.5, vertex.y - 1.5, 3.5, 3.5);\n            }\n          }\n          if (options.wireframes) {\n            c.fillStyle = 'rgba(255,255,255,0.7)';\n          } else {\n            c.fillStyle = 'orange';\n          }\n          c.fill();\n          c.beginPath();\n\n          // render collision normals\n          for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n            if (!pair.isActive) continue;\n            collision = pair.collision;\n            if (pair.activeContacts.length > 0) {\n              var normalPosX = pair.activeContacts[0].vertex.x,\n                normalPosY = pair.activeContacts[0].vertex.y;\n              if (pair.activeContacts.length === 2) {\n                normalPosX = (pair.activeContacts[0].vertex.x + pair.activeContacts[1].vertex.x) / 2;\n                normalPosY = (pair.activeContacts[0].vertex.y + pair.activeContacts[1].vertex.y) / 2;\n              }\n              if (collision.bodyB === collision.supports[0].body || collision.bodyA.isStatic === true) {\n                c.moveTo(normalPosX - collision.normal.x * 8, normalPosY - collision.normal.y * 8);\n              } else {\n                c.moveTo(normalPosX + collision.normal.x * 8, normalPosY + collision.normal.y * 8);\n              }\n              c.lineTo(normalPosX, normalPosY);\n            }\n          }\n          if (options.wireframes) {\n            c.strokeStyle = 'rgba(255,165,0,0.7)';\n          } else {\n            c.strokeStyle = 'orange';\n          }\n          c.lineWidth = 1;\n          c.stroke();\n        };\n\n        /**\n         * Description\n         * @private\n         * @method separations\n         * @param {render} render\n         * @param {pair[]} pairs\n         * @param {RenderingContext} context\n         */\n        Render.separations = function (render, pairs, context) {\n          var c = context,\n            options = render.options,\n            pair,\n            collision,\n            corrected,\n            bodyA,\n            bodyB,\n            i,\n            j;\n          c.beginPath();\n\n          // render separations\n          for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n            if (!pair.isActive) continue;\n            collision = pair.collision;\n            bodyA = collision.bodyA;\n            bodyB = collision.bodyB;\n            var k = 1;\n            if (!bodyB.isStatic && !bodyA.isStatic) k = 0.5;\n            if (bodyB.isStatic) k = 0;\n            c.moveTo(bodyB.position.x, bodyB.position.y);\n            c.lineTo(bodyB.position.x - collision.penetration.x * k, bodyB.position.y - collision.penetration.y * k);\n            k = 1;\n            if (!bodyB.isStatic && !bodyA.isStatic) k = 0.5;\n            if (bodyA.isStatic) k = 0;\n            c.moveTo(bodyA.position.x, bodyA.position.y);\n            c.lineTo(bodyA.position.x + collision.penetration.x * k, bodyA.position.y + collision.penetration.y * k);\n          }\n          if (options.wireframes) {\n            c.strokeStyle = 'rgba(255,165,0,0.5)';\n          } else {\n            c.strokeStyle = 'orange';\n          }\n          c.stroke();\n        };\n\n        /**\n         * Description\n         * @private\n         * @method inspector\n         * @param {inspector} inspector\n         * @param {RenderingContext} context\n         */\n        Render.inspector = function (inspector, context) {\n          var engine = inspector.engine,\n            selected = inspector.selected,\n            render = inspector.render,\n            options = render.options,\n            bounds;\n          if (options.hasBounds) {\n            var boundsWidth = render.bounds.max.x - render.bounds.min.x,\n              boundsHeight = render.bounds.max.y - render.bounds.min.y,\n              boundsScaleX = boundsWidth / render.options.width,\n              boundsScaleY = boundsHeight / render.options.height;\n            context.scale(1 / boundsScaleX, 1 / boundsScaleY);\n            context.translate(-render.bounds.min.x, -render.bounds.min.y);\n          }\n          for (var i = 0; i < selected.length; i++) {\n            var item = selected[i].data;\n            context.translate(0.5, 0.5);\n            context.lineWidth = 1;\n            context.strokeStyle = 'rgba(255,165,0,0.9)';\n            context.setLineDash([1, 2]);\n            switch (item.type) {\n              case 'body':\n                // render body selections\n                bounds = item.bounds;\n                context.beginPath();\n                context.rect(Math.floor(bounds.min.x - 3), Math.floor(bounds.min.y - 3), Math.floor(bounds.max.x - bounds.min.x + 6), Math.floor(bounds.max.y - bounds.min.y + 6));\n                context.closePath();\n                context.stroke();\n                break;\n              case 'constraint':\n                // render constraint selections\n                var point = item.pointA;\n                if (item.bodyA) point = item.pointB;\n                context.beginPath();\n                context.arc(point.x, point.y, 10, 0, 2 * Math.PI);\n                context.closePath();\n                context.stroke();\n                break;\n            }\n            context.setLineDash([]);\n            context.translate(-0.5, -0.5);\n          }\n\n          // render selection region\n          if (inspector.selectStart !== null) {\n            context.translate(0.5, 0.5);\n            context.lineWidth = 1;\n            context.strokeStyle = 'rgba(255,165,0,0.6)';\n            context.fillStyle = 'rgba(255,165,0,0.1)';\n            bounds = inspector.selectBounds;\n            context.beginPath();\n            context.rect(Math.floor(bounds.min.x), Math.floor(bounds.min.y), Math.floor(bounds.max.x - bounds.min.x), Math.floor(bounds.max.y - bounds.min.y));\n            context.closePath();\n            context.stroke();\n            context.fill();\n            context.translate(-0.5, -0.5);\n          }\n          if (options.hasBounds) context.setTransform(1, 0, 0, 1, 0, 0);\n        };\n\n        /**\n         * Updates render timing.\n         * @method _updateTiming\n         * @private\n         * @param {render} render\n         * @param {number} time\n         */\n        var _updateTiming = function (render, time) {\n          var engine = render.engine,\n            timing = render.timing,\n            historySize = timing.historySize,\n            timestamp = engine.timing.timestamp;\n          timing.delta = time - timing.lastTime || Render._goodDelta;\n          timing.lastTime = time;\n          timing.timestampElapsed = timestamp - timing.lastTimestamp || 0;\n          timing.lastTimestamp = timestamp;\n          timing.deltaHistory.unshift(timing.delta);\n          timing.deltaHistory.length = Math.min(timing.deltaHistory.length, historySize);\n          timing.engineDeltaHistory.unshift(engine.timing.lastDelta);\n          timing.engineDeltaHistory.length = Math.min(timing.engineDeltaHistory.length, historySize);\n          timing.timestampElapsedHistory.unshift(timing.timestampElapsed);\n          timing.timestampElapsedHistory.length = Math.min(timing.timestampElapsedHistory.length, historySize);\n          timing.engineElapsedHistory.unshift(engine.timing.lastElapsed);\n          timing.engineElapsedHistory.length = Math.min(timing.engineElapsedHistory.length, historySize);\n          timing.elapsedHistory.unshift(timing.lastElapsed);\n          timing.elapsedHistory.length = Math.min(timing.elapsedHistory.length, historySize);\n        };\n\n        /**\n         * Returns the mean value of the given numbers.\n         * @method _mean\n         * @private\n         * @param {Number[]} values\n         * @return {Number} the mean of given values\n         */\n        var _mean = function (values) {\n          var result = 0;\n          for (var i = 0; i < values.length; i += 1) {\n            result += values[i];\n          }\n          return result / values.length || 0;\n        };\n\n        /**\n         * @method _createCanvas\n         * @private\n         * @param {} width\n         * @param {} height\n         * @return canvas\n         */\n        var _createCanvas = function (width, height) {\n          var canvas = document.createElement('canvas');\n          canvas.width = width;\n          canvas.height = height;\n          canvas.oncontextmenu = function () {\n            return false;\n          };\n          canvas.onselectstart = function () {\n            return false;\n          };\n          return canvas;\n        };\n\n        /**\n         * Gets the pixel ratio of the canvas.\n         * @method _getPixelRatio\n         * @private\n         * @param {HTMLElement} canvas\n         * @return {Number} pixel ratio\n         */\n        var _getPixelRatio = function (canvas) {\n          var context = canvas.getContext('2d'),\n            devicePixelRatio = window.devicePixelRatio || 1,\n            backingStorePixelRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;\n          return devicePixelRatio / backingStorePixelRatio;\n        };\n\n        /**\n         * Gets the requested texture (an Image) via its path\n         * @method _getTexture\n         * @private\n         * @param {render} render\n         * @param {string} imagePath\n         * @return {Image} texture\n         */\n        var _getTexture = function (render, imagePath) {\n          var image = render.textures[imagePath];\n          if (image) return image;\n          image = render.textures[imagePath] = new Image();\n          image.src = imagePath;\n          return image;\n        };\n\n        /**\n         * Applies the background to the canvas using CSS.\n         * @method applyBackground\n         * @private\n         * @param {render} render\n         * @param {string} background\n         */\n        var _applyBackground = function (render, background) {\n          var cssBackground = background;\n          if (/(jpg|gif|png)$/.test(background)) cssBackground = 'url(' + background + ')';\n          render.canvas.style.background = cssBackground;\n          render.canvas.style.backgroundSize = \"contain\";\n          render.currentBackground = background;\n        };\n\n        /*\n        *\n        *  Events Documentation\n        *\n        */\n\n        /**\n        * Fired before rendering\n        *\n        * @event beforeRender\n        * @param {} event An event object\n        * @param {number} event.timestamp The engine.timing.timestamp of the event\n        * @param {} event.source The source object of the event\n        * @param {} event.name The name of the event\n        */\n\n        /**\n        * Fired after rendering\n        *\n        * @event afterRender\n        * @param {} event An event object\n        * @param {number} event.timestamp The engine.timing.timestamp of the event\n        * @param {} event.source The source object of the event\n        * @param {} event.name The name of the event\n        */\n\n        /*\n        *\n        *  Properties Documentation\n        *\n        */\n\n        /**\n         * A back-reference to the `Matter.Render` module.\n         *\n         * @deprecated\n         * @property controller\n         * @type render\n         */\n\n        /**\n         * A reference to the `Matter.Engine` instance to be used.\n         *\n         * @property engine\n         * @type engine\n         */\n\n        /**\n         * A reference to the element where the canvas is to be inserted (if `render.canvas` has not been specified)\n         *\n         * @property element\n         * @type HTMLElement\n         * @default null\n         */\n\n        /**\n         * The canvas element to render to. If not specified, one will be created if `render.element` has been specified.\n         *\n         * @property canvas\n         * @type HTMLCanvasElement\n         * @default null\n         */\n\n        /**\n         * A `Bounds` object that specifies the drawing view region.\n         * Rendering will be automatically transformed and scaled to fit within the canvas size (`render.options.width` and `render.options.height`).\n         * This allows for creating views that can pan or zoom around the scene.\n         * You must also set `render.options.hasBounds` to `true` to enable bounded rendering.\n         *\n         * @property bounds\n         * @type bounds\n         */\n\n        /**\n         * The 2d rendering context from the `render.canvas` element.\n         *\n         * @property context\n         * @type CanvasRenderingContext2D\n         */\n\n        /**\n         * The sprite texture cache.\n         *\n         * @property textures\n         * @type {}\n         */\n\n        /**\n         * The mouse to render if `render.options.showMousePosition` is enabled.\n         *\n         * @property mouse\n         * @type mouse\n         * @default null\n         */\n\n        /**\n         * The configuration options of the renderer.\n         *\n         * @property options\n         * @type {}\n         */\n\n        /**\n         * The target width in pixels of the `render.canvas` to be created.\n         * See also the `options.pixelRatio` property to change render quality.\n         *\n         * @property options.width\n         * @type number\n         * @default 800\n         */\n\n        /**\n         * The target height in pixels of the `render.canvas` to be created.\n         * See also the `options.pixelRatio` property to change render quality.\n         *\n         * @property options.height\n         * @type number\n         * @default 600\n         */\n\n        /**\n         * The [pixel ratio](https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio) to use when rendering.\n         *\n         * @property options.pixelRatio\n         * @type number\n         * @default 1\n         */\n\n        /**\n         * A CSS background color string to use when `render.options.wireframes` is disabled.\n         * This may be also set to `'transparent'` or equivalent.\n         *\n         * @property options.background\n         * @type string\n         * @default '#14151f'\n         */\n\n        /**\n         * A CSS background color string to use when `render.options.wireframes` is enabled.\n         * This may be also set to `'transparent'` or equivalent.\n         *\n         * @property options.wireframeBackground\n         * @type string\n         * @default '#14151f'\n         */\n\n        /**\n         * A flag that specifies if `render.bounds` should be used when rendering.\n         *\n         * @property options.hasBounds\n         * @type boolean\n         * @default false\n         */\n\n        /**\n         * A flag to enable or disable all debug information overlays together.  \n         * This includes and has priority over the values of:\n         *\n         * - `render.options.showStats`\n         * - `render.options.showPerformance`\n         *\n         * @property options.showDebug\n         * @type boolean\n         * @default false\n         */\n\n        /**\n         * A flag to enable or disable the engine stats info overlay.  \n         * From left to right, the values shown are:\n         *\n         * - body parts total\n         * - body total\n         * - constraints total\n         * - composites total\n         * - collision pairs total\n         *\n         * @property options.showStats\n         * @type boolean\n         * @default false\n         */\n\n        /**\n         * A flag to enable or disable performance charts.  \n         * From left to right, the values shown are:\n         *\n         * - average render frequency (e.g. 60 fps)\n         * - exact engine delta time used for last update (e.g. 16.66ms)\n         * - average engine execution duration (e.g. 5.00ms)\n         * - average render execution duration (e.g. 0.40ms)\n         * - average effective play speed (e.g. '1.00x' is 'real-time')\n         *\n         * Each value is recorded over a fixed sample of past frames (60 frames).\n         *\n         * A chart shown below each value indicates the variance from the average over the sample.\n         * The more stable or fixed the value is the flatter the chart will appear.\n         *\n         * @property options.showPerformance\n         * @type boolean\n         * @default false\n         */\n\n        /**\n         * A flag to enable or disable rendering entirely.\n         *\n         * @property options.enabled\n         * @type boolean\n         * @default false\n         */\n\n        /**\n         * A flag to toggle wireframe rendering otherwise solid fill rendering is used.\n         *\n         * @property options.wireframes\n         * @type boolean\n         * @default true\n         */\n\n        /**\n         * A flag to enable or disable sleeping bodies indicators.\n         *\n         * @property options.showSleeping\n         * @type boolean\n         * @default true\n         */\n\n        /**\n         * A flag to enable or disable the debug information overlay.\n         *\n         * @property options.showDebug\n         * @type boolean\n         * @default false\n         */\n\n        /**\n         * A flag to enable or disable the collision broadphase debug overlay.\n         *\n         * @deprecated no longer implemented\n         * @property options.showBroadphase\n         * @type boolean\n         * @default false\n         */\n\n        /**\n         * A flag to enable or disable the body bounds debug overlay.\n         *\n         * @property options.showBounds\n         * @type boolean\n         * @default false\n         */\n\n        /**\n         * A flag to enable or disable the body velocity debug overlay.\n         *\n         * @property options.showVelocity\n         * @type boolean\n         * @default false\n         */\n\n        /**\n         * A flag to enable or disable the body collisions debug overlay.\n         *\n         * @property options.showCollisions\n         * @type boolean\n         * @default false\n         */\n\n        /**\n         * A flag to enable or disable the collision resolver separations debug overlay.\n         *\n         * @property options.showSeparations\n         * @type boolean\n         * @default false\n         */\n\n        /**\n         * A flag to enable or disable the body axes debug overlay.\n         *\n         * @property options.showAxes\n         * @type boolean\n         * @default false\n         */\n\n        /**\n         * A flag to enable or disable the body positions debug overlay.\n         *\n         * @property options.showPositions\n         * @type boolean\n         * @default false\n         */\n\n        /**\n         * A flag to enable or disable the body angle debug overlay.\n         *\n         * @property options.showAngleIndicator\n         * @type boolean\n         * @default false\n         */\n\n        /**\n         * A flag to enable or disable the body and part ids debug overlay.\n         *\n         * @property options.showIds\n         * @type boolean\n         * @default false\n         */\n\n        /**\n         * A flag to enable or disable the body vertex numbers debug overlay.\n         *\n         * @property options.showVertexNumbers\n         * @type boolean\n         * @default false\n         */\n\n        /**\n         * A flag to enable or disable the body convex hulls debug overlay.\n         *\n         * @property options.showConvexHulls\n         * @type boolean\n         * @default false\n         */\n\n        /**\n         * A flag to enable or disable the body internal edges debug overlay.\n         *\n         * @property options.showInternalEdges\n         * @type boolean\n         * @default false\n         */\n\n        /**\n         * A flag to enable or disable the mouse position debug overlay.\n         *\n         * @property options.showMousePosition\n         * @type boolean\n         * @default false\n         */\n      })();\n\n      /***/\n    }, /* 27 */\n    /***/function (module, exports, __nested_webpack_require_357142__) {\n      /**\n      * The `Matter.Runner` module is an optional utility which provides a game loop, \n      * that handles continuously updating a `Matter.Engine` for you within a browser.\n      * It is intended for development and debugging purposes, but may also be suitable for simple games.\n      * If you are using your own game loop instead, then you do not need the `Matter.Runner` module.\n      * Instead just call `Engine.update(engine, delta)` in your own loop.\n      *\n      * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n      *\n      * @class Runner\n      */\n\n      var Runner = {};\n      module.exports = Runner;\n      var Events = __nested_webpack_require_357142__(5);\n      var Engine = __nested_webpack_require_357142__(17);\n      var Common = __nested_webpack_require_357142__(0);\n      (function () {\n        var _requestAnimationFrame, _cancelAnimationFrame;\n        if (typeof window !== 'undefined') {\n          _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame;\n          _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;\n        }\n        if (!_requestAnimationFrame) {\n          var _frameTimeout;\n          _requestAnimationFrame = function (callback) {\n            _frameTimeout = setTimeout(function () {\n              callback(Common.now());\n            }, 1000 / 60);\n          };\n          _cancelAnimationFrame = function () {\n            clearTimeout(_frameTimeout);\n          };\n        }\n\n        /**\n         * Creates a new Runner. The options parameter is an object that specifies any properties you wish to override the defaults.\n         * @method create\n         * @param {} options\n         */\n        Runner.create = function (options) {\n          var defaults = {\n            fps: 60,\n            deltaSampleSize: 60,\n            counterTimestamp: 0,\n            frameCounter: 0,\n            deltaHistory: [],\n            timePrev: null,\n            frameRequestId: null,\n            isFixed: false,\n            enabled: true\n          };\n          var runner = Common.extend(defaults, options);\n          runner.delta = runner.delta || 1000 / runner.fps;\n          runner.deltaMin = runner.deltaMin || 1000 / runner.fps;\n          runner.deltaMax = runner.deltaMax || 1000 / (runner.fps * 0.5);\n          runner.fps = 1000 / runner.delta;\n          return runner;\n        };\n\n        /**\n         * Continuously ticks a `Matter.Engine` by calling `Runner.tick` on the `requestAnimationFrame` event.\n         * @method run\n         * @param {engine} engine\n         */\n        Runner.run = function (runner, engine) {\n          // create runner if engine is first argument\n          if (typeof runner.positionIterations !== 'undefined') {\n            engine = runner;\n            runner = Runner.create();\n          }\n          (function run(time) {\n            runner.frameRequestId = _requestAnimationFrame(run);\n            if (time && runner.enabled) {\n              Runner.tick(runner, engine, time);\n            }\n          })();\n          return runner;\n        };\n\n        /**\n         * A game loop utility that updates the engine and renderer by one step (a 'tick').\n         * Features delta smoothing, time correction and fixed or dynamic timing.\n         * Consider just `Engine.update(engine, delta)` if you're using your own loop.\n         * @method tick\n         * @param {runner} runner\n         * @param {engine} engine\n         * @param {number} time\n         */\n        Runner.tick = function (runner, engine, time) {\n          var timing = engine.timing,\n            delta;\n          if (runner.isFixed) {\n            // fixed timestep\n            delta = runner.delta;\n          } else {\n            // dynamic timestep based on wall clock between calls\n            delta = time - runner.timePrev || runner.delta;\n            runner.timePrev = time;\n\n            // optimistically filter delta over a few frames, to improve stability\n            runner.deltaHistory.push(delta);\n            runner.deltaHistory = runner.deltaHistory.slice(-runner.deltaSampleSize);\n            delta = Math.min.apply(null, runner.deltaHistory);\n\n            // limit delta\n            delta = delta < runner.deltaMin ? runner.deltaMin : delta;\n            delta = delta > runner.deltaMax ? runner.deltaMax : delta;\n\n            // update engine timing object\n            runner.delta = delta;\n          }\n\n          // create an event object\n          var event = {\n            timestamp: timing.timestamp\n          };\n          Events.trigger(runner, 'beforeTick', event);\n\n          // fps counter\n          runner.frameCounter += 1;\n          if (time - runner.counterTimestamp >= 1000) {\n            runner.fps = runner.frameCounter * ((time - runner.counterTimestamp) / 1000);\n            runner.counterTimestamp = time;\n            runner.frameCounter = 0;\n          }\n          Events.trigger(runner, 'tick', event);\n\n          // update\n          Events.trigger(runner, 'beforeUpdate', event);\n          Engine.update(engine, delta);\n          Events.trigger(runner, 'afterUpdate', event);\n          Events.trigger(runner, 'afterTick', event);\n        };\n\n        /**\n         * Ends execution of `Runner.run` on the given `runner`, by canceling the animation frame request event loop.\n         * If you wish to only temporarily pause the engine, see `engine.enabled` instead.\n         * @method stop\n         * @param {runner} runner\n         */\n        Runner.stop = function (runner) {\n          _cancelAnimationFrame(runner.frameRequestId);\n        };\n\n        /**\n         * Alias for `Runner.run`.\n         * @method start\n         * @param {runner} runner\n         * @param {engine} engine\n         */\n        Runner.start = function (runner, engine) {\n          Runner.run(runner, engine);\n        };\n\n        /*\n        *\n        *  Events Documentation\n        *\n        */\n\n        /**\n        * Fired at the start of a tick, before any updates to the engine or timing\n        *\n        * @event beforeTick\n        * @param {} event An event object\n        * @param {number} event.timestamp The engine.timing.timestamp of the event\n        * @param {} event.source The source object of the event\n        * @param {} event.name The name of the event\n        */\n\n        /**\n        * Fired after engine timing updated, but just before update\n        *\n        * @event tick\n        * @param {} event An event object\n        * @param {number} event.timestamp The engine.timing.timestamp of the event\n        * @param {} event.source The source object of the event\n        * @param {} event.name The name of the event\n        */\n\n        /**\n        * Fired at the end of a tick, after engine update and after rendering\n        *\n        * @event afterTick\n        * @param {} event An event object\n        * @param {number} event.timestamp The engine.timing.timestamp of the event\n        * @param {} event.source The source object of the event\n        * @param {} event.name The name of the event\n        */\n\n        /**\n        * Fired before update\n        *\n        * @event beforeUpdate\n        * @param {} event An event object\n        * @param {number} event.timestamp The engine.timing.timestamp of the event\n        * @param {} event.source The source object of the event\n        * @param {} event.name The name of the event\n        */\n\n        /**\n        * Fired after update\n        *\n        * @event afterUpdate\n        * @param {} event An event object\n        * @param {number} event.timestamp The engine.timing.timestamp of the event\n        * @param {} event.source The source object of the event\n        * @param {} event.name The name of the event\n        */\n\n        /*\n        *\n        *  Properties Documentation\n        *\n        */\n\n        /**\n         * A flag that specifies whether the runner is running or not.\n         *\n         * @property enabled\n         * @type boolean\n         * @default true\n         */\n\n        /**\n         * A `Boolean` that specifies if the runner should use a fixed timestep (otherwise it is variable).\n         * If timing is fixed, then the apparent simulation speed will change depending on the frame rate (but behaviour will be deterministic).\n         * If the timing is variable, then the apparent simulation speed will be constant (approximately, but at the cost of determininism).\n         *\n         * @property isFixed\n         * @type boolean\n         * @default false\n         */\n\n        /**\n         * A `Number` that specifies the time step between updates in milliseconds.\n         * If `engine.timing.isFixed` is set to `true`, then `delta` is fixed.\n         * If it is `false`, then `delta` can dynamically change to maintain the correct apparent simulation speed.\n         *\n         * @property delta\n         * @type number\n         * @default 1000 / 60\n         */\n      })();\n\n      /***/\n    }, /* 28 */\n    /***/function (module, exports, __nested_webpack_require_366277__) {\n      /**\n      * This module has now been replaced by `Matter.Collision`.\n      *\n      * All usage should be migrated to `Matter.Collision`.\n      * For back-compatibility purposes this module will remain for a short term and then later removed in a future release.\n      *\n      * The `Matter.SAT` module contains methods for detecting collisions using the Separating Axis Theorem.\n      *\n      * @class SAT\n      * @deprecated\n      */\n\n      var SAT = {};\n      module.exports = SAT;\n      var Collision = __nested_webpack_require_366277__(8);\n      var Common = __nested_webpack_require_366277__(0);\n      var deprecated = Common.deprecated;\n      (function () {\n        /**\n         * Detect collision between two bodies using the Separating Axis Theorem.\n         * @deprecated replaced by Collision.collides\n         * @method collides\n         * @param {body} bodyA\n         * @param {body} bodyB\n         * @return {collision} collision\n         */\n        SAT.collides = function (bodyA, bodyB) {\n          return Collision.collides(bodyA, bodyB);\n        };\n        deprecated(SAT, 'collides', 'SAT.collides ➤ replaced by Collision.collides');\n      })();\n\n      /***/\n    }, /* 29 */\n    /***/function (module, exports, __nested_webpack_require_367507__) {\n      /**\n      * The `Matter.Svg` module contains methods for converting SVG images into an array of vector points.\n      *\n      * To use this module you also need the SVGPathSeg polyfill: https://github.com/progers/pathseg\n      *\n      * See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n      *\n      * @class Svg\n      */\n\n      var Svg = {};\n      module.exports = Svg;\n      var Bounds = __nested_webpack_require_367507__(1);\n      var Common = __nested_webpack_require_367507__(0);\n      (function () {\n        /**\n         * Converts an SVG path into an array of vector points.\n         * If the input path forms a concave shape, you must decompose the result into convex parts before use.\n         * See `Bodies.fromVertices` which provides support for this.\n         * Note that this function is not guaranteed to support complex paths (such as those with holes).\n         * You must load the `pathseg.js` polyfill on newer browsers.\n         * @method pathToVertices\n         * @param {SVGPathElement} path\n         * @param {Number} [sampleLength=15]\n         * @return {Vector[]} points\n         */\n        Svg.pathToVertices = function (path, sampleLength) {\n          if (typeof window !== 'undefined' && !('SVGPathSeg' in window)) {\n            Common.warn('Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.');\n          }\n\n          // https://github.com/wout/svg.topoly.js/blob/master/svg.topoly.js\n          var i,\n            il,\n            total,\n            point,\n            segment,\n            segments,\n            segmentsQueue,\n            lastSegment,\n            lastPoint,\n            segmentIndex,\n            points = [],\n            lx,\n            ly,\n            length = 0,\n            x = 0,\n            y = 0;\n          sampleLength = sampleLength || 15;\n          var addPoint = function (px, py, pathSegType) {\n            // all odd-numbered path types are relative except PATHSEG_CLOSEPATH (1)\n            var isRelative = pathSegType % 2 === 1 && pathSegType > 1;\n\n            // when the last point doesn't equal the current point add the current point\n            if (!lastPoint || px != lastPoint.x || py != lastPoint.y) {\n              if (lastPoint && isRelative) {\n                lx = lastPoint.x;\n                ly = lastPoint.y;\n              } else {\n                lx = 0;\n                ly = 0;\n              }\n              var point = {\n                x: lx + px,\n                y: ly + py\n              };\n\n              // set last point\n              if (isRelative || !lastPoint) {\n                lastPoint = point;\n              }\n              points.push(point);\n              x = lx + px;\n              y = ly + py;\n            }\n          };\n          var addSegmentPoint = function (segment) {\n            var segType = segment.pathSegTypeAsLetter.toUpperCase();\n\n            // skip path ends\n            if (segType === 'Z') return;\n\n            // map segment to x and y\n            switch (segType) {\n              case 'M':\n              case 'L':\n              case 'T':\n              case 'C':\n              case 'S':\n              case 'Q':\n                x = segment.x;\n                y = segment.y;\n                break;\n              case 'H':\n                x = segment.x;\n                break;\n              case 'V':\n                y = segment.y;\n                break;\n            }\n            addPoint(x, y, segment.pathSegType);\n          };\n\n          // ensure path is absolute\n          Svg._svgPathToAbsolute(path);\n\n          // get total length\n          total = path.getTotalLength();\n\n          // queue segments\n          segments = [];\n          for (i = 0; i < path.pathSegList.numberOfItems; i += 1) segments.push(path.pathSegList.getItem(i));\n          segmentsQueue = segments.concat();\n\n          // sample through path\n          while (length < total) {\n            // get segment at position\n            segmentIndex = path.getPathSegAtLength(length);\n            segment = segments[segmentIndex];\n\n            // new segment\n            if (segment != lastSegment) {\n              while (segmentsQueue.length && segmentsQueue[0] != segment) addSegmentPoint(segmentsQueue.shift());\n              lastSegment = segment;\n            }\n\n            // add points in between when curving\n            // TODO: adaptive sampling\n            switch (segment.pathSegTypeAsLetter.toUpperCase()) {\n              case 'C':\n              case 'T':\n              case 'S':\n              case 'Q':\n              case 'A':\n                point = path.getPointAtLength(length);\n                addPoint(point.x, point.y, 0);\n                break;\n            }\n\n            // increment by sample value\n            length += sampleLength;\n          }\n\n          // add remaining segments not passed by sampling\n          for (i = 0, il = segmentsQueue.length; i < il; ++i) addSegmentPoint(segmentsQueue[i]);\n          return points;\n        };\n        Svg._svgPathToAbsolute = function (path) {\n          // http://phrogz.net/convert-svg-path-to-all-absolute-commands\n          // Copyright (c) Gavin Kistner\n          // http://phrogz.net/js/_ReuseLicense.txt\n          // Modifications: tidy formatting and naming\n          var x0,\n            y0,\n            x1,\n            y1,\n            x2,\n            y2,\n            segs = path.pathSegList,\n            x = 0,\n            y = 0,\n            len = segs.numberOfItems;\n          for (var i = 0; i < len; ++i) {\n            var seg = segs.getItem(i),\n              segType = seg.pathSegTypeAsLetter;\n            if (/[MLHVCSQTA]/.test(segType)) {\n              if ('x' in seg) x = seg.x;\n              if ('y' in seg) y = seg.y;\n            } else {\n              if ('x1' in seg) x1 = x + seg.x1;\n              if ('x2' in seg) x2 = x + seg.x2;\n              if ('y1' in seg) y1 = y + seg.y1;\n              if ('y2' in seg) y2 = y + seg.y2;\n              if ('x' in seg) x += seg.x;\n              if ('y' in seg) y += seg.y;\n              switch (segType) {\n                case 'm':\n                  segs.replaceItem(path.createSVGPathSegMovetoAbs(x, y), i);\n                  break;\n                case 'l':\n                  segs.replaceItem(path.createSVGPathSegLinetoAbs(x, y), i);\n                  break;\n                case 'h':\n                  segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x), i);\n                  break;\n                case 'v':\n                  segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y), i);\n                  break;\n                case 'c':\n                  segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i);\n                  break;\n                case 's':\n                  segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i);\n                  break;\n                case 'q':\n                  segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i);\n                  break;\n                case 't':\n                  segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i);\n                  break;\n                case 'a':\n                  segs.replaceItem(path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i);\n                  break;\n                case 'z':\n                case 'Z':\n                  x = x0;\n                  y = y0;\n                  break;\n              }\n            }\n            if (segType == 'M' || segType == 'm') {\n              x0 = x;\n              y0 = y;\n            }\n          }\n        };\n      })();\n\n      /***/\n    }, /* 30 */\n    /***/function (module, exports, __nested_webpack_require_375250__) {\n      /**\n      * This module has now been replaced by `Matter.Composite`.\n      *\n      * All usage should be migrated to the equivalent functions found on `Matter.Composite`.\n      * For example `World.add(world, body)` now becomes `Composite.add(world, body)`.\n      *\n      * The property `world.gravity` has been moved to `engine.gravity`.\n      *\n      * For back-compatibility purposes this module will remain as a direct alias to `Matter.Composite` in the short term during migration.\n      * Eventually this alias module will be marked as deprecated and then later removed in a future release.\n      *\n      * @class World\n      */\n\n      var World = {};\n      module.exports = World;\n      var Composite = __nested_webpack_require_375250__(6);\n      var Common = __nested_webpack_require_375250__(0);\n      (function () {\n        /**\n         * See above, aliases for back compatibility only\n         */\n        World.create = Composite.create;\n        World.add = Composite.add;\n        World.remove = Composite.remove;\n        World.clear = Composite.clear;\n        World.addComposite = Composite.addComposite;\n        World.addBody = Composite.addBody;\n        World.addConstraint = Composite.addConstraint;\n      })();\n\n      /***/\n    }\n    /******/])\n  );\n});\n\n//# sourceURL=webpack://my-webpack-project/./node_modules/matter-js/build/matter.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var matter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! matter-js */ \"./node_modules/matter-js/build/matter.js\");\n/* harmony import */ var matter_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(matter_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var howler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! howler */ \"./node_modules/howler/dist/howler.js\");\n/* harmony import */ var howler__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(howler__WEBPACK_IMPORTED_MODULE_1__);\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n/* eslint-disable no-undef */\n/* eslint-disable no-unused-vars */\n\n\nwindow.addEventListener(\"load\", function () {\n  // module aliases\n  var Engine = (matter_js__WEBPACK_IMPORTED_MODULE_0___default().Engine),\n    Render = (matter_js__WEBPACK_IMPORTED_MODULE_0___default().Render),\n    Runner = (matter_js__WEBPACK_IMPORTED_MODULE_0___default().Runner),\n    Bodies = (matter_js__WEBPACK_IMPORTED_MODULE_0___default().Bodies),\n    Body = (matter_js__WEBPACK_IMPORTED_MODULE_0___default().Body),\n    Constraint = (matter_js__WEBPACK_IMPORTED_MODULE_0___default().Constraint),\n    Events = (matter_js__WEBPACK_IMPORTED_MODULE_0___default().Events),\n    Composite = (matter_js__WEBPACK_IMPORTED_MODULE_0___default().Composite),\n    Mouse = (matter_js__WEBPACK_IMPORTED_MODULE_0___default().Mouse),\n    MouseConstraint = (matter_js__WEBPACK_IMPORTED_MODULE_0___default().MouseConstraint);\n\n  // check if viewport is mobile or not\n  var maxDesktopWidth = 430;\n  var isMobile = window.innerWidth <= 768;\n  var canvasWidth = isMobile ? window.innerWidth : maxDesktopWidth;\n  var canvasHeight = window.innerHeight;\n  if (!isMobile) {\n    document.querySelector(\".card\").style.display = \"block\";\n  }\n  document.querySelector(\".btn-container\").style.display = \"block\";\n  document.querySelector(\"#loading\").style.display = \"none\";\n\n  // list of particles\n  var particles = [\"particles/particles.json\", \"particles/particles-bubble.json\", \"particles/particles-nasa.json\", \"particles/particles-snow.json\"];\n  if (!isMobile) {\n    // load particles\n    particlesJS.load(\"particles-js\", getRandom(particles), function () {\n      console.log(\"particles.js loaded - callback\");\n    });\n  }\n  var canvas = document.getElementById(\"myCanvas\"),\n    CW = canvas.width = canvasWidth,\n    CH = canvas.height = canvasHeight;\n\n  // background fill color\n  var backgroundColor = \"#2e2e2e\";\n  // top circle initial position\n  var positionY = 60;\n  // scale between category\n  var scale = 1.3;\n  // initial radius of first circle\n  var initialValue = 20;\n  // walls fill color\n  var wallsColor = \"#1c1c1c\";\n  // sign fill color\n  var signColor = \"#986129\";\n  // walls wallThickness\n  var wallThickness = 20;\n  // floor thickness\n  var floorThickness = 100;\n  // radius of texture image = image size/2\n  var textureImageRadius = 75;\n  // texture images count\n  var textureImageCount = 39;\n  // all possible texture images\n  var textures = [];\n  for (var i = 1; i <= textureImageCount; i++) {\n    textures.push(\"assets/image/circles/orbs (\".concat(i, \").png\"));\n  }\n  // shuffle array value to get random image\n  textures.sort(function () {\n    return Math.random() - 0.5;\n  });\n\n  // list of sfx\n  var sfx = {\n    merge: new howler__WEBPACK_IMPORTED_MODULE_1__.Howl({\n      src: [\"assets/audio/merge.wav\"]\n    }),\n    gameOver: new howler__WEBPACK_IMPORTED_MODULE_1__.Howl({\n      src: [\"assets/audio/game_over.mp3\"]\n    }),\n    hit: new howler__WEBPACK_IMPORTED_MODULE_1__.Howl({\n      src: [\"assets/audio/hit.wav\"]\n    })\n  };\n\n  // list of BGM\n  var music = {\n    bgm: new howler__WEBPACK_IMPORTED_MODULE_1__.Howl({\n      src: [\"assets/audio/bgm/enjoy.mp3\"],\n      loop: true\n    })\n  };\n  music.bgm.play();\n  var btnPlay = document.querySelector(\"#btn-music-play\");\n  var btnStop = document.querySelector(\"#btn-music-stop\");\n  btnPlay.style.display = \"none\";\n  btnStop.style.display = \"block\";\n\n  // function to play BGM\n  function playMusic() {\n    if (!music.bgm.playing()) {\n      btnPlay.style.display = \"none\";\n      btnStop.style.display = \"block\";\n      music.bgm.play();\n    }\n  }\n\n  // function to stop BGM\n  function stopMusic() {\n    if (music.bgm.playing()) {\n      btnPlay.style.display = \"block\";\n      btnStop.style.display = \"none\";\n      music.bgm.stop();\n    }\n  }\n  btnPlay.onclick = function () {\n    playMusic();\n  };\n  btnStop.onclick = function () {\n    stopMusic();\n  };\n\n  // create an engine\n  var engine = Engine.create();\n  var world = engine.world;\n\n  // custom property\n  var gameOver = false;\n  var gameScore = 0;\n\n  // create a renderer\n  var render = Render.create({\n    canvas: canvas,\n    engine: engine,\n    options: {\n      width: CW,\n      height: CH,\n      background: backgroundColor,\n      wireframes: false,\n      showCollisions: false,\n      showDebug: false,\n      showPositions: false\n    }\n  });\n  // canvas 2D context\n  var ctx = render.context;\n  // run the renderer\n  Render.run(render);\n  // create runner\n  var runner = Runner.create();\n  // run the engine\n  Runner.run(runner, engine);\n  // add mouse control\n  var mouse = Mouse.create(render.canvas),\n    mouseConstraint = MouseConstraint.create(engine, {\n      mouse: mouse,\n      constraint: {\n        stiffness: 0.2,\n        render: {\n          visible: false\n        }\n      }\n    });\n  // add mouse to world\n  Composite.add(world, mouseConstraint);\n  // keep the mouse in sync with rendering\n  render.mouse = mouse;\n  // fit the render viewport to the scene\n  Render.lookAt(render, {\n    min: {\n      x: 0,\n      y: 0\n    },\n    max: {\n      x: CW,\n      y: CH\n    }\n  });\n\n  // define our categories (as bit fields, there are up to 32 available) to prevent mouse for moving the circle\n  var defaultCategory = 0x0001,\n    redCategory = 0x0002,\n    greenCategory = 0x0004;\n\n  // only green category should be draggable with the mouse\n  mouseConstraint.collisionFilter.mask = greenCategory;\n\n  // radius ratio between category\n  var commonRatio = scale; // 7.5 / 5 = 1.5\n\n  // categories count\n  var numTerms = textures.length;\n\n  // create all possible radius sizes for the circle\n  var sizes = generateGeometricSequence(initialValue, commonRatio, numTerms);\n\n  // Array to store all possible circle category\n  var categories = [];\n  // generate all possible category for the circle\n  for (var _i = 0; _i < textures.length; _i++) {\n    categories.push({\n      size: sizes[_i],\n      category: _i,\n      texture: textures[_i],\n      textureScale: sizes[_i] / textureImageRadius\n    });\n  }\n\n  // create first circle and add to world\n  createCircle();\n  var allowNextCircle = true;\n  var timeToNextCircle = 1100;\n\n  // get start canvas position\n  var startCanvasPosition = window.innerWidth / 2 - CW / 2;\n  // get end canvas position\n  var endCanvasPosition = startCanvasPosition + CW;\n\n  // set circle position back to center when mouse outside the canvas\n  window.addEventListener(\"mousemove\", function (e) {\n    if (!allowNextCircle) return;\n\n    // get all circle body\n    var circles = getBodies();\n    var mouseX = e.x;\n    var mouseY = e.y;\n\n    // check if mouse position is out of canvas\n    if (mouseX < startCanvasPosition || mouseX > endCanvasPosition || mouseY < 0 || mouseY > CH) {\n      // update latest circle position here\n      Body.setPosition(circles[circles.length - 1], {\n        x: CW / 2,\n        y: positionY\n      });\n    }\n  });\n\n  // listen to mouse movement and update static circle position\n  Events.on(mouseConstraint, \"mousemove\", function (event) {\n    if (!allowNextCircle) return;\n    // get all circle body\n    var circles = getBodies();\n    var mouseX = event.mouse.position.x;\n    var mouseY = event.mouse.position.y;\n    // console.log(mouseX, mouseY)\n    // check if mouse position is out of canvas\n    if (mouseX < startCanvasPosition || mouseX > endCanvasPosition || mouseY < 0 || mouseY > CH) {\n      // update latest circle position here\n      Body.setPosition(circles[circles.length - 1], {\n        x: CW / 2,\n        y: positionY\n      });\n    }\n\n    // update latest circle position here\n    Body.setPosition(circles[circles.length - 1], {\n      x: mouseX,\n      y: positionY\n    });\n  });\n\n  // listen to mouse left click and set circle static to false\n  Events.on(mouseConstraint, \"mouseup\", function (event) {\n    if (allowNextCircle) {\n      allowNextCircle = false;\n      // get all circle body\n      var circles = getBodies();\n      // set latest circle isStatic to false here\n      Body.setStatic(circles[circles.length - 1], false);\n      // create next circle\n\n      // set timer to create next circle\n      setTimeout(function () {\n        allowNextCircle = true;\n        createCircle();\n      }, timeToNextCircle);\n    }\n  });\n  // handle collision between circle and floor\n  Events.on(engine, \"collisionStart\", function (event) {\n    var pairs = event.pairs;\n    for (var _i2 = 0; _i2 < pairs.length; _i2++) {\n      var bodyA = pairs[_i2].bodyA;\n      var bodyB = pairs[_i2].bodyB;\n      if (bodyA.label === \"Circle Body\" && bodyB.label === \"Floor\" || bodyB.label === \"Circle Body\" && bodyA.label === \"Floor\") {\n        sfx.hit.play();\n      }\n    }\n  });\n\n  // handle collision between two circle\n  Events.on(engine, \"collisionActive\", function (event) {\n    // pairs of active collision between two circle => []\n    var pairs = event.source.pairs.list;\n\n    // check collision between circles\n    for (var _i3 = 0; _i3 < pairs.length; _i3++) {\n      // get collided circle\n      var circleA = pairs[_i3].bodyA;\n      var circleB = pairs[_i3].bodyB;\n\n      // filter collided circle\n      if (checkCircleCollision(circleA, circleB)) {\n        // play collision audio\n        sfx.merge.play();\n\n        // remove circleA in world\n        Composite.remove(world, circleA);\n\n        // category is a number and it has 0 on it so we add 1 to prevent adding 0 value to gameScore\n        gameScore += circleB.category + 1;\n\n        // update circleB\n        // check previous circleB category\n        var prevCategory = circleB.category;\n        // update circleB category\n        var newCategory = prevCategory < textures.length ? categories[prevCategory + 1] : prevCategory;\n        // update depends on previous circleB category\n        Body.set(circleB, \"category\", newCategory.category);\n        // update body texture\n        Body.set(circleB.render.sprite, \"texture\", newCategory.texture);\n        // update body texture scale X\n        Body.set(circleB.render.sprite, \"xScale\", newCategory.textureScale);\n        // update body texture scale Y\n        Body.set(circleB.render.sprite, \"yScale\", newCategory.textureScale);\n        // update circleB radius\n        Body.scale(circleB, scale, scale);\n      }\n    }\n  });\n\n  // an example of using beforeUpdate event on an engine\n  Events.on(engine, \"beforeUpdate\", function (event) {\n    // draw game score\n    drawGameStatus();\n    // get all bodies in world\n    var circles = getBodies();\n    // game over condition\n    for (var _i4 = 0; _i4 < circles.length; _i4++) {\n      // check circle highest y coordinate\n      var y = circles[_i4].position.y - circles[_i4].circleRadius;\n      if (y <= 10 && !circles[_i4].isStatic) {\n        // stop bgm if playing\n        if (music.bgm.playing()) {\n          music.bgm.stop();\n        }\n        // play game over audio\n        if (!sfx.gameOver.playing()) {\n          sfx.gameOver.play();\n        }\n        gameOver = true;\n        // stop world for re render\n        Composite.clear(world, true);\n        Render.stop(render);\n      }\n    }\n  });\n\n  // create walls\n  var wallOptions = {\n    isStatic: true,\n    label: \"Wall\",\n    render: {\n      fillStyle: wallsColor\n    }\n  };\n  var topWall = Bodies.rectangle(CW / 2, 0, CW, wallThickness, wallOptions);\n  var bottomWall = Bodies.rectangle(CW / 2, CH, CW, floorThickness, {\n    isStatic: true,\n    label: \"Floor\",\n    render: {\n      fillStyle: wallsColor\n    }\n  });\n  var leftWall = Bodies.rectangle(0, CH / 2, wallThickness, CH, wallOptions);\n  var rightWall = Bodies.rectangle(CW, CH / 2, wallThickness, CH, wallOptions);\n  Composite.add(world, [topWall, rightWall, leftWall, bottomWall]);\n\n  // create hanging sign\n  var sign = Bodies.rectangle(50, 50, 100, 30, {\n    label: \"Sign\",\n    render: {\n      fillStyle: signColor\n    },\n    chamfer: {\n      radius: 3\n    }\n  });\n  var constraintRender = {\n    strokeStyle: \"#9b9b9b\",\n    lineWidth: 1.5\n  };\n  var constraintLength = 10;\n  var constraintLeft = Constraint.create({\n    bodyA: topWall,\n    pointA: {\n      x: 30 - CW / 2,\n      y: wallThickness / 2\n    },\n    bodyB: sign,\n    pointB: {\n      x: -40,\n      y: -15\n    },\n    render: constraintRender,\n    length: constraintLength\n  });\n  var constraintRight = Constraint.create({\n    bodyA: topWall,\n    pointA: {\n      x: 110 - CW / 2,\n      y: wallThickness / 2\n    },\n    bodyB: sign,\n    pointB: {\n      x: 40,\n      y: -15\n    },\n    render: constraintRender,\n    length: constraintLength\n  });\n  Composite.add(world, [constraintLeft, constraintRight, sign]);\n\n  /** UTILS **/\n  /**\n   * Draw game status on canvas\n   */\n  function drawGameStatus() {\n    if (gameOver) {\n      // draw game over message\n      ctx.save();\n      var fromX = CW / 2 - 145;\n      ctx.font = \"bold 50px Arial\";\n      ctx.fillStyle = \"#191919\";\n      ctx.fillText(\"GAME OVER\", fromX + 3, CH / 2 + 3);\n      ctx.fillStyle = \"#f4f4f4\";\n      ctx.fillText(\"GAME OVER\", fromX, CH / 2);\n      ctx.restore();\n    } else {\n      // update score ui\n      // get sign body\n      var signBody = Composite.allBodies(world).filter(function (body) {\n        return body.label === \"Sign\";\n      })[0];\n      var signX = signBody.position.x;\n      var signY = signBody.position.y;\n      ctx.save();\n      // draw game score\n      ctx.translate(signX, signY);\n      ctx.rotate(signBody.angle);\n      ctx.font = \"bold 15px Arial\";\n      ctx.fillStyle = \"#070707\";\n      ctx.fillText(\"SCORE: \".concat(gameScore.toString()), -38, 7);\n      ctx.fillStyle = \"#e9e9e9\";\n      ctx.fillText(\"SCORE: \".concat(gameScore.toString()), -40, 5);\n      ctx.restore();\n    }\n  }\n\n  /**\n   * Get random value from Array\n   * @return Array[random]\n   */\n  function getRandom(array) {\n    var randomIndex = Math.floor(Math.random() * array.length);\n    return array[randomIndex];\n  }\n  function generateGeometricSequence(initialValue, commonRatio, numTerms) {\n    var sequence = [];\n    var currentValue = initialValue;\n    for (var _i5 = 0; _i5 < numTerms; _i5++) {\n      sequence.push(currentValue);\n      currentValue *= commonRatio;\n    }\n    return sequence;\n  }\n\n  /**\n   * Get all circle body from world\n   * @return Body[]\n   */\n  function getBodies() {\n    return Composite.allBodies(world).filter(function (body) {\n      return body.label === \"Circle Body\";\n    });\n  }\n\n  /**\n   * create and add new circle to world\n   * @return Void\n   */\n  function createCircle() {\n    var category = getRandom(_toConsumableArray(categories.slice(0, 4)));\n    var options = {\n      isStatic: true,\n      restitution: 0.5,\n      // bounce level\n      category: category.category,\n      collisionFilter: {\n        mask: defaultCategory | redCategory\n      },\n      render: {\n        sprite: {\n          texture: category.texture,\n          xScale: category.textureScale,\n          yScale: category.textureScale\n        }\n      }\n    };\n    var circle = Bodies.circle(CW / 2, positionY, category.size, options);\n    Composite.add(world, circle);\n  }\n\n  /**\n   * Check collision between two circle\n   * @return Boolean\n   */\n  function checkCircleCollision(circleA, circleB) {\n    return circleA.category === circleB.category && circleA.circleRadius === circleB.circleRadius && circleA.label === \"Circle Body\" && circleB.label === \"Circle Body\" && !circleA.isStatic && !circleB.isStatic;\n  }\n});\n\n//# sourceURL=webpack://my-webpack-project/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;